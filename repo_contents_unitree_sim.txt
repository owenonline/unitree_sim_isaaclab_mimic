

===== .gitignore =====

# ================================
# Python
# ================================
*/__pycache__
*/__pycache__/
__pycache__
__pycache__
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# ================================
# env
# ================================
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/
conda-meta/

# ================================
# IDE 
# ================================
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store
Thumbs.db

# ================================
# Jupyter Notebook
# ================================
.ipynb_checkpoints
*.ipynb

# ================================
# æ—¥å¿—æ–‡ä»¶
# ================================
*.log
logs/
log/

# ================================
# ä»¿çœŸå’Œæœºå™¨äººç›¸å…³
# ================================
# Isaac Lab ç›¸å…³
.isaac/
isaac-sim/
kit/
logs/
videos/
screenshots/
*.usda


# ROS ç›¸å…³ï¼ˆå¦‚æœä½¿ç”¨ï¼‰
devel/
build/
install/
.catkin_workspace
*.pyc

# Gazebo ç›¸å…³
*.world~
models/




# ================================
# ç¼“å­˜å’Œä¸´æ—¶æ–‡ä»¶
# ================================
.cache/
.tmp/
tmp/
temp/
*.tmp
*.temp
*.bak
*.backup
*.old





# ================================
# Git ç›¸å…³
# ================================
*.orig
*.rej


data.*
data/

assets/
assets.*
assets

===== LICENSE =====

Copyright [2025] [HangZhou YuShu TECHNOLOGY CO.,LTD. ("Unitree Robotics")]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

------------------

This code builds upon following open-source code-bases. Please visit the URLs to see the respective LICENSES:

1. https://github.com/isaac-sim/IsaacLab
2. https://github.com/isaac-sim/IsaacSim
3. https://github.com/zeromq/pyzmq
4. https://github.com/unitreerobotics/unitree_sdk2_python

------------------


===== README.md =====

<div align="center">
  <h1 align="center"> unitree_sim_isaaclab </h1>
  <h3 align="center"> Unitree Robotics </h3>
  <p align="center">
    <a> English </a> | <a href="README_zh-CN.md">ä¸­æ–‡</a> 
  </p>
  <a href="https://discord.gg/ZwcVwxv5rq" target="_blank"><img src="https://img.shields.io/badge/-Discord-5865F2?style=flat&logo=Discord&logoColor=white" alt="Unitree LOGO"></a>
</div>

## Important Notes First
- Please use the [officially recommended](https://isaac-sim.github.io/IsaacLab/main/source/setup/installation/index.html) hardware resources for deployment
- The simulator may take some time to load resources during its first startup, and the waiting time depends on hardware performance and network environment
- After the simulator starts running, it will send/receive the same DDS topics as the real robot (Please note to distinguish between the simulator and real robot if there is a real robot running on the same network). For specific DDS usage, please refer to[G1 Control](https://github.com/unitreerobotics/unitree_sdk2_python/tree/master/example/g1) and [Dex3 Dexterous Hand Control](https://github.com/unitreerobotics/unitree_sdk2/blob/main/example/g1/dex3/g1_dex3_example.cpp)
- The weight files provided in this project are only for simulation environment testing
- Currently, our project has only been tested on RTX 3080, RTX 3090, and RTX 4090 GPUs. For the RTX 50 series GPUs, please use Isaac Sim version 5.0.0
- After the virtual scene starts up, please click PerspectiveCamera -> Cameras -> PerspectiveCamera to view the main view scene. The operation steps are shown below:
<table align="center">
    <tr>
    <td align="center">
        <img src="./img/mainview.png" width="300" alt="G1-gripper-cylinder"/>
      <br/>
      <code>Main View Finding Steps</code>
    </td>
    </tr>
</table>

## 1ã€ ğŸ“– Introduction

This project is built on **Isaac Lab** to simulate **Unitree robots** in various tasks, facilitating data collection, playback, generation, and model validation. It can be used in conjunction with the [xr_teleoperate](https://github.com/unitreerobotics/xr_teleoperate) repository for dataset collection. The project adopts the same DDS communication protocol as the real robot to enhance code generality and ease of use.

Currently, the project employs Unitree G1/H1-2 robots equipped with different actuators, and provides simulation scenarios for multiple tasks. The task names and corresponding illustrations are summarized in the table below. Tasks that include `Wholebody` in their names enable mobile operations.

<table align="center">
  <tr>
    <th>G1-29dof-gripper</th>
    <th>G1-29dof-dex3</th>
    <th>G1-29dof-inspire</th>
    <th>H1-2-inspire</th>
  </tr>
  <tr>
    <td align="center">
      <img src="./img/pickplace_clinder_g129_dex1.png" width="300" alt="G1-gripper-cylinder"/>
      <br/>
      <code>Isaac-PickPlace-Cylinder-G129-Dex1-Joint</code>
    </td>
    <td align="center">
      <img src="./img/pickplace_clinder_g129_dex3.png" width="300" alt="G1-dex3-cylinder"/>
      <br/>
      <code>Isaac-PickPlace-Cylinder-G129-Dex3-Joint</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-PickPlace-Cylinder-G129-Inspire-Joint.png" width="300" alt="G1-dex3-cylinder"/>
      <br/>
      <code>Isaac-PickPlace-Cylinder-G129-Inspire-Joint</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-PickPlace-Cylinder-H12-27dof-Inspire-Joint.png" width="300" alt="G1-gripper-redblock"/>
      <br/>
      <code>Isaac-PickPlace-Cylinder-H12-27dof-Inspire-Joint</code>
    </td>
  </tr>
  <tr>
    <td align="center">
      <img src="./img/pickplace_redblock_g129_dex1.png" width="300" alt="G1-gripper-redblock"/>
      <br/>
      <code>Isaac-PickPlace-RedBlock-G129-Dex1-Joint</code>
    </td>
    <td align="center">
      <img src="./img/pickplace_redblock_g129_dex3.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-PickPlace-RedBlock-G129-Dex3-Joint</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-PickPlace-RedBlock-G129-Inspire-Joint.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-PickPlace-RedBlock-G129-Inspire-Joint</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-PickPlace-RedBlock-H12-27dof-Inspire-Joint.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-PickPlace-RedBlock-H12-27dof-Inspire-Joint</code>
    </td>
  </tr>
  <tr>
    <td align="center">
      <img src="./img/stack_rgyblock_g129_dex1.png" width="300" alt="G1-gripper-redblock"/>
      <br/>
      <code>Isaac-Stack-RgyBlock-G129-Dex1-Joint</code>
    </td>
    <td align="center">
      <img src="./img/stack_rgyblock_g129_dex3.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-Stack-RgyBlock-G129-Dex3-Joint</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-Stack-RgyBlock-G129-Inspire-Joint.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-Stack-RgyBlock-G129-Inspire-Joint</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-Stack-RgyBlock-H12-27dof-Inspire-Joint.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code> Isaac-Stack-RgyBlock-H12-27dof-Inspire-Joint</code>
    </td>
  </tr>
    <tr>
    <td align="center">
      <img src="./img/Isaac-Move-Cylinder-G129-Dex1-Wholebody.png" width="300" alt="G1-gripper-redblock"/>
      <br/>
      <code>Isaac-Move-Cylinder-G129-Dex1-Wholebody</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-Move-Cylinder-G129-Dex3-Wholebody.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-Move-Cylinder-G129-Dex3-Wholebody</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-Move-Cylinder-G129-Inspire-Wholebody.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-Move-Cylinder-G129-Inspire-Wholebody</code>
    </td>
  </tr>
</table>

## 2ã€âš™ï¸ Environment Setup and Running

This project requires Isaac Sim 4.5.0/Isaac Sim 5.0.0 and Isaac Lab. You can refer to the [official installation guide](https://isaac-sim.github.io/IsaacLab/main/source/setup/installation/pip_installation.html)  or follow the steps below. The installation methods for Ubuntu 20.04 and Ubuntu 22.04 (and later versions) are different. Please choose the installation method based on your system version and GPU resources.

### 2.1 Isaac Sim 4.5.0 Environment Installation (Recommended for RTX 4080 and below)

Please refer to the <a href="doc/isaacsim4.5_install.md">Isaac Sim 4.5.0 Environment Installation Steps</a> for the setup.

### 2.2 Isaac Sim 5.0.0 Environment Installation (Recommended for RTX 4080 and above)

Please refer to the <a href="doc/isaacsim5.0_install.md">Isaac Sim 5.0.0 Environment Installation Steps</a> for the setup.

### 2.3 Build the Docker Environment (Using Ubuntu 22.04 / IsaacSim 5.0)

#### 2.3.1 Build the Docker environment
```shell
sudo docker pull nvidia/cuda:12.2.0-runtime-ubuntu22.04
cd unitree_sim_isaaclab
sudo docker build \
  --build-arg http_proxy=http://127.0.0.1:7890 \
  --build-arg https_proxy=http://127.0.0.1:7890 \
  -t unitree-sim:latest -f Dockerfile .

# If you need to use a proxy, please fill in
# --build-arg http_proxy=http://127.0.0.1:7890 --build-arg https_proxy=http://127.0.0.1:7890
```

#### 2.3.2 Enter the Docker environment

```shell
xhost +local:docker

sudo docker run --gpus all -it --rm   --network host   -e NVIDIA_VISIBLE_DEVICES=all   -e NVIDIA_DRIVER_CAPABILITIES=compute,utility,video,graphics,display   -e LD_LIBRARY_PATH=/usr/local/nvidia/lib:/usr/local/nvidia/lib64:$LD_LIBRARY_PATH   -e DISPLAY=$DISPLAY   -e VK_ICD_FILENAMES=/etc/vulkan/icd.d/nvidia_icd.json   -v /etc/vulkan/icd.d:/etc/vulkan/icd.d:ro   -v /usr/share/vulkan/icd.d:/usr/share/vulkan/icd.d:ro   -v /tmp/.X11-unix:/tmp/.X11-unix:rw   -v /home/unitree/newDisk/unitree_sim_isaaclab_usds:/home/code/isaacsim_assets   unitree-isaacsim-env /bin/bash

# The option `-v /home/unitree/newDisk/unitree_sim_isaaclab_usds:/home/code/isaacsim_assets` maps the `unitree_sim_isaaclab_usds` directory on the host machine to `isaacsim_assets` inside the Docker container, making it convenient to share data between the host and the container. Please modify it according to your own setup.
```

### 2.4 Run Program

#### 2.4.1 Asset Download

Use the following command to download the required asset files

```
sudo apt update

sudo apt install git-lfs

. fetch_assets.sh
```

#### 2.4.2 Teleoperation

```
python sim_main.py --device cpu  --enable_cameras  --task  Isaac-PickPlace-Cylinder-G129-Dex1-Joint    --enable_dex1_dds --robot_type g129
```

- --task: Task name, corresponding to the task names in the table above
- --enable_dex1_dds/--enable_dex3_dds: Represent enabling DDS for two-finger gripper/three-finger dexterous hand respectively  
- --robot_type: Robot type, currently has 29-DOF unitree g1 (g129),27-DoF H1-2
- --headless: This allows running without launching the simulation window. Add this parameter if you're using a Docker environment.

**Note:** If you need to control robot movement, please refer to `send_commands_8bit.py` or `send_commands_keyboard.py` to publish control commands, or you can use them directly. Please note that only tasks marked with `Wholebody` are mobile tasks and can control the robot's movement.

#### 2.4.3 Data Replay

```
python sim_main.py --device cpu  --enable_cameras  --task Isaac-Stack-RgyBlock-G129-Dex1-Joint     --enable_dex1_dds --robot_type g129 --replay  --file_path "/home/unitree/Code/xr_teleoperate/teleop/utils/data" 
```
- --replay: Specifies whether to perform data replay.

- --file_path: Directory where the dataset is stored (please update this to your own dataset path).


**Note:** The dataset format used here is consistent with the one recorded via teleoperation in [xr_teleoperate](https://github.com/unitreerobotics/xr_teleoperate) .

**Note:** For task-discrete rewards, you can use the `get_step_reward_value` function to retrieve them.


#### 2.4.4 Data Generation
During data replay, by modifying lighting conditions and camera parameters and re-capturing image data, more diverse visual features can be generated for data augmentation, thereby improving the modelâ€™s generalization ability.
```
python sim_main.py --device cpu  --enable_cameras  --task Isaac-Stack-RgyBlock-G129-Dex1-Joint     --enable_dex1_dds --robot_type g129 --replay  --file_path "/home/unitree/Code/xr_teleoperate/teleop/utils/data" --generate_data --generate_data_dir "./data2"
```

- --generate_data: Enables generation of new data.

- --generate_data_dir: Directory to store the newly generated data.

- --rerun_log: Enables logging during data generation.

- --modify_light: Enables modification of lighting conditions (you need to adjust the update_light function in main accordingly).

- --modify_camera: Enables modification of camera parameters (you need to adjust the batch_augment_cameras_by_name function in main accordingly).

**Note:**
If you wish to modify lighting or camera parameters, please tune and test the parameters carefully before performing large-scale data generation.

## 3ã€Task Scene Construction

### 3.1 Code Structure

```
unitree_sim_isaaclab/
â”‚
â”œâ”€â”€ action_provider                   [Action providers, provides interfaces for reading file actions, receiving DDS actions, policy-generated actions, etc. Currently mainly uses DDS-based action acquisition]
â”‚
â”œâ”€â”€ dds                               [DDS communication module, implements DDS communication for g1, gripper, and three-finger dexterous hand]
â”‚
â”œâ”€â”€ image_server                      [Image publishing service, uses ZMQ for image publishing]
â”‚
â”œâ”€â”€ layeredcontrol                    [Low-level control module, gets actions and sets them in virtual environment]
â”‚
â”œâ”€â”€ robots                            [Basic robot configurations]
â”‚
â”œâ”€â”€ tasks                             [Task-related files]
â”‚   â”œâ”€â”€ common_config
â”‚   â”‚     â”œâ”€â”€ camera_configs.py       [Camera placement related configurations]
â”‚   â”‚     â”œâ”€â”€ robot_configs.py        [Robot setup related configurations]
â”‚   â”‚
â”‚   â”œâ”€â”€ common_event
â”‚   â”‚      â”œâ”€â”€ event_manager.py       [Event registration management]  
â”‚   â”‚
â”‚   â”œâ”€â”€ common_observations
â”‚   â”‚      â”œâ”€â”€ camera_state.py        [Camera data acquisition]  
â”‚   â”‚      â”œâ”€â”€ dex3_state.py          [Three-finger dexterous hand data acquisition]
â”‚   â”‚      â”œâ”€â”€ g1_29dof_state.py      [Robot state data acquisition]
â”‚   â”‚      â”œâ”€â”€ gripper_state.py       [Gripper data acquisition]
â”‚   â”‚
â”‚   â”œâ”€â”€ common_scene                
â”‚   â”‚      â”œâ”€â”€ base_scene_pickplace_cylindercfg.py         [Common scene for cylinder grasping task]  
â”‚   â”‚      â”œâ”€â”€ base_scene_pickplace_redblock.py            [Common scene for red block grasping task] 
â”‚   â”‚
â”‚   â”œâ”€â”€ common_termination                                 [Judgment of whether objects in different tasks exceed specified working range]
â”‚   â”‚      â”œâ”€â”€ base_termination_pick_place_cylinder         
â”‚   â”‚      â”œâ”€â”€ base_termination_pick_place_redblock 
â”‚   â”‚
â”‚   â”œâ”€â”€ g1_tasks                                            [All g1-related tasks]
â”‚   â”‚      â”œâ”€â”€ pick_place_cylinder_g1_29dof_dex1            [Cylinder grasping task]
â”‚   â”‚      â”‚     â”œâ”€â”€ mdp                                      
â”‚   â”‚      â”‚     â”‚     â”œâ”€â”€ observations.py                  [Observation data]
â”‚   â”‚      â”‚     â”‚     â”œâ”€â”€ terminations.py                  [Termination judgment conditions]
â”‚   â”‚      â”‚     â”œâ”€â”€ __init__.py                            [Task name registration]  
â”‚   â”‚      â”‚     â”œâ”€â”€ pickplace_cylinder_g1_29dof_dex1_joint_env_cfg.py           [Task-specific scene import and related class initialization]
â”‚   â”‚      â”œâ”€â”€ ...
â”‚   â”‚      â”œâ”€â”€ __init__.py                                  [Display all task names existing in g1]
â”‚   â”œâ”€â”€ utils                                               [Utility functions]
â”œâ”€â”€ tools                                                   [USD conversion and modification related tools]
â”œâ”€â”€ usd                                                     [USD model files]
â”œâ”€â”€ sim_main.py                                             [Main function] 
â”œâ”€â”€ reset_pose_test.py                                      [Test function for object position reset] 
```

### 3.2 Task Scene Construction Steps
If using existing robot configurations (G1-29dof-gripper, G1-29dof-dex3) to build new task scenes, just follow the steps below:

#### 3.2.1ã€Build Common Parts of Task Scene (i.e., scenes other than the robot)
According to existing task configurations, add new task common scene configurations in the common_scene directory. You can refer to existing task common configuration files.
#### 3.2.2 Termination or Object Reset Condition Judgment
Add termination or object reset judgment conditions according to your scene needs in the common_termination directory
#### 3.2.3 Add and Register Tasks
Add new task directories in the g1_tasks directory and modify related files following existing tasks. Taking the pick_place_cylinder_g1_29dof_dex1 task as an example:

- observations.py: Add corresponding observation functions, just import the corresponding files as needed
 ```

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.gripper_state import get_robot_gipper_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_gipper_joint_states", 
    "get_camera_image"
]

 ```
- terminations.py: Add corresponding condition judgment functions, import corresponding files from common_termination
 ```
 from tasks.common_termination.base_termination_pick_place_cylinder import reset_object_estimate
__all__ = [
"reset_object_estimate"
]
 ```

- pick_place_cylinder_g1_29dof_dex1/```__init__.py ```

Add ```__init__.py``` in the new task directory and add task name, as shown in the ```__init__.py``` under pick_place_cylinder_g1_29dof_dex1:

```
# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import gymnasium as gym

from . import pickplace_cylinder_g1_29dof_dex1_joint_env_cfg


gym.register(
    id="Isaac-PickPlace-Cylinder-G129-Dex1-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": pickplace_cylinder_g1_29dof_dex1_joint_env_cfg.PickPlaceG129DEX1BaseFixEnvCfg,
    },
    disable_env_checker=True,
)


```
- Write the environment configuration file corresponding to the task, such as pickplace_cylinder_g1_29dof_dex1_joint_env_cfg.py

Import common scenes, set robot positions, and add camera configurations

- Modify g1_tasks/```__init__.py```

Add the new task configuration class to the ```__init__.py``` file in the g1_tasks directory as follows:

```

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""Unitree G1 robot task module
contains various task implementations for the G1 robot, such as pick and place, motion control, etc.
"""

# use relative import
from . import pick_place_cylinder_g1_29dof_dex3
from . import pick_place_cylinder_g1_29dof_dex1
from . import pick_place_redblock_g1_29dof_dex1
from . import pick_place_redblock_g1_29dof_dex3
# export all modules
__all__ = ["pick_place_cylinder_g1_29dof_dex3", "pick_place_cylinder_g1_29dof_dex1", "pick_place_redblock_g1_29dof_dex1", "pick_place_redblock_g1_29dof_dex3"]

```
### ğŸ“‹ TODO List

- â¬œ Continue adding new task scenes
- â¬œ Continue code optimization 

## ğŸ™ Acknowledgement

This code builds upon following open-source code-bases. Please visit the URLs to see the respective LICENSES:

1. https://github.com/isaac-sim/IsaacLab
2. https://github.com/isaac-sim/IsaacSim
3. https://github.com/zeromq/pyzmq
4. https://github.com/unitreerobotics/unitree_sdk2_python

===== README_zh-CN.md =====

<div align="center">
  <h1 align="center"> unitree_sim_isaaclab </h1>
  <h3 align="center"> Unitree Robotics </h3>
  <p align="center">
    <a href="README.md"> English </a> | <a >ä¸­æ–‡</a> 
  </p>
    <p align="center">
    <a href="https://discord.gg/ZwcVwxv5rq" target="_blank"><img src="https://img.shields.io/badge/-Discord-5865F2?style=flat&logo=Discord&logoColor=white" alt="Unitree LOGO"></a>
  </p>
</div>

## é‡è¦äº‹æƒ…æå‰è¯´
- è¯·ä½¿ç”¨[å®˜æ–¹æ¨è](https://isaac-sim.github.io/IsaacLab/main/source/setup/installation/index.html)çš„ç¡¬ä»¶èµ„æºè¿›è¡Œéƒ¨ç½²ä½¿ç”¨
- ä»¿çœŸå™¨åœ¨ç¬¬ä¸€æ¬¡å¯åŠ¨çš„æ—¶å€™ç”±äºå…¶è‡ªèº«éœ€è¦åŠ è½½èµ„æºå¯èƒ½ä¼šç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œå…·ä½“ç­‰å¾…æ—¶é—´ä¸ç¡¬ä»¶æ€§èƒ½ä»¥åŠç½‘ç»œç¯å¢ƒæœ‰å…³
- ä»¿çœŸå™¨è¿è¡Œèµ·æ¥ä»¥åä¼šå‘é€/æ¥æ”¶å’ŒçœŸå®æœºå™¨äººä¸€æ ·çš„DDSè¯é¢˜(å¦‚æœåŒä¸€ç½‘è·¯ä¸­æœ‰çœŸå®æœºå™¨äººè¿è¡Œè¯·æ³¨æ„åŒºåˆ†)ï¼ŒDDSçš„ä½¿ç”¨å…·ä½“å¯å‚è€ƒ[G1æ§åˆ¶](https://github.com/unitreerobotics/unitree_sdk2_python/tree/master/example/g1)ã€[Dex3çµå·§æ‰‹æ§åˆ¶](https://github.com/unitreerobotics/unitree_sdk2/blob/main/example/g1/dex3/g1_dex3_example.cpp)
- é¡¹ç›®ä¸­æä¾›çš„æƒé‡æ–‡ä»¶åªé’ˆå¯¹ä»¿çœŸç¯å¢ƒæµ‹è¯•ä½¿ç”¨
- ç›®å‰é¡¹ç›®æˆ‘ä»¬åªåœ¨RTX3080ã€RTX3090ä»¥åŠRTX4090ä¸Šè¿›è¡Œæµ‹è¯•ã€‚RTX50ç³»åˆ—æ˜¾å¡è¯·ä½¿ç”¨IsaacSim 5.0.0ç‰ˆæœ¬
- è™šæ‹Ÿåœºæ™¯å¯åŠ¨ä»¥åè¯·ç‚¹å‡» PerspectiveCamera -> Cameras -> PerspectiveCamera æŸ¥çœ‹ä¸»è§†å›¾çš„åœºæ™¯ã€‚æ“ä½œæ­¥éª¤å¦‚ä¸‹å›¾æ‰€ç¤º:
<table align="center">
    <tr>
    <td align="center">
        <img src="./img/mainview.png" width="300" alt="G1-gripper-cylinder"/>
      <br/>
      <code>ä¸»è§†å›¾æŸ¥æ‰¾æ­¥éª¤</code>
    </td>
    </tr>
</table>

## 1ã€ ğŸ“– ä»‹ç»
è¯¥é¡¹ç›®åŸºäºIsaac Lab æ­å»º**å®‡æ ‘(Unitree)æœºå™¨äºº**åœ¨ä¸åŒä»»åŠ¡ä¸‹çš„ä»¿çœŸåœºæ™¯ï¼Œæ–¹ä¾¿è¿›è¡Œæ•°æ®é‡‡é›†ã€æ•°æ®å›æ”¾ã€æ•°æ®ç”Ÿæˆä»¥åŠæ¨¡å‹éªŒè¯ã€‚å¯ä»¥ä¸[xr_teleoperate](https://github.com/unitreerobotics/xr_teleoperate)ä»£ç é…åˆè¿›è¡Œæ•°æ®é›†çš„é‡‡é›†ã€‚è¯¥é¡¹ç›®é‡‡ç”¨äº†ä¸çœŸå®æœºå™¨äººä¸€æ ·çš„DDSé€šä¿¡ï¼Œä»¥æé«˜ä»£ç çš„é€šç”¨æ€§å’Œä½¿ç”¨çš„ç®€æ˜“æ€§ã€‚

ç›®å‰è¯¥é¡¹ç›®ä½¿ç”¨äº†å¸¦æœ‰ä¸åŒæ‰§è¡Œå™¨çš„Unitree G1/H1-2æœºå™¨äººï¼Œå¹¶ä¸”æ­å»ºäº†ä¸åŒä»»åŠ¡çš„ä»¿çœŸåœºæ™¯ï¼Œå…·ä½“ä»»åŠ¡åœºæ™¯åç§°ä¸å›¾ç¤ºå¦‚ä¸‹è¡¨,å…¶ä¸­ä»»åŠ¡åç§°ä¸­å¸¦æœ‰ `Wholebody`çš„ä»»åŠ¡å¯ä»¥è¿›è¡Œç§»åŠ¨æ“ä½œï¼š


<table align="center">
  <tr>
    <th>G1-29dof-gripper</th>
    <th>G1-29dof-dex3</th>
    <th>G1-29dof-inspire</th>
    <th>H1-2-inspire</th>
  </tr>
  <tr>
    <td align="center">
      <img src="./img/pickplace_clinder_g129_dex1.png" width="300" alt="G1-gripper-cylinder"/>
      <br/>
      <code>Isaac-PickPlace-Cylinder-G129-Dex1-Joint</code>
    </td>
    <td align="center">
      <img src="./img/pickplace_clinder_g129_dex3.png" width="300" alt="G1-dex3-cylinder"/>
      <br/>
      <code>Isaac-PickPlace-Cylinder-G129-Dex3-Joint</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-PickPlace-Cylinder-G129-Inspire-Joint.png" width="300" alt="G1-dex3-cylinder"/>
      <br/>
      <code>Isaac-PickPlace-Cylinder-G129-Inspire-Joint</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-PickPlace-Cylinder-H12-27dof-Inspire-Joint.png" width="300" alt="G1-gripper-redblock"/>
      <br/>
      <code>Isaac-PickPlace-Cylinder-H12-27dof-Inspire-Joint</code>
    </td>
  </tr>
  <tr>
    <td align="center">
      <img src="./img/pickplace_redblock_g129_dex1.png" width="300" alt="G1-gripper-redblock"/>
      <br/>
      <code>Isaac-PickPlace-RedBlock-G129-Dex1-Joint</code>
    </td>
    <td align="center">
      <img src="./img/pickplace_redblock_g129_dex3.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-PickPlace-RedBlock-G129-Dex3-Joint</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-PickPlace-RedBlock-G129-Inspire-Joint.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-PickPlace-RedBlock-G129-Inspire-Joint</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-PickPlace-RedBlock-H12-27dof-Inspire-Joint.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-PickPlace-RedBlock-H12-27dof-Inspire-Joint</code>
    </td>
  </tr>
  <tr>
    <td align="center">
      <img src="./img/stack_rgyblock_g129_dex1.png" width="300" alt="G1-gripper-redblock"/>
      <br/>
      <code>Isaac-Stack-RgyBlock-G129-Dex1-Joint</code>
    </td>
    <td align="center">
      <img src="./img/stack_rgyblock_g129_dex3.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-Stack-RgyBlock-G129-Dex3-Joint</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-Stack-RgyBlock-G129-Inspire-Joint.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-Stack-RgyBlock-G129-Inspire-Joint</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-Stack-RgyBlock-H12-27dof-Inspire-Joint.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code> Isaac-Stack-RgyBlock-H12-27dof-Inspire-Joint</code>
    </td>
  </tr>
    <tr>
    <td align="center">
      <img src="./img/Isaac-Move-Cylinder-G129-Dex1-Wholebody.png" width="300" alt="G1-gripper-redblock"/>
      <br/>
      <code>Isaac-Move-Cylinder-G129-Dex1-Wholebody</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-Move-Cylinder-G129-Dex3-Wholebody.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-Move-Cylinder-G129-Dex3-Wholebody</code>
    </td>
    <td align="center">
      <img src="./img/Isaac-Move-Cylinder-G129-Inspire-Wholebody.png" width="300" alt="G1-dex3-redblock"/>
      <br/>
      <code>Isaac-Move-Cylinder-G129-Inspire-Wholebody</code>
    </td>
  </tr>
</table>

## 2ã€âš™ï¸ ç¯å¢ƒé…ç½®ä¸è¿è¡Œ
è¯¥é¡¹ç›®éœ€è¦å®‰è£…Isaac Sim 4.5.0/Isaac Sim 5.0.0ä»¥åŠIsaac Labï¼Œå…·ä½“å®‰è£…å¯å‚è€ƒ[å®˜æ–¹æ•™ç¨‹](https://isaac-sim.github.io/IsaacLab/main/source/setup/installation/pip_installation.html).æˆ–è€…æŒ‰ç…§ä¸‹é¢æµç¨‹è¿›è¡Œå®‰è£…ã€‚Ubuntu 20.4ä¸Ubuntu 22.4ä»¥åŠä»¥ä¸Šç‰ˆæœ¬å®‰è£…æ–¹å¼ä¸åŒï¼Œè¯·æ ¹æ®è‡ªå·±çš„ç³»ç»Ÿç‰ˆæœ¬ä»¥åŠæ˜¾å¡èµ„æºè¿›è¡Œå®‰è£…ã€‚

### 2.1 Isaac Sim 4.5.0ç›¸å…³ç¯å¢ƒå®‰è£…ï¼ˆRTX4080ä»¥ä¸‹æ¨èå®‰è£…ï¼‰

è¯·å‚è€ƒ<a href="doc/isaacsim4.5_install_zh.md"> isaacsim 4.5.0 ç¯å¢ƒå®‰è£…æ­¥éª¤ </a> è¿›è¡Œç¯å¢ƒå®‰è£…

### 2.2 Isaac Sim 5.0.0ç›¸å…³ç¯å¢ƒå®‰è£…ï¼ˆRTX4080ä»¥åŠä»¥ä¸Šæ¨èå®‰è£…ï¼‰
è¯·å‚è€ƒ<a href="doc/isaacsim5.0_install_zh.md"> isaacsim 5.0.0 ç¯å¢ƒå®‰è£…æ­¥éª¤ </a> è¿›è¡Œç¯å¢ƒå®‰è£…

### 2.3 æ„å»ºdockerç¯å¢ƒï¼ˆä½¿ç”¨çš„æ˜¯Ubuntu22.04/IsaacSim 5.0ï¼‰
#### 2.3.1 æ„å»ºdocker
```bash
sudo docker pull nvidia/cuda:12.2.0-runtime-ubuntu22.04
cd   unitree_sim_isaaclab
sudo docker build   --build-arg http_proxy=http://127.0.0.1:7890   --build-arg https_proxy=http://127.0.0.1:7890   -t unitree-sim:latest -f Dockerfile .
#  å¦‚æœéœ€è¦ä½¿ç”¨ä»£ç†è¯·å¡«å†™- -build-arg http_proxy=http://127.0.0.1:7890   --build-arg https_proxy=http://127.0.0.1:7890

```
#### 2.3.2 è¿›å…¥docker

```shell
xhost +local:docker

sudo docker run --gpus all -it --rm   --network host   -e NVIDIA_VISIBLE_DEVICES=all   -e NVIDIA_DRIVER_CAPABILITIES=compute,utility,video,graphics,display   -e LD_LIBRARY_PATH=/usr/local/nvidia/lib:/usr/local/nvidia/lib64:$LD_LIBRARY_PATH   -e DISPLAY=$DISPLAY   -e VK_ICD_FILENAMES=/etc/vulkan/icd.d/nvidia_icd.json   -v /etc/vulkan/icd.d:/etc/vulkan/icd.d:ro   -v /usr/share/vulkan/icd.d:/usr/share/vulkan/icd.d:ro   -v /tmp/.X11-unix:/tmp/.X11-unix:rw   -v /home/unitree/newDisk/unitree_sim_isaaclab_usds:/home/code/isaacsim_assets   unitree-isaacsim-env /bin/bash

#å…¶ä¸­ -v /home/unitree/newDisk/unitree_sim_isaaclab_usds:/home/code/isaacsim_assets æ˜¯æŠŠå®¿ä¸»æœºä¸­çš„unitree_sim_isaaclab_usdsç›®å½•æ˜ å°„åˆ°dockerå®¹å™¨çš„isaacsim_assetsä¸­ï¼Œæ–¹ä¾¿è¿›è¡Œæ•°æ®çš„å…±äº«ï¼Œè¯·æ ¹æ®è‡ªå·±æƒ…å†µä¿®æ”¹ã€‚

```
### 2.4 è¿è¡Œç¨‹åº

#### 2.4.1 èµ„äº§ä¸‹è½½

ä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤ä¸‹è½½éœ€è¦çš„èµ„äº§æ–‡ä»¶

```
sudo apt update

sudo apt install git-lfs

. fetch_assets.sh
```

#### 2.4.2 é¥æ“ä½œ

```
python sim_main.py --device cpu  --enable_cameras  --task  Isaac-PickPlace-Cylinder-G129-Dex1-Joint    --enable_dex1_dds --robot_type g129
```

- --task: ä»»åŠ¡åç§°ï¼Œå¯¹åº”ä¸Šè¡¨ä¸­çš„ä»»åŠ¡åç§°
- --enable_dex1_dds/--enable_dex3_dds: åˆ†åˆ«ä»£è¡¨å¯ç”¨äºŒæŒ‡å¤¹çˆª/ä¸‰æŒ‡çµå·§æ‰‹çš„dds
- --robot_type: æœºå™¨äººç±»å‹ï¼Œç›®å‰æœ‰29è‡ªç”±åº¦çš„unitree g1(g129),27è‡ªç”±åº¦çš„H1-2
- --headless: ä¸å¯åŠ¨Simçª—å£ä¸‹è¿è¡Œ,å¦‚æœä½¿ç”¨Dockerç¯å¢ƒè¿›è¡Œè¿è¡Œè¯·æ·»åŠ æ­¤å‚æ•°

**æ³¨æ„:** å¦‚éœ€è¦æ§åˆ¶æœºå™¨äººç§»åŠ¨ï¼Œè¯·å‚è€ƒ`send_commands_8bit.py` æˆ–è€… `send_commands_keyboard.py` å‘å¸ƒæ§åˆ¶å‘½ä»¤ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨ã€‚ä½†æ˜¯è¯·æ³¨æ„åªæœ‰å¸¦æœ‰`Wholebody`æ ‡è¯†çš„æ‰æ˜¯ç§»åŠ¨å‹ä»»åŠ¡ï¼Œæ‰èƒ½æ§åˆ¶æœºå™¨äººç§»åŠ¨ã€‚

#### 2.4.3 æ•°æ®å›æ”¾

```
python sim_main.py --device cpu  --enable_cameras  --task Isaac-Stack-RgyBlock-G129-Dex1-Joint     --enable_dex1_dds --robot_type g129 --replay  --file_path "/home/unitree/Code/xr_teleoperate/teleop/utils/data" 
```
- --replay: ç”¨äºåˆ¤æ–­æ˜¯å¦è¿›è¡Œæ•°æ®å›æ”¾
- --file_path: æ•°æ®é›†å­˜æ”¾çš„ç›®å½•(è¯·ä¿®æ”¹è‡ªå·±çš„æ•°æ®é›†è·¯å¾„)ã€‚

**æ³¨æ„ï¼š** è¿™é‡Œä½¿ç”¨çš„æ•°æ®é›†å­˜æ”¾æ ¼å¼æ˜¯ä¸[xr_teleoperate](https://github.com/unitreerobotics/xr_teleoperate)é¥æ“ä½œå½•åˆ¶çš„æ•°æ®é›†æ ¼å¼ä¸€è‡´ã€‚

**æ³¨æ„:** é’ˆå¯¹ä»»åŠ¡ç¦»æ•£çš„Rewardå¯ä»¥ä½¿ç”¨ 'get_step_reward_value' å‡½æ•°è·å–
#### 2.4.4 æ•°æ®ç”Ÿæˆ
é€šè¿‡åœ¨æ•°æ®å›æ”¾è¿‡ç¨‹ä¸­è°ƒæ•´å…‰ç…§æ¡ä»¶å’Œç›¸æœºå‚æ•°ï¼Œå¹¶é‡æ–°é‡‡é›†å›¾åƒæ•°æ®ï¼Œå¯ç”¨äºç”Ÿæˆå…·æœ‰å¤šæ ·åŒ–è§†è§‰ç‰¹å¾çš„å¢å¼ºæ•°æ®ï¼Œä»è€Œæå‡æ¨¡å‹çš„æ³›åŒ–èƒ½åŠ›ã€‚

```
 python sim_main.py --device cpu  --enable_cameras  --task Isaac-Stack-RgyBlock-G129-Dex1-Joint     --enable_dex1_dds --robot_type g129 --replay  --file_path "/home/unitree/Code/xr_teleoperate/teleop/utils/data" --generate_data --generate_data_dir "./data2"
```
- --generate_data: æ˜¯å¦ç”Ÿæˆæ–°çš„æ•°æ®
- --generate_data_dir: æ–°æ•°æ®å­˜æ”¾çš„è·¯å¾„
- --rerun_log: æ˜¯å¦å¼€å¯æ•°æ®å½•åˆ¶æ—¥å¿—
- --modify_light: æ˜¯å¦ä¿®æ”¹å…‰ç…§æ¡ä»¶(è¿™ä¸ªéœ€è¦è‡ªå·±æ ¹æ®éœ€æ±‚ä¿®æ”¹mainå‡½æ•°ä¸­update_lightçš„å‚æ•°)
- --modify_camera: æ˜¯å¦ä¿®æ”¹ç›¸æœºå‚æ•°(è¿™ä¸ªéœ€è¦è‡ªå·±æ ¹æ®éœ€æ±‚ä¿®æ”¹mainå‡½æ•°ä¸­batch_augment_cameras_by_nameå‚æ•°)

**æ³¨æ„:** å¦‚éœ€è¦ä¿®æ”¹å…‰ç…§æ¡ä»¶æˆ–è€…ç›¸æœºå‚æ•°ï¼Œè¯·ä¿®æ”¹éœ€è¦çš„å‚æ•°å¹¶ä¸”æµ‹è¯•åå†è¿›è¡Œå¤§é‡ç”Ÿæˆã€‚




## 3ã€ä»»åŠ¡åœºæ™¯æ­å»º

### 3.1 ä»£ç ç»“æ„

```
unitree_sim_isaaclab/
â”‚
â”œâ”€â”€ action_provider                   [åŠ¨ä½œæä¾›è€…,æä¾›äº†è¯»å–æ–‡ä»¶åŠ¨ä½œã€æ¥æ”¶ddsåŠ¨ä½œã€ç­–ç•¥ç”ŸæˆåŠ¨ä½œç­‰æ¥å£ï¼Œç›®å‰ä¸»è¦ä½¿ç”¨åŸºäºDDSçš„åŠ¨ä½œè·å–]
â”‚
â”œâ”€â”€ dds                               [ddsé€šä¿¡æ¨¡å—ï¼Œå®ç°äº†g1ã€å¤¹çˆªã€ä¸‰æŒ‡çµå·§æ‰‹çš„DDSé€šä¿¡]
â”‚
â”œâ”€â”€ image_server                      [å›¾åƒå‘å¸ƒæœåŠ¡ï¼Œé‡‡ç”¨ZMQè¿›è¡Œå›¾åƒå‘å¸ƒ]
â”‚
â”œâ”€â”€ layeredcontrol                    [åº•å±‚æ§åˆ¶æ¨¡å—ï¼Œè·å–actionå¹¶ä¸”è®¾ç½®åˆ°è™šæ‹Ÿç¯å¢ƒä¸­]
â”‚
â”œâ”€â”€ robots                            [æœºå™¨äººçš„åŸºç¡€é…ç½®]
â”‚
â”œâ”€â”€ tasks                             [å­˜æ”¾ä»»åŠ¡ç›¸å…³æ–‡ä»¶]
â”‚   â”œâ”€â”€ common_config
â”‚   â”‚     â”œâ”€â”€ camera_configs.py       [ç›¸æœºæ”¾ç½®ç›¸å…³é…ç½®]
â”‚   â”‚     â”œâ”€â”€ robot_configs.py        [æœºå™¨äººè®¾ç½®ç›¸å…³é…ç½®]
â”‚   â”‚
â”‚   â”œâ”€â”€ common_event
â”‚   â”‚      â”œâ”€â”€ event_manager.py       [äº‹ä»¶æ³¨å†Œç®¡ç†]  
â”‚   â”‚
â”‚   â”œâ”€â”€ common_observations
â”‚   â”‚      â”œâ”€â”€ camera_state.py        [ç›¸æœºæ•°æ®è·å–]  
â”‚   â”‚      â”œâ”€â”€ dex3_state.py          [ä¸‰æŒ‡çµå·§æ‰‹æ•°æ®è·å–]
â”‚   â”‚      â”œâ”€â”€ g1_29dof_state.py      [æœºå™¨äººçŠ¶æ€æ•°æ®è·å–]
â”‚   â”‚      â”œâ”€â”€ gripper_state.py       [å¤¹çˆªæ•°æ®è·å–]
â”‚   â”‚
â”‚   â”œâ”€â”€ common_scene                
â”‚   â”‚      â”œâ”€â”€ base_scene_pickplace_cylindercfg.py         [æŠ“å–åœ†æŸ±ä½“ä»»åŠ¡çš„å…¬å…±åœºæ™¯]  
â”‚   â”‚      â”œâ”€â”€ base_scene_pickplace_redblock.py            [æŠ“å–çº¢è‰²æœ¨å—ä»»åŠ¡çš„å…¬å…±åœºæ™¯] 
â”‚   â”‚
â”‚   â”œâ”€â”€ common_termination                                 [ä¸åŒä»»åŠ¡çš„ç‰©ä½“æ˜¯å¦è¶…å‡ºè§„å®šå·¥ä½œèŒƒå›´çš„åˆ¤æ–­]
â”‚   â”‚      â”œâ”€â”€ base_termination_pick_place_cylinder         
â”‚   â”‚      â”œâ”€â”€ base_termination_pick_place_redblock          
â”‚   â”‚
â”‚   â”œâ”€â”€ g1_tasks                                            [å­˜æ”¾g1ç›¸å…³çš„æ‰€æœ‰ä»»åŠ¡]
â”‚   â”‚      â”œâ”€â”€ pick_place_cylinder_g1_29dof_dex1            [åœ†æŸ±ä½“æŠ“å–ä»»åŠ¡]
â”‚   â”‚      â”‚     â”œâ”€â”€ mdp                                      
â”‚   â”‚      â”‚     â”‚     â”œâ”€â”€ observations.py                  [è§‚æµ‹æ•°æ®]
â”‚   â”‚      â”‚     â”‚     â”œâ”€â”€ terminations.py                  [ç»ˆæ­¢åˆ¤æ–­æ¡ä»¶]
â”‚   â”‚      â”‚     â”œâ”€â”€ __init__.py                            [ä»»åŠ¡åç§°æ³¨å†Œ]  
â”‚   â”‚      â”‚     â”œâ”€â”€ pickplace_cylinder_g1_29dof_dex1_joint_env_cfg.py           [ä»»åŠ¡å…·ä½“çš„åœºæ™¯å¯¼å…¥ä»¥åŠç›¸å…³ç±»çš„åˆå§‹åŒ–]
â”‚   â”‚      â”œâ”€â”€ ...
â”‚   â”‚      â”œâ”€â”€ __init__.py                                  [å¯¹å¤–æ˜¾ç¤ºg1ä¸­å­˜åœ¨çš„æ‰€æœ‰ä»»åŠ¡åç§°]
â”‚   â”œâ”€â”€ utils                                               [å·¥å…·å‡½æ•°]
â”œâ”€â”€ tools                                                   [å­˜æ”¾usdè½¬æ¢å’Œä¿®æ”¹ç›¸å…³å·¥å…·]
â”œâ”€â”€ usd                                                     [å­˜æ”¾usdçš„æ¨¡å‹æ–‡ä»¶]
â”œâ”€â”€ sim_main.py                                             [ä¸»å‡½æ•°] 
â”œâ”€â”€ reset_pose_test.py                                      [ç‰©ä½“ä½ç½®é‡ç½®çš„æµ‹è¯•å‡½æ•°] 
```

### 3.2 ä»»åŠ¡åœºæ™¯æ­å»ºæ­¥éª¤
å¦‚æœä½¿ç”¨å·²æœ‰çš„æœºå™¨äººé…ç½®ï¼ˆG1-29dof-gripperã€G1-29dof-dex3ï¼‰æ­å»ºæ–°ä»»åŠ¡åœºæ™¯åªéœ€è¦æŒ‰ç…§ä¸‹é¢æ­¥éª¤è¿›è¡Œæ“ä½œå³å¯ï¼š

#### 3.2.1ã€æ­å»ºä»»åŠ¡åœºæ™¯çš„å…¬å…±éƒ¨åˆ†ï¼ˆå³é™¤æœºå™¨äººä¹‹å¤–çš„å…¶ä»–åœºæ™¯ï¼‰
æŒ‰ç…§å·²æœ‰çš„ä»»åŠ¡é…ç½®ï¼Œåœ¨common_scene ç›®å½•ä¸‹æ·»åŠ æ–°ä»»åŠ¡çš„å…¬å…±åœºæ™¯é…ç½®ï¼Œå¯å‚è€ƒå·²æœ‰çš„ä»»åŠ¡çš„å…¬å…±é…ç½®æ–‡ä»¶ã€‚
#### 3.2.2 ç»ˆæ­¢æˆ–ç‰©ä½“é‡ç½®çš„æ¡ä»¶åˆ¤æ–­
åœ¨common_terminationç›®å½•ä¸­æ ¹æ®è‡ªå·±åœºæ™¯çš„éœ€è¦æ·»åŠ ç»ˆæ­¢æˆ–è€…ç‰©ä½“é‡ç½®çš„åˆ¤æ–­æ¡ä»¶
#### 3.2.3 æ·»åŠ å¹¶æ³¨å†Œä»»åŠ¡
åœ¨ g1_tasks ç›®å½•ä¸‹æ·»åŠ æ–°ä»»åŠ¡çš„ç›®å½•å¹¶ä¸”ä»¿ç…§å·²æœ‰çš„ä»»åŠ¡è¿›è¡Œä¿®æ”¹ç›¸å…³æ–‡ä»¶ï¼Œä¸‹é¢ä»¥pick_place_cylinder_g1_29dof_dex1ä»»åŠ¡ä¸ºä¾‹ï¼Œå…·ä½“å¦‚ä¸‹ï¼š

- observations.pyï¼šæ·»åŠ å¯¹åº”çš„è§‚æµ‹å‡½æ•°ï¼Œåªéœ€è¦æŒ‰ç…§éœ€æ±‚å¯¼å…¥å¯¹åº”çš„æ–‡ä»¶å³å¯
 ```

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.gripper_state import get_robot_gipper_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_gipper_joint_states", 
    "get_camera_image"
]

 ```
- terminations.pyï¼šæ·»åŠ å¯¹åº”çš„æ¡ä»¶åˆ¤æ–­å‡½æ•°ï¼Œä»common_terminationå¯¼å…¥å¯¹åº”æ–‡ä»¶
 ```
 from tasks.common_termination.base_termination_pick_place_cylinder import reset_object_estimate
__all__ = [
"reset_object_estimate"
]
 ```

- pick_place_cylinder_g1_29dof_dex1/```__init__.py ```

åœ¨æ–°ä»»åŠ¡çš„ç›®å½•ä¸‹æ·»åŠ ```__init__.py ```å¹¶ä¸”æ·»åŠ ä»»åŠ¡åç§°ï¼Œå¦‚pick_place_cylinder_g1_29dof_dex1ä¸‹é¢çš„```__init__.py``` 

```
# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import gymnasium as gym

from . import pickplace_cylinder_g1_29dof_dex1_joint_env_cfg


gym.register(
    id="Isaac-PickPlace-Cylinder-G129-Dex1-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": pickplace_cylinder_g1_29dof_dex1_joint_env_cfg.PickPlaceG129DEX1BaseFixEnvCfg,
    },
    disable_env_checker=True,
)


```
- ç¼–å†™ä»»åŠ¡å¯¹åº”çš„ç¯å¢ƒé…ç½®æ–‡ä»¶ï¼Œå¦‚ pickplace_cylinder_g1_29dof_dex1_joint_env_cfg.py

å¯¼å…¥å…¬å…±çš„åœºæ™¯ï¼Œè®¾ç½®æœºå™¨äººçš„ä½ç½®ä»¥åŠæ·»åŠ ç›¸æœºç­‰é…ç½®

- ä¿®æ”¹g1_tasks/```__init__.py```

æŒ‰ç…§ä¸‹é¢æ–¹å¼æŠŠæ–°ä»»åŠ¡çš„é…ç½®ç±»æ·»åŠ åˆ°g1_tasksç›®å½•ä¸‹çš„```__init__.py```çš„æ–‡ä»¶ä¸­ã€‚

```
# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""Unitree G1 robot task module
contains various task implementations for the G1 robot, such as pick and place, motion control, etc.
"""

# use relative import
from . import pick_place_cylinder_g1_29dof_dex3
from . import pick_place_cylinder_g1_29dof_dex1
from . import pick_place_redblock_g1_29dof_dex1
from . import pick_place_redblock_g1_29dof_dex3
# export all modules
__all__ = ["pick_place_cylinder_g1_29dof_dex3", "pick_place_cylinder_g1_29dof_dex1", "pick_place_redblock_g1_29dof_dex1", "pick_place_redblock_g1_29dof_dex3"]

```
### ğŸ“‹ TODO List

- â¬œ æŒç»­æ·»åŠ æ–°çš„ä»»åŠ¡åœºæ™¯
- â¬œ æŒç»­è¿›è¡Œä»£ç ä¼˜åŒ–

## ğŸ™ é¸£è°¢
è¯¥ä»£ç åŸºäºä»¥ä¸‹å¼€æºä»£ç åº“æ„å»ºã€‚è¯·è®¿é—®ä»¥ä¸‹é“¾æ¥æŸ¥çœ‹å„è‡ªçš„è®¸å¯è¯ï¼š

1. https://github.com/isaac-sim/IsaacLab
2. https://github.com/isaac-sim/IsaacSim
3. https://github.com/zeromq/pyzmq
4. https://github.com/unitreerobotics/unitree_sdk2_python

===== action_provider/__init__.py =====



===== action_provider/action_base.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# Author: wei.li
# License: Apache License, Version 2.0

from abc import ABC, abstractmethod
from typing import Optional
import torch
import time
import threading

class ActionProvider(ABC):
    """Abstract base class for action providers"""
    
    def __init__(self, name: str):
        print(f"ActionProvider init")
        self.name = name
        self.is_running = False
        self._thread = None
    
    @abstractmethod
    def get_action(self, env) -> Optional[torch.Tensor]:
        """Get action
        
        Args:
            env: environment instance
            
        Returns:
            torch.Tensor: action tensor, return None if no action is available
        """
        pass
    
    def start(self):
        """Start action provider"""
        if not self.is_running:
            self.is_running = True
            self._thread = threading.Thread(target=self._run_loop, daemon=True)
            self._thread.start()
            print(f"[{self.name}] ActionProvider started")
    
    def stop(self):
        """Stop action provider"""
        print(f"[{self.name}] ActionProvider stop")
        self.is_running = False
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.0)
        print(f"[{self.name}] ActionProvider stopped")
    
    def _run_loop(self):
        """Run loop (subclass can override)"""
        while self.is_running:
            time.sleep(0.01)
    
    def cleanup(self):
        """Clean up resources (subclass can override)"""
        pass

===== action_provider/action_provider_dds.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0
from action_provider.action_base import ActionProvider
from typing import Optional
import torch
from dds.dds_master import dds_manager
class DDSActionProvider(ActionProvider):
    """Action provider based on DDS"""
    
    def __init__(self,env, args_cli):
        super().__init__("DDSActionProvider")
        self.enable_robot = args_cli.robot_type
        self.enable_gripper = args_cli.enable_dex1_dds
        self.enable_dex3 = args_cli.enable_dex3_dds
        self.enable_inspire = args_cli.enable_inspire_dds
        self.env = env
        # Initialize DDS communication
        self.robot_dds = None
        self.gripper_dds = None
        self.dex3_dds = None
        self.inspire_dds = None
        self._setup_dds()
        self._setup_joint_mapping()
    
    def _setup_dds(self):
        """Setup DDS communication"""
        print(f"enable_robot: {self.enable_robot}")
        print(f"enable_gripper: {self.enable_gripper}")
        print(f"enable_dex3: {self.enable_dex3}")
        try:
            if self.enable_robot == "g129" or self.enable_robot == "h1_2":
                self.robot_dds = dds_manager.get_object("g129")
            if self.enable_gripper:
                self.gripper_dds = dds_manager.get_object("dex1")
            elif self.enable_dex3:
                self.dex3_dds = dds_manager.get_object("dex3")
            elif self.enable_inspire:
                self.inspire_dds = dds_manager.get_object("inspire")
            print(f"[{self.name}] DDS communication initialized")
        except Exception as e:
            print(f"[{self.name}] DDS initialization failed: {e}")
    
    def _setup_joint_mapping(self):
        """Setup joint mapping"""
        if self.enable_robot == "g129":
            self.arm_joint_mapping = {
                "left_shoulder_pitch_joint": 0,
                "left_shoulder_roll_joint": 1,
                "left_shoulder_yaw_joint": 2,
                "left_elbow_joint": 3,
                "left_wrist_roll_joint": 4,
                "left_wrist_pitch_joint": 5,
                "left_wrist_yaw_joint": 6,
                "right_shoulder_pitch_joint": 7,
                "right_shoulder_roll_joint": 8,
                "right_shoulder_yaw_joint": 9,
                "right_elbow_joint": 10,
                "right_wrist_roll_joint": 11,
                "right_wrist_pitch_joint": 12,
                "right_wrist_yaw_joint": 13
            }
            self.all_joint_names = self.env.scene["robot"].data.joint_names
            self.joint_to_index = {name: i for i, name in enumerate(self.all_joint_names)}
            self.arm_action_pose = [self.joint_to_index[name] for name in self.arm_joint_mapping.keys()]
            self.arm_action_pose_indices = [self.arm_joint_mapping[name] for name in self.arm_joint_mapping.keys()]
            self._arm_target_indices = [self.joint_to_index[name] for name in self.arm_joint_mapping.keys()]
            self._arm_source_indices = [idx + 15 for idx in self.arm_joint_mapping.values()]  # source data from positions[15:]
        elif self.enable_robot == "h1_2":
            self.arm_joint_mapping = {
                "left_shoulder_pitch_joint": 0,
                "left_shoulder_roll_joint": 1,
                "left_shoulder_yaw_joint": 2,
                "left_elbow_joint": 3,
                "left_wrist_roll_joint": 4,
                "left_wrist_pitch_joint": 5,
                "left_wrist_yaw_joint": 6,
                "right_shoulder_pitch_joint": 7,
                "right_shoulder_roll_joint": 8,
                "right_shoulder_yaw_joint": 9,
                "right_elbow_joint": 10,
                "right_wrist_roll_joint": 11,
                "right_wrist_pitch_joint": 12,
                "right_wrist_yaw_joint": 13
            }
            print(f"self.env.scene['robot'].data.joint_names: {self.env.scene['robot'].data.joint_names}")
            self.all_joint_names = self.env.scene["robot"].data.joint_names
            self.joint_to_index = {name: i for i, name in enumerate(self.all_joint_names)}
            self.arm_action_pose = [self.joint_to_index[name] for name in self.arm_joint_mapping.keys()]
            self.arm_action_pose_indices = [self.arm_joint_mapping[name] for name in self.arm_joint_mapping.keys()]
            self._arm_target_indices = [self.joint_to_index[name] for name in self.arm_joint_mapping.keys()]
            self._arm_source_indices = [idx + 13 for idx in self.arm_joint_mapping.values()]  # source data from positions[13:]
        if self.enable_gripper:
            self.gripper_joint_mapping = {
                "left_hand_Joint1_1": 1,
                "left_hand_Joint2_1": 1,
                "right_hand_Joint1_1": 0,
                "right_hand_Joint2_1": 0,
            }
        if self.enable_dex3:
            self.left_hand_joint_mapping = {
                "left_hand_thumb_0_joint":0,
                "left_hand_thumb_1_joint":1,
                "left_hand_thumb_2_joint":2,
                "left_hand_middle_0_joint":3,
                "left_hand_middle_1_joint":4,
                "left_hand_index_0_joint":5,
                "left_hand_index_1_joint":6}
            self.right_hand_joint_mapping = {
                "right_hand_thumb_0_joint":0,     
                "right_hand_thumb_1_joint":1,
                "right_hand_thumb_2_joint":2,
                "right_hand_middle_0_joint":3,
                "right_hand_middle_1_joint":4,
                "right_hand_index_0_joint":5,
                "right_hand_index_1_joint":6}
        if self.enable_inspire:
            self.inspire_hand_joint_mapping = {
                "R_pinky_proximal_joint":0,
                "R_ring_proximal_joint":1,
                "R_middle_proximal_joint":2,
                "R_index_proximal_joint":3,
                "R_thumb_proximal_pitch_joint":4,
                "R_thumb_proximal_yaw_joint":5,
                "L_pinky_proximal_joint":6,
                "L_ring_proximal_joint":7,
                "L_middle_proximal_joint":8,
                "L_index_proximal_joint":9,
                "L_thumb_proximal_pitch_joint":10,
                "L_thumb_proximal_yaw_joint":11,
            }
            self.special_joint_mapping = {
                "L_index_intermediate_joint":[9,1],
                "L_middle_intermediate_joint":[8,1],
                "L_pinky_intermediate_joint":[6,1],
                "L_ring_intermediate_joint":[7,1],
                "L_thumb_intermediate_joint":[10,1.5],
                "L_thumb_distal_joint":[10,2.4],

                "R_index_intermediate_joint":[3,1],
                "R_middle_intermediate_joint":[2,1],
                "R_pinky_intermediate_joint":[0,1],
                "R_ring_intermediate_joint":[1,1],
                "R_thumb_intermediate_joint":[4,1.5],
                "R_thumb_distal_joint":[4,2.4],
            }

        
        # precompute indices (for vectorization)

        if self.enable_gripper:
            self._gripper_target_indices = [self.joint_to_index[name] for name in self.gripper_joint_mapping.keys()]
            self._gripper_source_indices = [idx for idx in self.gripper_joint_mapping.values()]
        if self.enable_dex3:
            self._left_hand_target_indices = [self.joint_to_index[name] for name in self.left_hand_joint_mapping.keys()]
            self._left_hand_source_indices = [idx for idx in self.left_hand_joint_mapping.values()]
            self._right_hand_target_indices = [self.joint_to_index[name] for name in self.right_hand_joint_mapping.keys()]
            self._right_hand_source_indices = [idx for idx in self.right_hand_joint_mapping.values()]
        if self.enable_inspire:
            self._inspire_target_indices = [self.joint_to_index[name] for name in self.inspire_hand_joint_mapping.keys()]
            self._inspire_source_indices = [idx for idx in self.inspire_hand_joint_mapping.values()]
            self._inspire_special_target_indices = [self.joint_to_index[name] for name in self.special_joint_mapping.keys()]
            self._inspire_special_source_indices = [spec[0] for spec in self.special_joint_mapping.values()]
            self._inspire_special_scales = torch.tensor([spec[1] for spec in self.special_joint_mapping.values()], dtype=torch.float32)
        
        device = self.env.device
        self._arm_target_idx_t = torch.tensor(self._arm_target_indices, dtype=torch.long, device=device)
        self._arm_source_idx_t = torch.tensor(self._arm_source_indices, dtype=torch.long, device=device)
        if self.enable_gripper:
            self._gripper_target_idx_t = torch.tensor(self._gripper_target_indices, dtype=torch.long, device=device)
            self._gripper_source_idx_t = torch.tensor(self._gripper_source_indices, dtype=torch.long, device=device)
        if self.enable_dex3:
            self._left_hand_target_idx_t = torch.tensor(self._left_hand_target_indices, dtype=torch.long, device=device)
            self._left_hand_source_idx_t = torch.tensor(self._left_hand_source_indices, dtype=torch.long, device=device)
            self._right_hand_target_idx_t = torch.tensor(self._right_hand_target_indices, dtype=torch.long, device=device)
            self._right_hand_source_idx_t = torch.tensor(self._right_hand_source_indices, dtype=torch.long, device=device)
        if self.enable_inspire:
            self._inspire_target_idx_t = torch.tensor(self._inspire_target_indices, dtype=torch.long, device=device)
            self._inspire_source_idx_t = torch.tensor(self._inspire_source_indices, dtype=torch.long, device=device)
            self._inspire_special_target_idx_t = torch.tensor(self._inspire_special_target_indices, dtype=torch.long, device=device)
            self._inspire_special_source_idx_t = torch.tensor(self._inspire_special_source_indices, dtype=torch.long, device=device)
            self._inspire_special_scales_t = self._inspire_special_scales.to(device)
        
        self._full_action_buf = torch.zeros(len(self.all_joint_names), device=device, dtype=torch.float32)
        print("DEBUG SECTION")
        print(f"Joint names: {self.all_joint_names}")
        print(f"joint to index: {self.joint_to_index}")
        self._positions_buf = torch.empty(29, device=device, dtype=torch.float32)
        if self.enable_gripper:
            self._gripper_buf = torch.empty(2, device=device, dtype=torch.float32)
        if self.enable_dex3:
            self._left_hand_buf = torch.empty(len(self._left_hand_source_indices), device=device, dtype=torch.float32)
            self._right_hand_buf = torch.empty(len(self._right_hand_source_indices), device=device, dtype=torch.float32)
        if self.enable_inspire:
            self._inspire_buf = torch.empty(12, device=device, dtype=torch.float32)
    
    def get_action(self, env) -> Optional[torch.Tensor]:
        """Get action from DDS"""
        try:

            full_action = self._full_action_buf
            full_action.zero_()
            if self.enable_robot == "g129" and self.robot_dds:
                cmd_data = self.robot_dds.get_robot_command()
                if cmd_data and 'motor_cmd' in cmd_data:
                    positions = cmd_data['motor_cmd']['positions']
                    if len(positions) >= 29:
                        self._positions_buf[:29].copy_(torch.tensor(positions[:29], dtype=torch.float32, device=self.env.device))
                        arm_vals = self._positions_buf.index_select(0, self._arm_source_idx_t)
                        full_action.index_copy_(0, self._arm_target_idx_t, arm_vals)
            elif self.enable_robot == "h1_2" and self.robot_dds:
                cmd_data = self.robot_dds.get_robot_command()
                if cmd_data and 'motor_cmd' in cmd_data:
                    positions = cmd_data['motor_cmd']['positions']
                    if len(positions) >= 29:
                        self._positions_buf[:29].copy_(torch.tensor(positions[:29], dtype=torch.float32, device=self.env.device))
                        arm_vals = self._positions_buf.index_select(0, self._arm_source_idx_t)
                        full_action.index_copy_(0, self._arm_target_idx_t, arm_vals)
            # Get gripper command
            if self.gripper_dds:
                gripper_cmd = self.gripper_dds.get_gripper_command()
                if gripper_cmd:
                    left_gripper_cmd = gripper_cmd.get('left_gripper_cmd', {})
                    right_gripper_cmd = gripper_cmd.get('right_gripper_cmd', {})
                    left_gripper_positions = left_gripper_cmd.get('positions', [])
                    right_gripper_positions = right_gripper_cmd.get('positions', [])
                    gripper_positions = right_gripper_positions + left_gripper_positions
                    if len(gripper_positions) >= 2:
                        self._gripper_buf.copy_(torch.tensor(gripper_positions[:2], dtype=torch.float32, device=self.env.device))
                        gp_vals = self._gripper_buf.index_select(0, self._gripper_source_idx_t)
                        full_action.index_copy_(0, self._gripper_target_idx_t, gp_vals)
             
            elif self.dex3_dds:
                hand_cmds = self.dex3_dds.get_hand_commands()
                if hand_cmds:
                    left_hand_cmd = hand_cmds.get('left_hand_cmd', {})
                    right_hand_cmd = hand_cmds.get('right_hand_cmd', {})
                    if left_hand_cmd and right_hand_cmd:
                        left_positions = left_hand_cmd.get('positions', [])
                        right_positions = right_hand_cmd.get('positions', [])
                        if len(left_positions) >= len(self._left_hand_buf) and len(right_positions) >= len(self._right_hand_buf):
                            self._left_hand_buf.copy_(torch.tensor(left_positions[:len(self._left_hand_buf)], dtype=torch.float32, device=self.env.device))
                            self._right_hand_buf.copy_(torch.tensor(right_positions[:len(self._right_hand_buf)], dtype=torch.float32, device=self.env.device))
                            l_vals = self._left_hand_buf.index_select(0, self._left_hand_source_idx_t)
                            r_vals = self._right_hand_buf.index_select(0, self._right_hand_source_idx_t)
                            full_action.index_copy_(0, self._left_hand_target_idx_t, l_vals)
                            full_action.index_copy_(0, self._right_hand_target_idx_t, r_vals)
            elif self.inspire_dds:
                inspire_cmds = self.inspire_dds.get_inspire_hand_command()
                if inspire_cmds and 'positions' in inspire_cmds:
                        inspire_cmds_positions = inspire_cmds['positions']
                        if len(inspire_cmds_positions) >= 12:
                            self._inspire_buf.copy_(torch.tensor(inspire_cmds_positions[:12], dtype=torch.float32, device=self.env.device))
                            base_vals = self._inspire_buf.index_select(0, self._inspire_source_idx_t)
                            full_action.index_copy_(0, self._inspire_target_idx_t, base_vals)
                            special_vals = self._inspire_buf.index_select(0, self._inspire_special_source_idx_t) * self._inspire_special_scales_t
                            full_action.index_copy_(0, self._inspire_special_target_idx_t, special_vals)
            return full_action.unsqueeze(0)
            
        except Exception as e:
            print(f"[{self.name}] Get DDS action failed: {e}")
            return None
    
    def _convert_to_joint_range(self, value):
        """Convert gripper control value to joint angle"""
        input_min, input_max = 0.0, 5.6
        output_min, output_max = 0.03, -0.02
        value = max(input_min, min(input_max, value))
        return output_min + (output_max - output_min) * (value - input_min) / (input_max - input_min)
    
    def cleanup(self):
        """Clean up DDS resources"""
        try:
            if self.robot_dds:
                self.robot_dds.stop_communication()
            if self.gripper_dds:
                self.gripper_dds.stop_communication()
            if self.dex3_dds:
                self.dex3_dds.stop_communication()
            if self.inspire_dds:
                self.inspire_dds.stop_communication()
        except Exception as e:
            print(f"[{self.name}] Clean up DDS resources failed: {e}")

===== action_provider/action_provider_replay.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0
from action_provider.action_base import ActionProvider
from typing import Optional
import torch
from tools.data_json_load import load_robot_data
from image_server.shared_memory_utils import MultiImageReader
from tools.episode_writer import EpisodeWriter
import json
from typing import List, Optional
import numpy as np
import time
from tools.data_convert import convert_to_gripper_range
class FileActionProviderReplay(ActionProvider):
    """Action provider based on DDS"""
    
    def __init__(self,env, args_cli):
        super().__init__("FileActionProviderReplay")
        self.env = env
        self.enable_robot = args_cli.robot_type
        self.enable_gripper = args_cli.enable_dex1_dds
        self.enable_dex3 = args_cli.enable_dex3_dds
        self.enable_inspire = args_cli.enable_inspire_dds
        self.generate_data = args_cli.generate_data
        self.generate_data_dir = args_cli.generate_data_dir
        self.action_index = 10**1000
        self.total_step_num =0
        self.start_loop = True
        self.saved_data = True
        self.all_joint_names = env.scene["robot"].data.joint_names
        self.joint_to_index = {name: i for i, name in enumerate(self.all_joint_names)}
        self._setup_joint_mapping()
        self.multi_image_reader=None
        self.recorder=None
        if self.generate_data:
            try:
                self.multi_image_reader = MultiImageReader()
                print(f"[{self.name}] MultiImageReader created")
            except Exception as e:
                print(f"[{self.name}] MultiImageReader creation failed: {e}")
                print(f"[{self.name}] Image data saving will be disabled")
                self.multi_image_reader = None
            
            self.recorder = EpisodeWriter(task_dir = self.generate_data_dir, frequency = 30, rerun_log = True)
        print(f"FileActionProviderReplay init ok")
        

        device = self.env.device
        if hasattr(self, "left_arm_joint_indices"):
            self._left_arm_idx_t = torch.tensor(self.left_arm_joint_indices, dtype=torch.long, device=device)
        if hasattr(self, "right_arm_joint_indices"):
            self._right_arm_idx_t = torch.tensor(self.right_arm_joint_indices, dtype=torch.long, device=device)

    def load_data(self, file_path):
        """Setup DDS communication"""
        self.robot_action, self.hand_action, self.sim_state_list,self.task_name_list,self.sim_state_json_list = load_robot_data(file_path)
        
        self.total_step_num = len(self.robot_action)
        self.total_hand_step_num = len(self.hand_action)
        if self.total_hand_step_num != self.total_hand_step_num:
            raise ValueError("total_hand_step_num is NaN. Please check your data or initialization.")
        if self.generate_data:
            # tem_sim_state  = self.sim_state_to_json(self.sim_state_json_list[0])
            self.recorder.create_episode()
            self.saved_data = False
        
        self.start_loop = False
        
        return self.sim_state_list[0],self.task_name_list[0]
    def start_replay(self):
        self.action_index=0
    def get_start_loop(self):
        return self.start_loop
    def _setup_joint_mapping(self):
        """Setup joint mapping"""
        if self.enable_robot == "g129" or self.enable_robot == "h1_2":
            self.arm_joint_mapping = {
                "left_shoulder_pitch_joint": 0,
                "left_shoulder_roll_joint": 1,
                "left_shoulder_yaw_joint": 2,
                "left_elbow_joint": 3,
                "left_wrist_roll_joint": 4,
                "left_wrist_pitch_joint": 5,
                "left_wrist_yaw_joint": 6,
                "right_shoulder_pitch_joint": 7,
                "right_shoulder_roll_joint": 8,
                "right_shoulder_yaw_joint": 9,
                "right_elbow_joint": 10,
                "right_wrist_roll_joint": 11,
                "right_wrist_pitch_joint": 12,
                "right_wrist_yaw_joint": 13
            }
            self.left_arm_joint = [        
                "left_shoulder_pitch_joint",
                "left_shoulder_roll_joint",
                "left_shoulder_yaw_joint",
                "left_elbow_joint",
                "left_wrist_roll_joint",
                "left_wrist_pitch_joint",
                "left_wrist_yaw_joint"]
            self.right_arm_joint = [        
                "right_shoulder_pitch_joint",
                "right_shoulder_roll_joint",
                "right_shoulder_yaw_joint",
                "right_elbow_joint",
                "right_wrist_roll_joint",
                "right_wrist_pitch_joint",
                "right_wrist_yaw_joint"]
            self.left_arm_joint_indices = [self.joint_to_index[name] for name in self.left_arm_joint]
            self.right_arm_joint_indices = [self.joint_to_index[name] for name in self.right_arm_joint]
            
        if self.enable_gripper:
            self.gripper_joint_mapping = {
                "left_hand_Joint1_1": 1,
                "left_hand_Joint2_1": 1,
                "right_hand_Joint1_1": 0,
                "right_hand_Joint2_1": 0,
            }
            self.left_hand_joint = ["left_hand_Joint1_1"]
            self.right_hand_joint = ["right_hand_Joint1_1"]
        if self.enable_dex3:
            self.left_hand_joint_mapping = {
                "left_hand_thumb_0_joint":0,
                "left_hand_thumb_1_joint":1,
                "left_hand_thumb_2_joint":2,
                "left_hand_middle_0_joint":3,
                "left_hand_middle_1_joint":4,
                "left_hand_index_0_joint":5,
                "left_hand_index_1_joint":6}
            self.right_hand_joint_mapping = {
                "right_hand_thumb_0_joint":0,     
                "right_hand_thumb_1_joint":1,
                "right_hand_thumb_2_joint":2,
                "right_hand_middle_0_joint":3,
                "right_hand_middle_1_joint":4,
                "right_hand_index_0_joint":5,
                "right_hand_index_1_joint":6}
            self.left_hand_joint = [
                # hand joints (14)
                # left hand (7)
                "left_hand_thumb_0_joint",
                "left_hand_thumb_1_joint",
                "left_hand_thumb_2_joint",
                "left_hand_middle_0_joint",
                "left_hand_middle_1_joint",
                "left_hand_index_0_joint",
                "left_hand_index_1_joint"]
            self.right_hand_joint = [
                    "right_hand_thumb_0_joint",
                    "right_hand_thumb_1_joint",
                    "right_hand_thumb_2_joint",
                    "right_hand_middle_0_joint",
                    "right_hand_middle_1_joint",
                    "right_hand_index_0_joint",
                    "right_hand_index_1_joint",
                ]
        if self.enable_inspire:
            self.left_hand_joint = [
                "L_pinky_proximal_joint",
                "L_ring_proximal_joint",
                "L_middle_proximal_joint",
                "L_index_proximal_joint",
                "L_thumb_proximal_pitch_joint",
                "L_thumb_proximal_yaw_joint",
            ]
            self.right_hand_joint = [
                "R_pinky_proximal_joint",
                "R_ring_proximal_joint",
                "R_middle_proximal_joint",
                "R_index_proximal_joint",
                "R_thumb_proximal_pitch_joint",
                "R_thumb_proximal_yaw_joint",
            ]
        self.left_hand_joint_indices = [self.joint_to_index[name] for name in self.left_hand_joint]
        self.right_hand_joint_indices = [self.joint_to_index[name] for name in self.right_hand_joint]
        self.all_joint_indices = self.left_arm_joint_indices + self.right_arm_joint_indices #+ self.left_hand_joint_indices + self.right_hand_joint_indices


    def get_action(self, env) -> Optional[torch.Tensor]:
        """Get action from DDS"""
        try:
            # Get robot command
            if self.action_index < self.total_step_num:
                if self.enable_robot == "g129" or self.enable_robot == "h1_2":
                    arm_cmd_data = self.robot_action[self.action_index]
     
                # Get gripper command
                if self.enable_gripper:
                    hand_cmd_data = self.hand_action[self.action_index]

                # Get hand command
                elif self.enable_dex3:
                    hand_cmd_data = self.hand_action[self.action_index]
                elif self.enable_inspire:
                    hand_cmd_data = self.hand_action[self.action_index]
                
                env.scene.reset_to(self.sim_state_list[self.action_index], torch.tensor([0], device=env.device), is_relative=True)
                
                if self.generate_data:
                    for sensor in env.scene.sensors.values():
                        sensor.update(0.02, force_recompute=False)
                    env.sim.render()
                    env.observation_manager.compute()
                    while not self.save_date(env,arm_cmd_data,hand_cmd_data,self.sim_state_json_list[self.action_index]):
                        time.sleep(0.01)
                        env.sim.render()
                        env.observation_manager.compute()
                else:
                    env.sim.render()
                self.action_index += 1
            else:
                self.action_index = 10**1000
                if self.generate_data: 
                    if not self.saved_data:
                        self.recorder.save_episode()
                        self.saved_data = True
                    if self.recorder.is_available:
                        self.start_loop=True
                else:
                    self.start_loop=True
                
            # print(f"full_action: {full_action}")
            return None
            
        except Exception as e:
            print(f"[{self.name}] Get DDS action failed: {e}")
            return None
    

    def cleanup(self):
        """Clean up DDS resources"""
        if self.multi_image_reader:
            self.multi_image_reader.close()
        if self.recorder:
            self.recorder.close()
        self.is_running = False
        print(f"[{self.name}] Resource cleanup completed")
    def get_state(self,env):

        joint_pos = env.scene["robot"].data.joint_pos
        left_arm_joint_pose = joint_pos[:,self.left_arm_joint_indices][0].detach().cpu().numpy().tolist()
        right_arm_joint_pose = joint_pos[:,self.right_arm_joint_indices][0].detach().cpu().numpy().tolist()
        if self.enable_gripper:
            left_hand_joint_pose = np.array(convert_to_gripper_range(joint_pos[:,self.left_hand_joint_indices][0].detach().cpu().numpy())).tolist()
            right_hand_joint_pose = np.array(convert_to_gripper_range(joint_pos[:,self.right_hand_joint_indices][0].detach().cpu().numpy())).tolist()
        else:
            left_hand_joint_pose = joint_pos[:,self.left_hand_joint_indices][0].detach().cpu().numpy().tolist()
            right_hand_joint_pose = joint_pos[:,self.right_hand_joint_indices][0].detach().cpu().numpy().tolist()


        return left_arm_joint_pose,right_arm_joint_pose,left_hand_joint_pose,right_hand_joint_pose

    def get_images(self,image_count=3):
        concatenated_image = self.multi_image_reader.read_concatenated_image()
        if concatenated_image is None:
            return None
        height, total_width, channels = concatenated_image.shape
        single_width = total_width // image_count
        if total_width % image_count != 0:
            raise ValueError("Total width is not divisible by image_count. Cannot split cleanly.")

        images = {}
        names = ['head', 'left', 'right']
        for i, name in enumerate(names[:image_count]):
            x_start = i * single_width
            x_end = x_start + single_width
            images[name] = concatenated_image[:, x_start:x_end, :]
        return images
    def save_date(self,env,arm_action,hand_action,sim_state=None):
        def ensure_list(data):
            """Ensure data is list type, if not, convert to list"""
            if isinstance(data, list):
                return data
            elif hasattr(data, 'tolist'):  # numpy array or torch tensor
                return data.tolist()
            elif hasattr(data, '__iter__') and not isinstance(data, (str, bytes)):  # other iterable types
                return list(data)
            else:  # single value
                return [data]
        
        left_arm_state,right_arm_state,left_ee_state,right_ee_state = self.get_state(env)
        images = self.get_images()
        if images is None:
            return False
        colors = {}
        depths = {}
        left_arm_action = arm_action[:7].tolist()
        right_arm_action = arm_action[7:].tolist()
        if self.enable_gripper:
            right_hand_action = np.array(hand_action[:1]).tolist() 
            left_hand_action = np.array(hand_action[1:]).tolist()
        elif self.enable_dex3:
            right_hand_action = hand_action[:7].tolist()
            left_hand_action = hand_action[7:].tolist()
        elif self.enable_inspire:
            right_hand_action = hand_action[:6].tolist()
            left_hand_action = hand_action[6:].tolist()
        colors[f"color_{0}"] = images["head"]
        colors[f"color_{1}"] = images["left"]
        colors[f"color_{2}"] = images["right"]
        states = {
            "left_arm": {                                                                    
                "qpos":   ensure_list(left_arm_state),    
                "qvel":   [],                          
                "torque": [],                        
            }, 
            "right_arm": {                                                                    
                "qpos":   ensure_list(right_arm_state),       
                "qvel":   [],                          
                "torque": [],                         
            },                        
            "left_ee": {                                                                    
                "qpos":   ensure_list(left_ee_state),           
                "qvel":   [],                           
                "torque": [],                          
            }, 
            "right_ee": {                                                                    
                "qpos":   ensure_list(right_ee_state),       
                "qvel":   [],                           
                "torque": [],  
            }, 
            "body": {
                "qpos": [],
            }, 
        }
        actions = {
            "left_arm": {                                   
                "qpos":   ensure_list(left_arm_action),       
                "qvel":   [],       
                "torque": [],      
            }, 
            "right_arm": {                                   
                "qpos":   ensure_list(right_arm_action),       
                "qvel":   [],       
                "torque": [],       
            },                         
            "left_ee": {                                   
                "qpos":   ensure_list(left_hand_action),       
                "qvel":   [],       
                "torque": [],       
            }, 
            "right_ee": {                                   
                "qpos":   ensure_list(right_hand_action),       
                "qvel":   [],       
                "torque": [], 
            }, 
            "body": {
                "qpos": [],
            }, 
        }
        self.recorder.add_item(colors=colors, depths=depths, states=states, actions=actions,sim_state=sim_state)
        return True
    def sim_state_to_json(self,data):
        data_serializable = self.tensors_to_list(data)
        json_str = json.dumps(data_serializable)
        return json_str
    def tensors_to_list(self, obj):
        if isinstance(obj, torch.Tensor):
            return obj.tolist()
        elif isinstance(obj, dict):
            return {k: self.tensors_to_list(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [self.tensors_to_list(i) for i in obj]
        return obj

===== action_provider/action_provider_wh_dds.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0
from action_provider.action_base import ActionProvider
from typing import Optional
import torch
from dds.dds_master import dds_manager
import os
import onnxruntime as ort
from dds.sharedmemorymanager import SharedMemoryManager
import time
import threading
from isaaclab.utils.buffers import CircularBuffer,DelayBuffer
import os
import ast
project_root = os.environ.get("PROJECT_ROOT")
class DDSRLActionProvider(ActionProvider):
    """Action provider based on DDS"""
    
    def __init__(self,env, args_cli):
        super().__init__("DDSActionProvider")
        self.enable_robot = args_cli.robot_type
        self.enable_gripper = args_cli.enable_dex1_dds
        self.enable_dex3 = args_cli.enable_dex3_dds
        self.enable_inspire = args_cli.enable_inspire_dds
        self.wh = args_cli.enable_wholebody_dds
        self.policy_path = f"{project_root}/"+args_cli.model_path
        self.env = env
        # Initialize DDS communication
        self.robot_dds = None
        self.gripper_dds = None
        self.dex3_dds = None
        self.inspire_dds = None
        self.run_command = None
        self._setup_dds()
        self._setup_joint_mapping()
        self.policy = self.load_policy(self.policy_path)
        
        # é¢„è®¡ç®—ç´¢å¼•å¼ é‡ä¸å¤ç”¨ç¼“å†²
        device = self.env.device
        if hasattr(self, "arm_joint_mapping") and self.arm_joint_mapping:
            self._arm_target_indices = [self.joint_to_index[name] for name in self.arm_joint_mapping.keys()]
            self._arm_source_indices = [idx + 15 for idx in self.arm_joint_mapping.values()]
            self._arm_target_idx_t = torch.tensor(self._arm_target_indices, dtype=torch.long, device=device)
            self._arm_source_idx_t = torch.tensor(self._arm_source_indices, dtype=torch.long, device=device)
        if self.enable_gripper:
            self._gripper_target_indices = [self.joint_to_index[name] for name in self.gripper_joint_mapping.keys()]
            self._gripper_source_indices = [idx for idx in self.gripper_joint_mapping.values()]
            self._gripper_target_idx_t = torch.tensor(self._gripper_target_indices, dtype=torch.long, device=device)
            self._gripper_source_idx_t = torch.tensor(self._gripper_source_indices, dtype=torch.long, device=device)
        if self.enable_dex3:
            self._left_hand_target_indices = [self.joint_to_index[name] for name in self.left_hand_joint_mapping.keys()]
            self._left_hand_source_indices = [idx for idx in self.left_hand_joint_mapping.values()]
            self._right_hand_target_indices = [self.joint_to_index[name] for name in self.right_hand_joint_mapping.keys()]
            self._right_hand_source_indices = [idx for idx in self.right_hand_joint_mapping.values()]
            self._left_hand_target_idx_t = torch.tensor(self._left_hand_target_indices, dtype=torch.long, device=device)
            self._left_hand_source_idx_t = torch.tensor(self._left_hand_source_indices, dtype=torch.long, device=device)
            self._right_hand_target_idx_t = torch.tensor(self._right_hand_target_indices, dtype=torch.long, device=device)
            self._right_hand_source_idx_t = torch.tensor(self._right_hand_source_indices, dtype=torch.long, device=device)
        if self.enable_inspire:
            self._inspire_target_indices = [self.joint_to_index[name] for name in self.inspire_hand_joint_mapping.keys()]
            self._inspire_source_indices = [idx for idx in self.inspire_hand_joint_mapping.values()]
            self._inspire_special_target_indices = [self.joint_to_index[name] for name in self.special_joint_mapping.keys()]
            self._inspire_special_source_indices = [spec[0] for spec in self.special_joint_mapping.values()]
            self._inspire_special_scales = torch.tensor([spec[1] for spec in self.special_joint_mapping.values()], dtype=torch.float32)
            self._inspire_target_idx_t = torch.tensor(self._inspire_target_indices, dtype=torch.long, device=device)
            self._inspire_source_idx_t = torch.tensor(self._inspire_source_indices, dtype=torch.long, device=device)
            self._inspire_special_target_idx_t = torch.tensor(self._inspire_special_target_indices, dtype=torch.long, device=device)
            self._inspire_special_source_idx_t = torch.tensor(self._inspire_special_source_indices, dtype=torch.long, device=device)
            self._inspire_special_scales_t = self._inspire_special_scales.to(device)
        
        self._full_action_buf = torch.zeros(len(self.all_joint_names), device=device, dtype=torch.float32)
        self._positions_buf = torch.empty(29, device=device, dtype=torch.float32)
        if self.enable_gripper:
            self._gripper_buf = torch.empty(2, device=device, dtype=torch.float32)
        if self.enable_dex3:
            self._left_hand_buf = torch.empty(len(self._left_hand_source_indices), device=device, dtype=torch.float32)
            self._right_hand_buf = torch.empty(len(self._right_hand_source_indices), device=device, dtype=torch.float32)
        if self.enable_inspire:
            self._inspire_buf = torch.empty(12, device=device, dtype=torch.float32)
        
    def _setup_dds(self):
        """Setup DDS communication"""
        print(f"enable_robot: {self.enable_robot}")
        print(f"enable_gripper: {self.enable_gripper}")
        print(f"enable_dex3: {self.enable_dex3}")
        try:
            if self.enable_robot == "g129":
                self.robot_dds = dds_manager.get_object("g129")
            if self.enable_gripper:
                self.gripper_dds = dds_manager.get_object("dex1")
            elif self.enable_dex3:
                self.dex3_dds = dds_manager.get_object("dex3")
            elif self.enable_inspire:
                self.inspire_dds = dds_manager.get_object("inspire")
            if self.wh:
                self.run_command_dds = dds_manager.get_object("run_command")
            print(f"[{self.name}] DDS communication initialized")
        except Exception as e:
            print(f"[{self.name}] DDS initialization failed: {e}")
    
    def _setup_joint_mapping(self):
        """Setup joint mapping"""
        if self.wh:
            self.action_joint_names = [
            'left_hip_pitch_joint', 
            'right_hip_pitch_joint', 
            'left_hip_roll_joint', 
            'right_hip_roll_joint', 
            'left_hip_yaw_joint', 
            'right_hip_yaw_joint', 
            'left_knee_joint', 
            'right_knee_joint', 
            'left_ankle_pitch_joint',
            'right_ankle_pitch_joint',
            'left_ankle_roll_joint',
            'right_ankle_roll_joint'
            ]
            self.waist_joint_mapping = [
                'waist_yaw_joint',
                'waist_roll_joint',
                'waist_pitch_joint',
            ]
            self.arm_joint_names = [
            "left_shoulder_pitch_joint",
            "left_shoulder_roll_joint",
            "left_shoulder_yaw_joint",
            "left_elbow_joint",
            "left_wrist_roll_joint",
            "left_wrist_pitch_joint",
            "left_wrist_yaw_joint",
            # right arm (7)
            "right_shoulder_pitch_joint",
            "right_shoulder_roll_joint",
            "right_shoulder_yaw_joint",
            "right_elbow_joint",
            "right_wrist_roll_joint",
            "right_wrist_pitch_joint",
            "right_wrist_yaw_joint",
            ]
            self.old_action_joints_names = [
            'left_hip_pitch_joint', 
            'right_hip_pitch_joint', 
            'waist_yaw_joint', 
            'left_hip_roll_joint', 
            'right_hip_roll_joint', 
            'waist_roll_joint',
            'left_hip_yaw_joint', 
            'right_hip_yaw_joint', 
            'waist_pitch_joint', 
            'left_knee_joint', 
            'right_knee_joint', 
            'left_shoulder_pitch_joint',
            'right_shoulder_pitch_joint', 
            'left_ankle_pitch_joint', 
            'right_ankle_pitch_joint',
            'left_shoulder_roll_joint', 
            'right_shoulder_roll_joint', 
            'left_ankle_roll_joint', 
            'right_ankle_roll_joint', 
            'left_shoulder_yaw_joint', 
            'right_shoulder_yaw_joint', 
            'left_elbow_joint', 
            'right_elbow_joint', 
            'left_wrist_roll_joint', 
            'right_wrist_roll_joint', 
            'left_wrist_pitch_joint', 
            'right_wrist_pitch_joint', 
            'left_wrist_yaw_joint', 
            'right_wrist_yaw_joint',]
        if self.enable_robot == "g129":
            self.arm_joint_mapping = {
                "left_shoulder_pitch_joint": 0,
                "left_shoulder_roll_joint": 1,
                "left_shoulder_yaw_joint": 2,
                "left_elbow_joint": 3,
                "left_wrist_roll_joint": 4,
                "left_wrist_pitch_joint": 5,
                "left_wrist_yaw_joint": 6,
                "right_shoulder_pitch_joint": 7,
                "right_shoulder_roll_joint": 8,
                "right_shoulder_yaw_joint": 9,
                "right_elbow_joint": 10,
                "right_wrist_roll_joint": 11,
                "right_wrist_pitch_joint": 12,
                "right_wrist_yaw_joint": 13
            }
        if self.enable_gripper:
            self.gripper_joint_mapping = {
                "left_hand_Joint1_1": 1,
                "left_hand_Joint2_1": 1,
                "right_hand_Joint1_1": 0,
                "right_hand_Joint2_1": 0,
            }
        if self.enable_dex3:
            self.left_hand_joint_mapping = {
                "left_hand_thumb_0_joint":0,
                "left_hand_thumb_1_joint":1,
                "left_hand_thumb_2_joint":2,
                "left_hand_middle_0_joint":3,
                "left_hand_middle_1_joint":4,
                "left_hand_index_0_joint":5,
                "left_hand_index_1_joint":6}
            self.right_hand_joint_mapping = {
                "right_hand_thumb_0_joint":0,     
                "right_hand_thumb_1_joint":1,
                "right_hand_thumb_2_joint":2,
                "right_hand_middle_0_joint":3,
                "right_hand_middle_1_joint":4,
                "right_hand_index_0_joint":5,
                "right_hand_index_1_joint":6}
        if self.enable_inspire:
            self.inspire_hand_joint_mapping = {
                "R_pinky_proximal_joint":0,
                "R_ring_proximal_joint":1,
                "R_middle_proximal_joint":2,
                "R_index_proximal_joint":3,
                "R_thumb_proximal_pitch_joint":4,
                "R_thumb_proximal_yaw_joint":5,
                "L_pinky_proximal_joint":6,
                "L_ring_proximal_joint":7,
                "L_middle_proximal_joint":8,
                "L_index_proximal_joint":9,
                "L_thumb_proximal_pitch_joint":10,
                "L_thumb_proximal_yaw_joint":11,
            }
            self.special_joint_mapping = {
                "L_index_intermediate_joint":[9,1],
                "L_middle_intermediate_joint":[8,1],
                "L_pinky_intermediate_joint":[6,1],
                "L_ring_intermediate_joint":[7,1],
                "L_thumb_intermediate_joint":[10,1.5],
                "L_thumb_distal_joint":[10,2.4],

                "R_index_intermediate_joint":[3,1],
                "R_middle_intermediate_joint":[2,1],
                "R_pinky_intermediate_joint":[0,1],
                "R_ring_intermediate_joint":[1,1],
                "R_thumb_intermediate_joint":[4,1.5],
                "R_thumb_distal_joint":[4,2.4],
            }
        self.all_joint_names = self.env.scene["robot"].data.joint_names
        self.joint_to_index = {name: i for i, name in enumerate(self.all_joint_names)}
        self.arm_action_pose = [self.joint_to_index[name] for name in self.arm_joint_mapping.keys()]
        self.arm_action_pose_indices = [self.arm_joint_mapping[name] for name in self.arm_joint_mapping.keys()]
        self.action_to_indices=[]
        for action_joint in self.action_joint_names:
            if action_joint in self.all_joint_names:
                self.action_to_indices.append(self.all_joint_names.index(action_joint))
            else:
                raise ValueError(f"action joint '{action_joint}' not in all joint list")
        self.waist_to_all_indices = []
        for waist_joint in self.waist_joint_mapping:
            if waist_joint in self.all_joint_names:
                self.waist_to_all_indices.append(self.all_joint_names.index(waist_joint))
            else:
                raise ValueError(f"waist joint '{waist_joint}' not in all joint list")

        self.arm_to_all_indices=[]
        for arm_joint in self.arm_joint_names:
            if arm_joint in self.all_joint_names:
                self.arm_to_all_indices.append(self.all_joint_names.index(arm_joint))
            else:
                raise ValueError(f"arm joint '{arm_joint}' not in all joint list")
        self.default_waist_positions = self.env.scene["robot"].data.default_joint_pos[:, self.waist_to_all_indices]
        self.default_action_positions = self.env.scene["robot"].data.default_joint_pos
        self.default_action_velocities = self.env.scene["robot"].data.default_joint_vel
        self.all_obs_indices = self.action_to_indices + self.arm_to_all_indices
        self.old_action_indices = []
        for old_action_joint in self.old_action_joints_names:
            if old_action_joint in self.all_joint_names:
                self.old_action_indices.append(self.all_joint_names.index(old_action_joint))
            else:
                raise ValueError(f"action joint '{old_action_joint}' not in all joint list")
        self.arm_action = []
        self.obs_scales = {"ang_vel":1.0, "projected_gravity":1.0, "commands":1.0, 
                           "joint_pos":1.0, "joint_vel":1.0, "actions":1.0}
        self.ang_vel = self.env.scene["robot"].data.root_ang_vel_b                      
        self.projected_gravity = self.env.scene["robot"].data.projected_gravity_b       
        self.joint_pos = self.env.scene["robot"].data.joint_pos
        self.joint_vel = self.env.scene["robot"].data.joint_vel
        self.actor_obs_buffer = CircularBuffer(
            max_len=10, batch_size=1, device=self.env.device
        )
        self.num_envs =1
        self.clip_obs = 100
        self.num_actions_all = self.env.scene["robot"].data.default_joint_pos[:,self.old_action_indices].shape[1]  
        self.action_buffer = DelayBuffer(
            5, self.num_envs, device=self.env.device
        )
        self.action_buffer.compute(
            torch.zeros(self.num_envs, self.num_actions_all, dtype=torch.float, device=self.env.device, requires_grad=False)
        )
        self.clip_actions = 100
        self.action_scale = 0.25
        self.sim_step_counter = 0
    def load_policy(self,path):
        ext = os.path.splitext(path)[1].lower()
        if ext==".onnx":
            return self.load_onnx_policy(path)
        elif ext==".pt":
            return self.load_jit_pt_policy(path)

    def load_jit_pt_policy(self,path):
        return torch.jit.load(path)

    def load_onnx_policy(self,path):
        model = ort.InferenceSession(path)
        def run_inference(input_tensor):
            ort_inputs = {model.get_inputs()[0].name: input_tensor.cpu().numpy()}
            ort_outs = model.run(None, ort_inputs)
            return torch.tensor(ort_outs[0], device=self.env.device)
        return run_inference
    def compute_current_observations(self):
        command = [0,0,0,0.8]  
        run_command = self.run_command_dds.get_run_command()
        if run_command and 'run_command' in run_command:
            run_command_data = run_command['run_command']
            
            if isinstance(run_command_data, str):
                try:
                    run_command_list = ast.literal_eval(run_command_data)
                    if isinstance(run_command_list, list) and len(run_command_list) >= 4:
                        command[0] = float(run_command_list[0])
                        command[1] = float(run_command_list[1])
                        command[2] = float(run_command_list[2])
                        command[3] = float(run_command_list[3])
                except (ValueError, SyntaxError) as e:
                    print(f"[WARNING] cannot parse run_command string: {run_command_data}, error: {e}")
            else:
                try:
                    command[0] = float(run_command_data[0])
                    command[1] = float(run_command_data[1])
                    command[2] = float(run_command_data[2])
                    command[3] = float(run_command_data[3])
                except (IndexError, TypeError) as e:
                    print(f"[WARNING] cannot parse run_command data: {run_command_data}, error: {e}")
            
            self.run_command_dds.write_run_command([0.0,0,0,0.8])
      
        # command = [0.5,0.0,0.7,0.8]
        command = torch.tensor(command, device=self.env.device, dtype=torch.float32)
        
        if command.dim() == 1:
            command = command.unsqueeze(0)  # [4] -> [1, 4]
        self.ang_vel = self.env.scene["robot"].data.root_ang_vel_b                      
        self.projected_gravity = self.env.scene["robot"].data.projected_gravity_b       
        self.joint_pos = self.env.scene["robot"].data.joint_pos
        self.joint_vel = self.env.scene["robot"].data.joint_vel
        action = self.action_buffer._circular_buffer.buffer[:, -1, :]     
        current_actor_obs = torch.cat(
        [
            self.ang_vel * self.obs_scales["ang_vel"],
            self.projected_gravity * self.obs_scales["projected_gravity"],
            command * self.obs_scales["commands"],
            (self.joint_pos[:, self.all_obs_indices] - self.default_action_positions[:, self.all_obs_indices]) * self.obs_scales["joint_pos"],
            (self.joint_vel[:, self.all_obs_indices] - self.default_action_velocities[:, self.all_obs_indices]) * self.obs_scales["joint_vel"],
            action * self.obs_scales["actions"],  # [29] -> [1, 29]
        ],
        dim=-1,
    )
        return current_actor_obs
    def compute_observations(self):

        current_actor_obs = self.compute_current_observations()

        self.actor_obs_buffer.append(current_actor_obs)
        actor_obs = self.actor_obs_buffer.buffer.reshape(self.num_envs, -1)
        actor_obs = torch.clip(actor_obs, -self.clip_obs, self.clip_obs)
        return actor_obs
    
    def run_policy(self):
        current_actor_obs = self.compute_observations()
        action = self.policy(current_actor_obs)
        return action
    def get_action(self, env) -> Optional[torch.Tensor]:
        """Get action from DDS"""
        try:
            full_action = self._full_action_buf
            full_action.zero_()
            action_data = self.run_policy()

            # RL è¾“å‡ºä¸è…°éƒ¨é»˜è®¤ä½å§¿
            full_action[self.action_to_indices] = action_data
            full_action[self.waist_to_all_indices] = self.default_waist_positions
            # æœºå™¨äººæŒ‡ä»¤ï¼ˆè‹¥æœ‰ï¼‰
            if self.enable_robot == "g129" and self.robot_dds:
                cmd_data = self.robot_dds.get_robot_command()
                if cmd_data and 'motor_cmd' in cmd_data:
                    positions = cmd_data['motor_cmd']['positions']
                    if len(positions) >= 29 and hasattr(self, "_arm_source_idx_t"):
                        self._positions_buf[:29].copy_(torch.tensor(positions[:29], dtype=torch.float32, device=self.env.device))
                        arm_vals = self._positions_buf.index_select(0, self._arm_source_idx_t)
                        full_action.index_copy_(0, self._arm_target_idx_t, arm_vals)
            # å»¶æ—¶/è£å‰ª/ç¼©æ”¾
            delayed_actions = self.action_buffer.compute(full_action[self.old_action_indices].unsqueeze(0))
            cliped_actions = torch.clip(delayed_actions[:,self.action_to_indices], -self.clip_actions, self.clip_actions).to(self.env.device)
            full_action[self.action_to_indices] = cliped_actions * self.action_scale + self.default_action_positions[:, self.action_to_indices]
            
            # å¤¹çˆª/æ‰‹æŒ‡ï¼ˆè‹¥æœ‰ï¼‰
            if self.gripper_dds and hasattr(self, "_gripper_source_idx_t"):
                gripper_cmd = self.gripper_dds.get_gripper_command()
                if gripper_cmd:
                    left_gripper_cmd = gripper_cmd.get('left_gripper_cmd', {})
                    right_gripper_cmd = gripper_cmd.get('right_gripper_cmd', {})
                    left_gripper_positions = left_gripper_cmd.get('positions', [])
                    right_gripper_positions = right_gripper_cmd.get('positions', [])
                    gripper_positions = right_gripper_positions + left_gripper_positions
                    if len(gripper_positions) >= 2:
                        self._gripper_buf.copy_(torch.tensor(gripper_positions[:2], dtype=torch.float32, device=self.env.device))
                        gp_vals = self._gripper_buf.index_select(0, self._gripper_source_idx_t)
                        full_action.index_copy_(0, self._gripper_target_idx_t, gp_vals)
            elif self.dex3_dds and hasattr(self, "_left_hand_source_idx_t"):
                hand_cmds = self.dex3_dds.get_hand_commands()
                if hand_cmds:
                    left_hand_cmd = hand_cmds.get('left_hand_cmd', {})
                    right_hand_cmd = hand_cmds.get('right_hand_cmd', {})
                    if left_hand_cmd and right_hand_cmd:
                        left_positions = left_hand_cmd.get('positions', [])
                        right_positions = right_hand_cmd.get('positions', [])
                        if len(left_positions) >= len(self._left_hand_buf) and len(right_positions) >= len(self._right_hand_buf):
                            self._left_hand_buf.copy_(torch.tensor(left_positions[:len(self._left_hand_buf)], dtype=torch.float32, device=self.env.device))
                            self._right_hand_buf.copy_(torch.tensor(right_positions[:len(self._right_hand_buf)], dtype=torch.float32, device=self.env.device))
                            l_vals = self._left_hand_buf.index_select(0, self._left_hand_source_idx_t)
                            r_vals = self._right_hand_buf.index_select(0, self._right_hand_source_idx_t)
                            full_action.index_copy_(0, self._left_hand_target_idx_t, l_vals)
                            full_action.index_copy_(0, self._right_hand_target_idx_t, r_vals)
            elif self.inspire_dds and hasattr(self, "_inspire_source_idx_t"):
                inspire_cmds = self.inspire_dds.get_inspire_hand_command()
                if inspire_cmds and 'positions' in inspire_cmds:
                        inspire_cmds_positions = inspire_cmds['positions']
                        if len(inspire_cmds_positions) >= 12:
                            self._inspire_buf.copy_(torch.tensor(inspire_cmds_positions[:12], dtype=torch.float32, device=self.env.device))
                            base_vals = self._inspire_buf.index_select(0, self._inspire_source_idx_t)
                            full_action.index_copy_(0, self._inspire_target_idx_t, base_vals)
                            special_vals = self._inspire_buf.index_select(0, self._inspire_special_source_idx_t) * self._inspire_special_scales_t
                            full_action.index_copy_(0, self._inspire_special_target_idx_t, special_vals)
            # åŒæ­¥ä»¿çœŸå¤šæ­¥
            for _ in range(4):
                self.env.scene["robot"].set_joint_position_target(full_action) 
                self.env.scene.write_data_to_sim()                           
                self.env.sim.step(render=False)                              
                self.env.scene.update(dt=self.env.physics_dt)                    

            self.env.sim.render()
            self.env.observation_manager.compute()
            
        except Exception as e:
            print(f"[{self.name}] Get DDS action failed: {e}")
            return None
    
    def _convert_to_joint_range(self, value):
        """Convert gripper control value to joint angle"""
        input_min, input_max = 0.0, 5.6
        output_min, output_max = 0.03, -0.02
        value = max(input_min, min(input_max, value))
        return output_min + (output_max - output_min) * (value - input_min) / (input_max - input_min)
    
    def cleanup(self):
        """Clean up DDS resources"""
        try:
            if self.robot_dds:
                self.robot_dds.stop_communication()
            if self.gripper_dds:
                self.gripper_dds.stop_communication()
            if self.dex3_dds:
                self.dex3_dds.stop_communication()
            if self.inspire_dds:
                self.inspire_dds.stop_communication()
        except Exception as e:
            print(f"[{self.name}] Clean up DDS resources failed: {e}")

===== action_provider/create_action_provider.py =====

from action_provider.action_provider_dds import DDSActionProvider


from action_provider.action_provider_replay import FileActionProviderReplay

from action_provider.action_provider_wh_dds import DDSRLActionProvider
from pathlib import Path


def create_action_provider(env,args):
    """create action provider based on parameters"""
    if args.action_source == "dds":
        return DDSActionProvider(
            env=env,
            args_cli=args
        )
    elif args.action_source == "dds_wholebody":
        return DDSRLActionProvider(
            env=env,
            args_cli=args
        )
    elif args.action_source == "replay":
        return FileActionProviderReplay(env=env,args_cli=args)
    else:
        print(f"unknown action source: {args.action_source}")
        return None

===== annotate_demos.py =====

# Copyright (c) 2024-2025, The Isaac Lab Project Developers (https://github.com/isaac-sim/IsaacLab/blob/main/CONTRIBUTORS.md).
# All rights reserved.
#
# SPDX-License-Identifier: Apache-2.0

"""
Script to add mimic annotations to demos to be used as source demos for mimic dataset generation.
"""

import argparse
import math
from pprint import pprint
import time

from isaaclab.app import AppLauncher

# Launching Isaac Sim Simulator first.


# add argparse arguments
parser = argparse.ArgumentParser(description="Annotate demonstrations for Isaac Lab environments.")
parser.add_argument("--task", type=str, default=None, help="Name of the task.")
parser.add_argument(
    "--input_file", type=str, default="./datasets/dataset.hdf5", help="File name of the dataset to be annotated."
)
parser.add_argument(
    "--output_file",
    type=str,
    default="./datasets/dataset_annotated.hdf5",
    help="File name of the annotated output dataset file.",
)
parser.add_argument("--auto", action="store_true", default=False, help="Automatically annotate subtasks.")
parser.add_argument(
    "--enable_pinocchio",
    action="store_true",
    default=False,
    help="Enable Pinocchio.",
)
parser.add_argument(
    "--annotate_subtask_start_signals",
    action="store_true",
    default=False,
    help="Enable annotating start points of subtasks.",
)
parser.add_argument("--seed", type=int, default=42, help="environment seed")

# append AppLauncher cli args
AppLauncher.add_app_launcher_args(parser)
# parse the arguments
args_cli = parser.parse_args()
print(args_cli)

if args_cli.enable_pinocchio:
    # Import pinocchio before AppLauncher to force the use of the version installed by IsaacLab and not the one installed by Isaac Sim
    # pinocchio is required by the Pink IK controllers and the GR1T2 retargeter
    import pinocchio  # noqa: F401

# launch the simulator
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app

"""Rest everything follows."""

import contextlib
import gymnasium as gym
import os
import torch

import isaaclab_mimic.envs  # noqa: F401

if args_cli.enable_pinocchio:
    import isaaclab_mimic.envs.pinocchio_envs  # noqa: F401

# Only enables inputs if this script is NOT headless mode
# if not args_cli.headless and not os.environ.get("HEADLESS", 0):
from isaaclab.devices import Se3Keyboard, Se3KeyboardCfg

from isaaclab.envs import ManagerBasedRLMimicEnv
from isaaclab.envs.mdp.recorders.recorders_cfg import ActionStateRecorderManagerCfg
from isaaclab.managers import RecorderTerm, RecorderTermCfg, TerminationTermCfg
from isaaclab.utils import configclass
from isaaclab.utils.datasets import EpisodeData, HDF5DatasetFileHandler

import tasks  # noqa: F401
from isaaclab_tasks.utils.parse_cfg import parse_env_cfg

is_paused = False
current_action_index = 0
marked_subtask_action_indices = []
skip_episode = False


def play_cb():
    global is_paused
    print("N key received")
    is_paused = False


def pause_cb():
    global is_paused
    print("B key received")
    is_paused = True


def skip_episode_cb():
    global skip_episode
    print("Q key received")
    skip_episode = True


def mark_subtask_cb():
    global current_action_index, marked_subtask_action_indices
    print("S key received")
    marked_subtask_action_indices.append(current_action_index)
    print(f"Marked a subtask signal at action index: {current_action_index}")


class PreStepDatagenInfoRecorder(RecorderTerm):
    """Recorder term that records the datagen info data in each step."""

    def record_pre_step(self):
        eef_pose_dict = {}
        for eef_name in self._env.cfg.subtask_configs.keys():
            eef_pose_dict[eef_name] = self._env.get_robot_eef_pose(eef_name=eef_name)

        datagen_info = {
            "object_pose": self._env.get_object_poses(),
            "eef_pose": eef_pose_dict,
            "target_eef_pose": self._env.action_to_target_eef_pose(self._env.action_manager.action),
        }
        return "obs/datagen_info", datagen_info


@configclass
class PreStepDatagenInfoRecorderCfg(RecorderTermCfg):
    """Configuration for the datagen info recorder term."""

    class_type: type[RecorderTerm] = PreStepDatagenInfoRecorder


class PreStepSubtaskStartsObservationsRecorder(RecorderTerm):
    """Recorder term that records the subtask start observations in each step."""

    def record_pre_step(self):
        return "obs/datagen_info/subtask_start_signals", self._env.get_subtask_start_signals()


@configclass
class PreStepSubtaskStartsObservationsRecorderCfg(RecorderTermCfg):
    """Configuration for the subtask start observations recorder term."""

    class_type: type[RecorderTerm] = PreStepSubtaskStartsObservationsRecorder


class PreStepSubtaskTermsObservationsRecorder(RecorderTerm):
    """Recorder term that records the subtask completion observations in each step."""

    def record_pre_step(self):
        return "obs/datagen_info/subtask_term_signals", self._env.get_subtask_term_signals()


@configclass
class PreStepSubtaskTermsObservationsRecorderCfg(RecorderTermCfg):
    """Configuration for the step subtask terms observation recorder term."""

    class_type: type[RecorderTerm] = PreStepSubtaskTermsObservationsRecorder


@configclass
class MimicRecorderManagerCfg(ActionStateRecorderManagerCfg):
    """Mimic specific recorder terms."""

    record_pre_step_datagen_info = PreStepDatagenInfoRecorderCfg()
    record_pre_step_subtask_start_signals = PreStepSubtaskStartsObservationsRecorderCfg()
    record_pre_step_subtask_term_signals = PreStepSubtaskTermsObservationsRecorderCfg()


def main():
    """Add Isaac Lab Mimic annotations to the given demo dataset file."""
    global is_paused, current_action_index, marked_subtask_action_indices

    # Load input dataset to be annotated
    if not os.path.exists(args_cli.input_file):
        raise FileNotFoundError(f"The input dataset file {args_cli.input_file} does not exist.")
    dataset_file_handler = HDF5DatasetFileHandler()
    dataset_file_handler.open(args_cli.input_file)

    env_name = dataset_file_handler.get_env_name()
    episode_count = dataset_file_handler.get_num_episodes()

    if episode_count == 0:
        print("No episodes found in the dataset.")
        return 0

    # get output directory path and file name (without extension) from cli arguments
    output_dir = os.path.dirname(args_cli.output_file)
    output_file_name = os.path.splitext(os.path.basename(args_cli.output_file))[0]
    # create output directory if it does not exist
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    if args_cli.task is not None:
        env_name = args_cli.task.split(":")[-1]
    if env_name is None:
        raise ValueError("Task/env name was not specified nor found in the dataset.")

    env_cfg = parse_env_cfg(env_name, device=args_cli.device, num_envs=1)

    env_cfg.env_name = env_name

    # extract success checking function to invoke manually
    success_term = None
    if hasattr(env_cfg.terminations, "success"):
        success_term = env_cfg.terminations.success
        env_cfg.terminations.success = None
    else:
        raise NotImplementedError("No success termination term was found in the environment.")

    # Disable all termination terms
    env_cfg.terminations = None

    # Set up recorder terms for mimic annotations
    env_cfg.recorders = MimicRecorderManagerCfg()
    if not args_cli.auto:
        # disable subtask term signals recorder term if in manual mode
        env_cfg.recorders.record_pre_step_subtask_term_signals = None

    if not args_cli.auto or (args_cli.auto and not args_cli.annotate_subtask_start_signals):
        # disable subtask start signals recorder term if in manual mode or no need for subtask start annotations
        env_cfg.recorders.record_pre_step_subtask_start_signals = None

    env_cfg.recorders.dataset_export_dir_path = output_dir
    env_cfg.recorders.dataset_filename = output_file_name
    env_cfg.seed = args_cli.seed

    # create environment from loaded config (set the seed to be able to replicate collected data)
    env: ManagerBasedRLMimicEnv = gym.make(args_cli.task, cfg=env_cfg).unwrapped
    env.seed(args_cli.seed)

    print("total_action_dim:", env.action_manager.total_action_dim)
    for name, term in env.action_manager._terms.items():
        print(name, term.action_dim)

    if not isinstance(env, ManagerBasedRLMimicEnv):
        raise ValueError("The environment should be derived from ManagerBasedRLMimicEnv")

    if args_cli.auto:
        # check if the mimic API env.get_subtask_term_signals() is implemented
        if env.get_subtask_term_signals.__func__ is ManagerBasedRLMimicEnv.get_subtask_term_signals:
            raise NotImplementedError(
                "The environment does not implement the get_subtask_term_signals method required "
                "to run automatic annotations."
            )
        if (
            args_cli.annotate_subtask_start_signals
            and env.get_subtask_start_signals.__func__ is ManagerBasedRLMimicEnv.get_subtask_start_signals
        ):
            raise NotImplementedError(
                "The environment does not implement the get_subtask_start_signals method required "
                "to run automatic annotations."
            )
    else:
        # get subtask termination signal names for each eef from the environment configs
        subtask_term_signal_names = {}
        subtask_start_signal_names = {}
        for eef_name, eef_subtask_configs in env.cfg.subtask_configs.items():
            subtask_start_signal_names[eef_name] = (
                [subtask_config.subtask_term_signal for subtask_config in eef_subtask_configs]
                if args_cli.annotate_subtask_start_signals
                else []
            )
            subtask_term_signal_names[eef_name] = [
                subtask_config.subtask_term_signal for subtask_config in eef_subtask_configs
            ]
            # Validation: if annotating start signals, every subtask (including the last) must have a name
            if args_cli.annotate_subtask_start_signals:
                if any(name in (None, "") for name in subtask_start_signal_names[eef_name]):
                    raise ValueError(
                        f"Missing 'subtask_term_signal' for one or more subtasks in eef '{eef_name}'. When"
                        " '--annotate_subtask_start_signals' is enabled, each subtask (including the last) must"
                        " specify 'subtask_term_signal'. The last subtask's term signal name is used as the final"
                        " start signal name."
                    )
            # no need to annotate the last subtask term signal, so remove it from the list
            subtask_term_signal_names[eef_name].pop()

    # reset environment
    env.reset()

    print(f"cli args: {args_cli}")

    # Only enables inputs if this script is NOT headless mode
    # if not args_cli.headless and not os.environ.get("HEADLESS", 0):
    keyboard_interface = Se3Keyboard(Se3KeyboardCfg(pos_sensitivity=0.1, rot_sensitivity=0.1))
    keyboard_interface.add_callback("N", play_cb)
    keyboard_interface.add_callback("B", pause_cb)
    keyboard_interface.add_callback("Q", skip_episode_cb)
    if not args_cli.auto:
        keyboard_interface.add_callback("S", mark_subtask_cb)
    keyboard_interface.reset()
    print("Keyboard interface reset")

    # simulate environment -- run everything in inference mode
    exported_episode_count = 0
    processed_episode_count = 0
    successful_task_count = 0  # Counter for successful task completions
    with contextlib.suppress(KeyboardInterrupt) and torch.inference_mode():
        while simulation_app.is_running() and not simulation_app.is_exiting():
            # Iterate over the episodes in the loaded dataset file
            for episode_index, episode_name in enumerate(dataset_file_handler.get_episode_names()):
                processed_episode_count += 1
                print(f"\nAnnotating episode #{episode_index} ({episode_name})")
                episode = dataset_file_handler.load_episode(episode_name, env.device)

                is_episode_annotated_successfully = False
                if args_cli.auto:
                    is_episode_annotated_successfully = annotate_episode_in_auto_mode(env, episode, success_term, episode_name)
                else:
                    is_episode_annotated_successfully = annotate_episode_in_manual_mode(
                        env, episode, success_term, subtask_term_signal_names, subtask_start_signal_names
                    )

                if is_episode_annotated_successfully and not skip_episode:
                    # set success to the recorded episode data and export to file
                    env.recorder_manager.set_success_to_episodes(
                        None, torch.tensor([[True]], dtype=torch.bool, device=env.device)
                    )
                    env.recorder_manager.export_episodes()
                    exported_episode_count += 1
                    successful_task_count += 1  # Increment successful task counter
                    print("\tExported the annotated episode.")
                else:
                    print("\tSkipped exporting the episode due to incomplete subtask annotations.")
            break

    print(
        f"\nExported {exported_episode_count} (out of {processed_episode_count}) annotated"
        f" episode{'s' if exported_episode_count > 1 else ''}."
    )
    print(
        f"Successful task completions: {successful_task_count}"
    )  # This line is used by the dataset generation test case to check if the expected number of demos were annotated
    print("Exiting the app.")

    # Close environment after annotation is complete
    env.close()

    return successful_task_count


def replay_episode(
    env: ManagerBasedRLMimicEnv,
    episode: EpisodeData,
    success_term: TerminationTermCfg | None = None,
    episode_name: str="",
) -> bool:
    """Replays an episode in the environment.

    This function replays the given recorded episode in the environment. It can optionally check if the task
    was successfully completed using a success termination condition input.

    Args:
        env: The environment to replay the episode in.
        episode: The recorded episode data to replay.
        success_term: Optional termination term to check for task success.

    Returns:
        True if the episode was successfully replayed and the success condition was met (if provided),
        False otherwise.
    """
    global current_action_index, skip_episode, is_paused
    # read initial state and actions from the loaded episode
    initial_state = episode.data["initial_state"]
    raw_states = episode.data["states"]
    actions = episode.data["actions"]

    states_list = [
        {
            "articulation": {
                "robot": {
                    "joint_position": raw_states["articulation"]["robot"]["joint_position"][i:i+1, :],
                    "joint_velocity": raw_states["articulation"]["robot"]["joint_velocity"][i:i+1, :],
                    "root_pose":      raw_states["articulation"]["robot"]["root_pose"][i:i+1, :],
                    "root_velocity":  raw_states["articulation"]["robot"]["root_velocity"][i:i+1, :],
                }
            },
            "rigid_object": {
                "object": {
                    "root_pose":     raw_states["rigid_object"]["object"]["root_pose"][i:i+1, :],
                    "root_velocity": raw_states["rigid_object"]["object"]["root_velocity"][i:i+1, :],
                }
            }
        }
        for i in range(raw_states["articulation"]["robot"]["joint_position"].shape[0])
    ]

    print("length of actions and states")
    print(actions.shape)
    print(len(states_list))

    print(f"initial state: {initial_state['rigid_object']}")

    env.recorder_manager.reset()
    env.sim.reset()
    env.reset_to(initial_state, None, is_relative=True)
    env.sim.render()
    time.sleep(1) # follows on from sim_main.py

    joint_positions = [
        env.scene["robot"].data.joint_pos[0].clone().detach().cpu()
    ]
    
    first_action = True
    for action_index, action in enumerate(actions):
        current_action_index = action_index
        if first_action:
            first_action = False
        else:
            while is_paused or skip_episode:
                env.sim.render()
                if skip_episode:
                    return False
                continue
        action_tensor = torch.Tensor(action).reshape([1, action.shape[0]])
        env.step(torch.Tensor(action_tensor))
        joint_positions.append(env.scene["robot"].data.joint_pos[0].clone().detach().cpu())
        env.reset_to(states_list[action_index], None, is_relative=True)
        env.sim.render()
    positions = torch.stack(joint_positions)
    torch.save(positions, f"/workspace/joint_positions_{episode_name}.pt")
    if success_term is not None:
        success_term_value = success_term.func(env, **success_term.params)
        print(f"success term value: {success_term_value}")
        if not bool(success_term_value[0]):
            return False
    return True


def annotate_episode_in_auto_mode(
    env: ManagerBasedRLMimicEnv,
    episode: EpisodeData,
    success_term: TerminationTermCfg | None = None,
    episode_name: str="",
) -> bool:
    """Annotates an episode in automatic mode.

    This function replays the given episode in the environment and checks if the task was successfully completed.
    If the task was not completed, it will print a message and return False. Otherwise, it will check if all the
    subtask term signals are annotated and return True if they are, False otherwise.

    Args:
        env: The environment to replay the episode in.
        episode: The recorded episode data to replay.
        success_term: Optional termination term to check for task success.

    Returns:
        True if the episode was successfully annotated, False otherwise.
    """
    global skip_episode
    skip_episode = False
    is_episode_annotated_successfully = replay_episode(env, episode, success_term, episode_name)
    if skip_episode:
        print("\tSkipping the episode.")
        return False
    if not is_episode_annotated_successfully:
        print("\tThe final task was not completed.")
    else:
        # check if all the subtask term signals are annotated
        annotated_episode = env.recorder_manager.get_episode(0)
        subtask_term_signal_dict = annotated_episode.data["obs"]["datagen_info"]["subtask_term_signals"]
        for signal_name, signal_flags in subtask_term_signal_dict.items():
            signal_flags = torch.tensor(signal_flags, device=env.device)
            if not torch.any(signal_flags):
                is_episode_annotated_successfully = False
                print(f'\tDid not detect completion for the subtask "{signal_name}".')
        if args_cli.annotate_subtask_start_signals:
            subtask_start_signal_dict = annotated_episode.data["obs"]["datagen_info"]["subtask_start_signals"]
            for signal_name, signal_flags in subtask_start_signal_dict.items():
                if not torch.any(signal_flags):
                    is_episode_annotated_successfully = False
                    print(f'\tDid not detect start for the subtask "{signal_name}".')
    return is_episode_annotated_successfully


def annotate_episode_in_manual_mode(
    env: ManagerBasedRLMimicEnv,
    episode: EpisodeData,
    success_term: TerminationTermCfg | None = None,
    subtask_term_signal_names: dict[str, list[str]] = {},
    subtask_start_signal_names: dict[str, list[str]] = {},
) -> bool:
    """Annotates an episode in manual mode.

    This function replays the given episode in the environment and allows for manual marking of subtask term signals.
    It iterates over each eef and prompts the user to mark the subtask term signals for that eef.

    Args:
        env: The environment to replay the episode in.
        episode: The recorded episode data to replay.
        success_term: Optional termination term to check for task success.
        subtask_term_signal_names: Dictionary mapping eef names to lists of subtask term signal names.
        subtask_start_signal_names: Dictionary mapping eef names to lists of subtask start signal names.
    Returns:
        True if the episode was successfully annotated, False otherwise.
    """
    global is_paused, marked_subtask_action_indices, skip_episode
    # iterate over the eefs for marking subtask term signals
    subtask_term_signal_action_indices = {}
    subtask_start_signal_action_indices = {}
    for eef_name, eef_subtask_term_signal_names in subtask_term_signal_names.items():
        eef_subtask_start_signal_names = subtask_start_signal_names[eef_name]
        # skip if no subtask annotation is needed for this eef
        if len(eef_subtask_term_signal_names) == 0 and len(eef_subtask_start_signal_names) == 0:
            continue

        while True:
            is_paused = True
            skip_episode = False
            print(f'\tPlaying the episode for subtask annotations for eef "{eef_name}".')
            print("\tSubtask signals to annotate:")
            if len(eef_subtask_start_signal_names) > 0:
                print(f"\t\t- Start:\t{eef_subtask_start_signal_names}")
            print(f"\t\t- Termination:\t{eef_subtask_term_signal_names}")

            print('\n\tPress "N" to begin.')
            print('\tPress "B" to pause.')
            print('\tPress "S" to annotate subtask signals.')
            print('\tPress "Q" to skip the episode.\n')
            marked_subtask_action_indices = []
            task_success_result = replay_episode(env, episode, success_term)
            if skip_episode:
                print("\tSkipping the episode.")
                return False

            print(f"\tSubtasks marked at action indices: {marked_subtask_action_indices}")
            expected_subtask_signal_count = len(eef_subtask_term_signal_names) + len(eef_subtask_start_signal_names)
            if task_success_result and expected_subtask_signal_count == len(marked_subtask_action_indices):
                print(f'\tAll {expected_subtask_signal_count} subtask signals for eef "{eef_name}" were annotated.')
                for marked_signal_index in range(expected_subtask_signal_count):
                    if args_cli.annotate_subtask_start_signals and marked_signal_index % 2 == 0:
                        subtask_start_signal_action_indices[
                            eef_subtask_start_signal_names[int(marked_signal_index / 2)]
                        ] = marked_subtask_action_indices[marked_signal_index]
                    if not args_cli.annotate_subtask_start_signals:
                        # Direct mapping when only collecting termination signals
                        subtask_term_signal_action_indices[eef_subtask_term_signal_names[marked_signal_index]] = (
                            marked_subtask_action_indices[marked_signal_index]
                        )
                    elif args_cli.annotate_subtask_start_signals and marked_signal_index % 2 == 1:
                        # Every other signal is a termination when collecting both types
                        subtask_term_signal_action_indices[
                            eef_subtask_term_signal_names[math.floor(marked_signal_index / 2)]
                        ] = marked_subtask_action_indices[marked_signal_index]
                break

            if not task_success_result:
                print("\tThe final task was not completed.")
                return False

            if expected_subtask_signal_count != len(marked_subtask_action_indices):
                print(
                    f"\tOnly {len(marked_subtask_action_indices)} out of"
                    f' {expected_subtask_signal_count} subtask signals for eef "{eef_name}" were'
                    " annotated."
                )

            print(f'\tThe episode will be replayed again for re-marking subtask signals for the eef "{eef_name}".\n')

    annotated_episode = env.recorder_manager.get_episode(0)
    for (
        subtask_term_signal_name,
        subtask_term_signal_action_index,
    ) in subtask_term_signal_action_indices.items():
        # subtask termination signal is false until subtask is complete, and true afterwards
        subtask_signals = torch.ones(len(episode.data["actions"]), dtype=torch.bool)
        subtask_signals[:subtask_term_signal_action_index] = False
        annotated_episode.add(f"obs/datagen_info/subtask_term_signals/{subtask_term_signal_name}", subtask_signals)

    if args_cli.annotate_subtask_start_signals:
        for (
            subtask_start_signal_name,
            subtask_start_signal_action_index,
        ) in subtask_start_signal_action_indices.items():
            subtask_signals = torch.ones(len(episode.data["actions"]), dtype=torch.bool)
            subtask_signals[:subtask_start_signal_action_index] = False
            annotated_episode.add(
                f"obs/datagen_info/subtask_start_signals/{subtask_start_signal_name}", subtask_signals
            )

    return True


if __name__ == "__main__":
    # run the main function
    successful_task_count = main()
    # close sim app
    simulation_app.close()
    # exit with the number of successful task completions as return code
    exit(successful_task_count)

===== dds/__init__.py =====



===== dds/commands_dds.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
Run command DDS communication class
Specialized in receiving the run command
"""

import threading
from typing import Any, Dict, Optional
from dds.dds_base import DDSObject
from unitree_sdk2py.core.channel import ChannelSubscriber
from unitree_sdk2py.idl.std_msgs.msg.dds_ import String_


class RunCommandDDS(DDSObject):
    """Run command DDS node (singleton pattern)"""
    
    def __init__(self,node_name:str="run_command_dds"):
        """Initialize the run command DDS node"""
        # avoid duplicate initialization
        if hasattr(self, '_initialized'):
            return
        super().__init__()
        
        self._initialized = True
        self.node_name = node_name
        # setup the shared memory
        self.setup_shared_memory(
            output_shm_name="isaac_run_command_cmd", 
            input_shm_name="isaac_run_command_state",
            output_size=512, 
            input_size=3072,
            outputshm_flag=True,
            inputshm_flag=True,
        )
        print(f"[{self.node_name}] Run command DDS node initialized")

    
    def setup_publisher(self) -> bool:
        """Setup the run command publisher (this node is mainly used for subscribe, the publisher is optional)"""
        pass
    
    def setup_subscriber(self) -> bool:
        """Setup the run command subscriber"""
        try:
            self.subscriber = ChannelSubscriber("rt/run_command/cmd", String_)
            self.subscriber.Init(lambda msg: self.dds_subscriber(msg, ""), 1)
            
            print(f"[{self.node_name}] Run command subscriber initialized")
            return True
        except Exception as e:
            print(f"run_command_dds [{self.node_name}] Failed to initialize the run command subscriber: {e}")
            return False
    
    
    def dds_publisher(self) -> Any:
        """Process the publish data (this node is mainly used for subscribe, the publish function is optional)"""
        pass
    
    def dds_subscriber(self, msg: String_,datatype:str=None) -> Dict[str, Any]:
        """Process the subscribe data"""
        try:
            cmd_data = {
                "run_command": msg.data
            }
            self.output_shm.write_data(cmd_data)
        except Exception as e:
            print(f"run_command_dds [{self.node_name}] Failed to process the subscribe data: {e}")
            return {}
    
    def get_run_command(self) -> Optional[Dict[str, Any]]:
        """Get the run command
        
        Returns:
            Dict: the run command, if no command return None
        """
        if self.output_shm:
            return self.output_shm.read_data()
        return None
    
    def write_run_command(self, flag_category):
        """Write the run command to the shared memory
        
        Args:
            positions: the run command, if no command return None
        """
        try:
            # prepare the reset pose data
            cmd_data = {
                "run_command":flag_category
            }
            
            # write the reset pose data to the shared memory
            if self.output_shm:
                self.output_shm.write_data(cmd_data)
                
        except Exception as e:
            print(f"run_command_dds [{self.node_name}] Failed to write the run command: {e}")
    
    def write_run_state(self, ang_vel,projected_gravity,joint_pos,joint_vel):
        """Write the robot state to the shared memory
        
        Args:
            ang_vel: the angular velocity list or torch.Tensor
            projected_gravity: the projected gravity list or torch.Tensor
            joint_pos: the joint position list or torch.Tensor
            joint_vel: the joint velocity list or torch.Tensor
        """
        if self.input_shm is None:
            return
        try:
            state_data = {
                "ang_vel": ang_vel.tolist() if hasattr(ang_vel, 'tolist') else ang_vel,
                "projected_gravity": projected_gravity.tolist() if hasattr(projected_gravity, 'tolist') else projected_gravity,
                "joint_pos": joint_pos.tolist() if hasattr(joint_pos, 'tolist') else joint_pos,
                "joint_vel": joint_vel.tolist() if hasattr(joint_vel, 'tolist') else joint_vel,
            }
            self.input_shm.write_data(state_data)
        except Exception as e:
            print(f"run_command_dds [{self.node_name}] Error writing robot state: {e}")
    def get_run_state(self):
        if self.input_shm is None:
            return None
        state_data = self.input_shm.read_data()
        if state_data is None:
            return None
        return state_data

===== dds/dds_base.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0
from abc import ABC, abstractmethod
from dds.sharedmemorymanager import SharedMemoryManager
from typing import Any
class DDSObject(ABC):
    def __init__(self):
        self.publishing = False
        self.subscribing = False
    
    @abstractmethod
    def dds_publisher(self) -> None:
        pass
    @abstractmethod
    def dds_subscriber(self,msg:Any,datatype:str=None) -> None:
        """Process subscribe data"""
        pass
    @abstractmethod
    def setup_subscriber(): 
        """Process hand command"""
        pass
    @abstractmethod
    def setup_publisher():
        """Process hand command"""
        pass
    def setup_shared_memory(self, input_shm_name: str = None, output_shm_name: str = None, 
                           input_size: int = 4096, output_size: int = 4096,inputshm_flag:bool=True,outputshm_flag:bool=True):
        """Setup shared memory
        
        Args:
            input_shm_name: input shared memory name
            output_shm_name: output shared memory name
            input_size: input shared memory size
            output_size: output shared memory size
        """
        if inputshm_flag:
            if input_shm_name:
                self.input_shm = SharedMemoryManager(input_shm_name, input_size)
                print(f"[{self.node_name}] Input shared memory: {self.input_shm.get_name()}")
            else:
                self.input_shm = SharedMemoryManager(size=input_size)
                print(f"[{self.node_name}] Input shared memory: {self.input_shm.get_name()}")
        if outputshm_flag:
            if output_shm_name:
                self.output_shm = SharedMemoryManager(output_shm_name, output_size)
                print(f"[{self.node_name}] Output shared memory: {self.output_shm.get_name()}")
            else:
                self.output_shm = SharedMemoryManager(size=output_size)
                print(f"[{self.node_name}] Output shared memory: {self.output_shm.get_name()}")
    def stop_communication(self):
        self.publishing = False
        self.subscribing = False

===== dds/dds_create.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0
from dds.dds_master import dds_manager

def create_dds_objects(args_cli,env):
    publish_names = []
    subscribe_names = []
    if args_cli.robot_type=="g129" or args_cli.robot_type=="h1_2":
        from dds.g1_robot_dds import G1RobotDDS
        g1_robot = G1RobotDDS()
        dds_manager.register_object("g129", g1_robot)
        publish_names.append("g129")
        subscribe_names.append("g129")
    if args_cli.enable_dex3_dds:
        from dds.dex3_dds import Dex3DDS
        dex3 = Dex3DDS() 
        dds_manager.register_object("dex3", dex3)
        publish_names.append("dex3")
        subscribe_names.append("dex3")
    elif args_cli.enable_dex1_dds:
        from dds.gripper_dds import GripperDDS
        gripper = GripperDDS()
        dds_manager.register_object("dex1", gripper)
        publish_names.append("dex1")
        subscribe_names.append("dex1")
    elif args_cli.enable_inspire_dds:
        from dds.inspire_dds import InspireDDS
        inspire = InspireDDS()
        dds_manager.register_object("inspire", inspire)
        publish_names.append("inspire")
        subscribe_names.append("inspire")
    if "Wholebody" in args_cli.task or args_cli.enable_wholebody_dds:
        from dds.commands_dds import RunCommandDDS
        run_command_dds = RunCommandDDS()
        dds_manager.register_object("run_command", run_command_dds)
        publish_names.append("run_command")
        subscribe_names.append("run_command")
    from dds.reset_pose_dds import ResetPoseCmdDDS
    reset_pose_dds = ResetPoseCmdDDS()
    dds_manager.register_object("reset_pose", reset_pose_dds)
    subscribe_names.append("reset_pose")
    from dds.sim_state_dds import SimStateDDS
    sim_state_dds = SimStateDDS(env,args_cli.task)
    dds_manager.register_object("sim_state", sim_state_dds)
    publish_names.append("sim_state")
    from dds.rewards_dds import RewardsDDS
    rewards_dds = RewardsDDS(env,args_cli.task)
    dds_manager.register_object("rewards", rewards_dds)
    publish_names.append("rewards")

    dds_manager.start_publishing(publish_names)
    dds_manager.start_subscribing(subscribe_names)
    return reset_pose_dds,sim_state_dds,dds_manager

def create_dds_objects_replay(args_cli,env):
    publish_names = []
    subscribe_names = []
    if args_cli.robot_type=="g129" or args_cli.robot_type=="h1_2":
        from dds.g1_robot_dds import G1RobotDDS
        g1_robot = G1RobotDDS()
        dds_manager.register_object("g129", g1_robot)
        publish_names.append("g129")
        subscribe_names.append("g129")
    if args_cli.enable_dex3_dds:
        from dds.dex3_dds import Dex3DDS
        dex3 = Dex3DDS() 
        dds_manager.register_object("dex3", dex3)
        publish_names.append("dex3")
        subscribe_names.append("dex3")
    elif args_cli.enable_dex1_dds:
        from dds.gripper_dds import GripperDDS
        gripper = GripperDDS()
        dds_manager.register_object("dex1", gripper)
        publish_names.append("dex1")
        subscribe_names.append("dex1")
    elif args_cli.enable_inspire_dds:
        from dds.inspire_dds import InspireDDS
        inspire = InspireDDS()
        dds_manager.register_object("inspire", inspire)
        publish_names.append("inspire")
        subscribe_names.append("inspire")

    dds_manager.start_publishing(publish_names)
    dds_manager.start_subscribing(subscribe_names)

===== dds/dds_master.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0
import time
import threading
from typing import Dict, List, Optional
from unitree_sdk2py.core.channel import ChannelFactoryInitialize
from dds.dds_base import DDSObject



class DDSManager:    
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(DDSManager, cls).__new__(cls)
        return cls._instance
    
    def __init__(self):
        """Init DDSManager"""
        if hasattr(self, '_initialized'):
            return
        
        self._initialized = True
        self.publishing_running = False
        self.subscribing_running = False
        
        self.objects: Dict[str, DDSObject] = {}
        
        self.publish_thread: Optional[threading.Thread] = None
        self.subscribe_thread: Optional[threading.Thread] = None
        
        # publish object cache and frequency control (Hzâ†’interval)
        self._pub_list: List[str] = []
        self._pub_interval: Dict[str, float] = {}
        self._pub_next_ts: Dict[str, float] = {}
        self._default_pub_interval: float = 0.01  # 100Hz default

        self.dds_initialized = False
        self._init_dds()
        print("[DDSManager] DDSManager initialized")
    
    def _parse_object_name(self, name: str) -> tuple[str, str]:
        """Parse object name"""
        if ':' in name:
            parts = name.split(':', 1)
            return parts[0], parts[1]
        else:
            return "", name
    
    def _init_dds(self) -> bool:
        """Init DDS system"""
        if self.dds_initialized:
            return True
        
        try:
            ChannelFactoryInitialize(1)
            self.dds_initialized = True
            print("[DDSManager] DDS system initialized")
            return True
        except Exception as e:
            print(f"[DDSManager] DDS system initialization failed: {e}")
            return False
    
    def register_object(self, name: str, obj: DDSObject) -> bool:
        """Register DDS object"""
        if name in self.objects:
            print(f"[DDSManager] object '{name}' already exists")
            return False
        
        try:
            category, obj_name = self._parse_object_name(name)
            
            self.objects[name] = obj
            
            print(f"[DDSManager] register object '{name}' success (category: {category or 'No category'})")
            
            # default frequency
            self._pub_interval[name] = self._default_pub_interval
            self._pub_next_ts[name] = 0.0
            return True
        except Exception as e:
            print(f"[DDSManager] register object '{name}' failed: {e}")
            return False
    
    def unregister_object(self, name: str) -> bool:
        """Unregister DDS object"""
        if name not in self.objects:
            print(f"[DDSManager] object '{name}' not found")
            return False
        
        obj = self.objects[name]
        obj.publishing = False
        obj.subscribing = False
        
        del self.objects[name]
        self._pub_interval.pop(name, None)
        self._pub_next_ts.pop(name, None)
        if name in self._pub_list:
            self._pub_list.remove(name)
        print(f"[DDSManager] unregister object '{name}' success")
        return True
    
    def get_object(self, name: str) -> Optional[DDSObject]:
        """Get specified object"""
        obj = self.objects.get(name)
        if obj is None:
            print(f"[DDSManager] object '{name}' not found, objects: {self.objects.keys()}")
            return None
        return obj
    
    def get_objects_by_category(self, category: str) -> Dict[str, DDSObject]:
        """Get all objects by category"""
        result = {}
        for full_name, obj in self.objects.items():
            cat, obj_name = self._parse_object_name(full_name)
            if cat == category:
                result[obj_name] = obj
        return result
    
    def set_publish_rate(self, name: str, hz: float) -> None:
        """Set publish rate (Hz) for a specific object"""
        if name in self.objects and hz > 0:
            self._pub_interval[name] = 1.0 / hz
            # make the next cycle take effect immediately
            self._pub_next_ts[name] = 0.0
            print(f"[DDSManager] set publish rate for '{name}' to {hz}Hz")
    
    def set_default_publish_rate(self, hz: float) -> None:
        if hz > 0:
            self._default_pub_interval = 1.0 / hz
            for name in self.objects.keys():
                if name not in self._pub_interval:
                    self._pub_interval[name] = self._default_pub_interval
            print(f"[DDSManager] default publish rate set to {hz}Hz")

    def _publish_loop(self) -> None:
        """Publish loop thread"""
        print("[DDSManager] publish loop thread started")
        
        while self.publishing_running:
            try:
                now = time.perf_counter()
                next_due = None
                for name in self._pub_list:
                    obj = self.objects.get(name)
                    if obj is None or not obj.publishing:
                        continue
                    interval = self._pub_interval.get(name, self._default_pub_interval)
                    due = self._pub_next_ts.get(name, 0.0)
                    if now >= due:
                        try:
                            obj.dds_publisher()
                        except Exception as e:
                            print(f"[DDSManager] object '{name}' publish failed: {e}")
                        # schedule next
                        self._pub_next_ts[name] = now + interval
                    # track earliest due
                    nd = self._pub_next_ts.get(name, now + interval)
                    if next_due is None or nd < next_due:
                        next_due = nd
                # dynamic sleep until the nearest due, minimum lower bound
                if next_due is not None:
                    sleep_time = max(0.0002, next_due - time.perf_counter())
                    time.sleep(sleep_time)
                else:
                    time.sleep(0.001)
                
            except Exception as e:
                print(f"[DDSManager] publish loop error: {e}")
                time.sleep(0.01)
        
        print("[DDSManager] publish loop thread stopped")
    
    def start_publishing(self,enable_publish_names:List[str]=None):
        """Start publishing"""
        self._pub_list.clear()
        for name, obj in self.objects.items():
            if enable_publish_names is None or name in enable_publish_names:
                obj.setup_publisher()
                obj.publishing = True
                self._pub_list.append(name)
        self.publishing_running = True
        
        self.publish_thread = threading.Thread(target=self._publish_loop)
        self.publish_thread.daemon = True
        self.publish_thread.start()
        print(f"[DDSManager] manager started, managing {len(self._pub_list)} publishing objects")
    def stop_publishing(self):
        """Stop publishing"""
        for name, obj in self.objects.items():
            obj.publishing = False
        self.publishing_running = False
    def stop_subscribing(self):
        """Stop subscribing"""
        for name, obj in self.objects.items():
            obj.subscribing = False
        self.subscribing_running = False
    def start_subscribing(self,enable_subscribe_names:List[str]=None):
        """Start subscribing"""
        for name, obj in self.objects.items():  
            if enable_subscribe_names is None or name in enable_subscribe_names:
                obj.setup_subscriber()
                obj.subscribing = True


    def stop_all_communication(self):
        for name, obj in self.objects.items():
            obj.stop_communication()    
            self.publishing_running=False
            self.subscribing_running=False
# global singleton instance
dds_manager = DDSManager()


===== dds/dex3_dds.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0
"""
Dex3 DDS communication class
Handle the state publishing and command receiving of the hand (left and right)
"""

import threading
from typing import Any, Dict, Optional, Tuple
from dds.dds_base import DDSObject
from unitree_sdk2py.core.channel import ChannelPublisher, ChannelSubscriber
from unitree_sdk2py.idl.unitree_hg.msg.dds_ import HandState_, HandCmd_
from unitree_sdk2py.idl.default import unitree_hg_msg_dds__HandState_, unitree_hg_msg_dds__HandCmd_


class Dex3DDS(DDSObject):
    """Hand DDS communication class - singleton pattern
    
    Features:
    - Publish the state of the hand to DDS (rt/dex3/left/state, rt/dex3/right/state)
    - Receive the control command of the hand (rt/dex3/left/cmd, rt/dex3/right/cmd)
    """
    
    def __init__(self,node_name:str="dex3"):
        """Initialize the hand DDS node"""
        # avoid duplicate initialization
        if hasattr(self, '_initialized'):
            return
            
        super().__init__()
        self.node_name = node_name
        
        # initialize the state message of the hand
        self.left_hand_state = unitree_hg_msg_dds__HandState_()
        self.right_hand_state = unitree_hg_msg_dds__HandState_()
        
        # initialize the publisher and subscriber
        self.left_state_publisher = None
        self.right_state_publisher = None
        self.left_cmd_subscriber = None
        self.right_cmd_subscriber = None
        
        self._initialized = True
        self.existing_data = {"left_hand_cmd": {}, "right_hand_cmd": {}}
        # setup shared memory
        self.setup_shared_memory(
            input_shm_name="isaac_dex3_state",  # read the state of the hand from Isaac Lab
            input_size=1180,
            output_shm_name="isaac_dex3_cmd",  # output the command to Isaac Lab
            output_size=1180,  # output the command to Isaac Lab
        )
        
        print(f"[{self.node_name}] Hand DDS node initialized")
    
    def setup_publisher(self) -> bool:
        """Setup the publisher of the hand"""
        try:
            # left hand state publisher
            self.left_state_publisher = ChannelPublisher("rt/dex3/left/state", HandState_)
            self.left_state_publisher.Init()
            
            # right hand state publisher
            self.right_state_publisher = ChannelPublisher("rt/dex3/right/state", HandState_)
            self.right_state_publisher.Init()
            
            print(f"[{self.node_name}] Hand state publisher initialized")
            return True
        except Exception as e:
            print(f"dex3_dds [{self.node_name}] Hand state publisher initialization failed: {e}")
            return False
    
    def setup_subscriber(self) -> bool:
        """Setup the subscriber of the hand"""
        try:
            # left hand command subscriber
            self.left_cmd_subscriber = ChannelSubscriber("rt/dex3/left/cmd", HandCmd_)
            self.left_cmd_subscriber.Init(
                lambda msg: self.dds_subscriber(msg, "left"), 32
            )
            
            # right hand command subscriber
            self.right_cmd_subscriber = ChannelSubscriber("rt/dex3/right/cmd", HandCmd_)
            self.right_cmd_subscriber.Init(
                lambda msg: self.dds_subscriber(msg, "right"), 32
            )
            
            print(f"[{self.node_name}] Hand command subscriber initialized")
            return True
        except Exception as e:
            print(f"dex3_dds [{self.node_name}] Hand command subscriber initialization failed: {e}")
            return False
    
    def dds_subscriber(self, msg: HandCmd_, datatype:str=None):
        """Handle the command of the hand"""
        try:
            # process the command of the hand and write to the shared memory
            cmd_data = self.process_hand_command(msg, datatype)
            if cmd_data and self.output_shm:
                # write to shared memory
                self.existing_data[f"{datatype}_hand_cmd"] = cmd_data
                self.output_shm.write_data(self.existing_data)
        except Exception as e:
            print(f"dex3_dds [{self.node_name}] Error handling {datatype} hand command: {e}")
    
    def process_hand_command(self, msg: HandCmd_, datatype:str=None) -> Dict[str, Any]:
        """Process the command of the hand"""
        try:
            cmd_data = {
                "positions": [float(msg.motor_cmd[i].q) for i in range(len(msg.motor_cmd))],
                "velocities": [float(msg.motor_cmd[i].dq) for i in range(len(msg.motor_cmd))],
                "torques": [float(msg.motor_cmd[i].tau) for i in range(len(msg.motor_cmd))],
                "kp": [float(msg.motor_cmd[i].kp) for i in range(len(msg.motor_cmd))],
                "kd": [float(msg.motor_cmd[i].kd) for i in range(len(msg.motor_cmd))]
            }
            return cmd_data
        except Exception as e:
            print(f"dex3_dds [{self.node_name}] Error processing {datatype} hand command data: {e}")
            return {}
    
    def dds_publisher(self) -> Any:
        """Process the publish data: convert the hand state of Isaac Lab to DDS message
        
        Expected data format:
        {
            "left_hand": {
                "positions": [7 left hand joint positions],
                "velocities": [7 left hand joint velocities],
                "torques": [7 left hand joint torques]
            },
            "right_hand": {
                "positions": [7 right hand joint positions],
                "velocities": [7 right hand joint velocities],
                "torques": [7 right hand joint torques]
            }
        }
        """
        try:
            data = self.input_shm.read_data() or {}
            
            # process the left hand data
            if "left_hand" in data:
                left_data = data["left_hand"]
                self._update_hand_state(self.left_hand_state, left_data)
                if self.left_state_publisher:
                    self.left_state_publisher.Write(self.left_hand_state)
            
            # process the right hand data
            if "right_hand" in data:
                right_data = data["right_hand"]
                self._update_hand_state(self.right_hand_state, right_data)
                if self.right_state_publisher:
                    self.right_state_publisher.Write(self.right_hand_state)
        except Exception as e:
            print(f"dex3_dds [{self.node_name}] Error processing publish data: {e}")
            return None
    
    def _update_hand_state(self, hand_state, hand_data: Dict[str, Any]):
        """Update the hand state"""
        try:
            if all(key in hand_data for key in ["positions", "velocities", "torques"]):
                positions = hand_data["positions"]
                velocities = hand_data["velocities"]
                torques = hand_data["torques"]
                
                for i in range(min(7, len(positions))):  # at most 7 fingers
                    if i < len(positions):
                        hand_state.motor_state[i].q = float(positions[i])
                    if i < len(velocities):
                        hand_state.motor_state[i].dq = float(velocities[i])
                    if i < len(torques):
                        hand_state.motor_state[i].tau_est = float(torques[i])
        except Exception as e:
            print(f"dex3_dds [{self.node_name}] Error updating hand state: {e}")
    

    
    def get_hand_commands(self) -> Optional[Dict[str, Any]]:
        """Get the hand control commands
        
        Returns:
            Dict: the dictionary containing the commands of the left and right hands, the format is as follows:
            {
                "left_hand_cmd": {left hand command},
                "right_hand_cmd": {right hand command}
            }
        """
        if self.output_shm:
            return self.output_shm.read_data()
        return None
    
    def get_left_hand_command(self) -> Optional[Dict[str, Any]]:
        """Get the left hand command"""
        commands = self.get_hand_commands()
        if commands and "left_hand_cmd" in commands:
            return commands["left_hand_cmd"]
        return None
    
    def get_right_hand_command(self) -> Optional[Dict[str, Any]]:
        """Get the right hand command"""
        commands = self.get_hand_commands()
        if commands and "right_hand_cmd" in commands:
            return commands["right_hand_cmd"]
        return None
    
    def publish_hand_states(self, left_hand_data: Dict[str, Any], right_hand_data: Dict[str, Any]):
        """Publish the left and right hand states
        
        Args:
            left_hand_data: the data of the left hand
            right_hand_data: the data of the right hand
        """
        try:
            combined_data = {
                "left_hand": left_hand_data,
                "right_hand": right_hand_data
            }
            
            # write to the input shared memory for publishing
            if self.input_shm:
                self.input_shm.write_data(combined_data)
                
        except Exception as e:
            print(f"dex3_dds [{self.node_name}] Error publishing hand states: {e}")
    
    def write_hand_states(self, left_positions, left_velocities, left_torques, 
                         right_positions, right_velocities, right_torques):
        """Write the hand states to the shared memory directly
        
        Args:
            left_positions: the list or torch.Tensor of the left hand joint positions
            left_velocities: the list or torch.Tensor of the left hand joint velocities
            left_torques: the list or torch.Tensor of the left hand joint torques
            right_positions: the list or torch.Tensor of the right hand joint positions
            right_velocities: the list or torch.Tensor of the right hand joint velocities
            right_torques: the list or torch.Tensor of the right hand joint torques
        """
        try:
            # prepare the left hand data
            left_hand_data = {
                "positions": left_positions.tolist() if hasattr(left_positions, 'tolist') else left_positions,
                "velocities": left_velocities.tolist() if hasattr(left_velocities, 'tolist') else left_velocities,
                "torques": left_torques.tolist() if hasattr(left_torques, 'tolist') else left_torques
            }
            
            # prepare the right hand data
            right_hand_data = {
                "positions": right_positions.tolist() if hasattr(right_positions, 'tolist') else right_positions,
                "velocities": right_velocities.tolist() if hasattr(right_velocities, 'tolist') else right_velocities,
                "torques": right_torques.tolist() if hasattr(right_torques, 'tolist') else right_torques
            }
            
            # publish the states
            self.publish_hand_states(left_hand_data, right_hand_data)
            
        except Exception as e:
            print(f"dex3_dds [{self.node_name}] Error writing hand states: {e}")
    
    def write_single_hand_state(self, hand_side: str, positions, velocities, torques):
        """Write the single hand state
        
        Args:
            hand_side: the side of the hand ("left" or "right")
            positions: the list or torch.Tensor of the hand joint positions
            velocities: the list or torch.Tensor of the hand joint velocities
            torques: the list or torch.Tensor of the hand joint torques
        """
        try:
            hand_data = {
                "positions": positions.tolist() if hasattr(positions, 'tolist') else positions,
                "velocities": velocities.tolist() if hasattr(velocities, 'tolist') else velocities,
                "torques": torques.tolist() if hasattr(torques, 'tolist') else torques
            }
            
            # decide how to publish based on the hand side
            if hand_side == "left":
                # get the existing right hand data or use the default value
                existing_data = self.input_shm.read_data() if self.input_shm else {}
                right_data = existing_data.get("right_hand", {"positions": [0], "velocities": [0], "torques": [0]})
                self.publish_hand_states(hand_data, right_data)
            elif hand_side == "right":
                # get the existing left hand data or use the default value
                existing_data = self.input_shm.read_data() if self.input_shm else {}
                left_data = existing_data.get("left_hand", {"positions": [0], "velocities": [0], "torques": [0]})
                self.publish_hand_states(left_data, hand_data)
            else:
                print(f"dex3_dds [{self.node_name}] Invalid hand side: {hand_side}")
                
        except Exception as e:
            print(f"dex3_dds [{self.node_name}] Error writing {hand_side} hand state: {e}")
    


===== dds/g1_robot_dds.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
G1 robot DDS communication class
Handle the state publishing and command receiving of the G1 robot
"""

import numpy as np
from typing import Any, Dict, Optional
# from dds.dds_base import BaseDDSNode, node_manager
from dds.dds_base import DDSObject
from unitree_sdk2py.core.channel import ChannelPublisher, ChannelSubscriber
from unitree_sdk2py.idl.unitree_hg.msg.dds_ import LowState_, LowCmd_
from unitree_sdk2py.idl.default import unitree_hg_msg_dds__LowCmd_, unitree_hg_msg_dds__LowState_
from unitree_sdk2py.utils.crc import CRC


class G1RobotDDS(DDSObject):
    """G1 robot DDS communication class - singleton pattern
    
    Features:
    - Publish the state of the G1 robot to DDS (rt/lowstate)
    - Receive the control command of the G1 robot (rt/lowcmd)
    """
    
    def __init__(self,node_name:str="g1_robot"):
        """Initialize the G1 robot DDS node"""
        # avoid duplicate initialization
        if hasattr(self, '_initialized'):
            return
            
        super().__init__()
        self.node_name = node_name
        self.crc = CRC()
        self.low_state = unitree_hg_msg_dds__LowState_()
        self._initialized = True
        
        # setup the shared memory
        self.setup_shared_memory(
            input_shm_name="isaac_robot_state",  # read the state of the G1 robot from Isaac Lab
            output_shm_name="dds_robot_cmd",  # output the command to Isaac Lab
            input_size=3072,
            output_size=3072  # output the command to Isaac Lab
        )
        
        print(f"[{self.node_name}] G1 robot DDS node initialized")
    
    def setup_publisher(self) -> bool:
        """Setup the publisher of the G1 robot"""
        try:
            self.publisher = ChannelPublisher("rt/lowstate", LowState_)
            self.publisher.Init()
            print(f"[{self.node_name}] State publisher initialized (rt/lowstate)")
            return True
        except Exception as e:
            print(f"g1_robot_dds [{self.node_name}] State publisher initialization failed: {e}")    
            return False
    
    def setup_subscriber(self) -> bool:
        """Setup the subscriber of the G1 robot"""
        try:
            print(f"[{self.node_name}] Create ChannelSubscriber...")
            self.subscriber = ChannelSubscriber("rt/lowcmd", LowCmd_)
            self.subscriber.Init(lambda msg: self.dds_subscriber(msg, ""), 32)
            return True
        except Exception as e:
            print(f"g1_robot_dds [{self.node_name}] Command subscriber initialization failed: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def dds_publisher(self) -> Any:
        """Convert Isaac Lab state to DDS message and publish."""
        try:
            data = self.input_shm.read_data()
            if data is None:
                return

            motor_state = self.low_state.motor_state
            imu_state = self.low_state.imu_state
            num_motors =len(motor_state)

            positions = data.get("joint_positions")
            velocities = data.get("joint_velocities")
            torques = data.get("joint_torques")

            if positions and velocities and torques:
                q_array = np.asarray(positions, dtype=np.float32)
                dq_array = np.asarray(velocities, dtype=np.float32)
                tau_array = np.asarray(torques, dtype=np.float32)
                for i in range(len(q_array)):
                    motor = motor_state[i]
                    motor.q = q_array[i]
                    motor.dq = dq_array[i]
                    motor.tau_est = tau_array[i]

            imu = data.get("imu_data")
            if imu and len(imu) >= 13:
                imu_array = np.asarray(imu, dtype=np.float32)

                imu_state.quaternion[:] = imu_array[[4, 5, 6, 3]]

                imu_state.accelerometer[:] = imu_array[7:10]

                imu_state.gyroscope[:] = imu_array[10:13]

            self.low_state.tick += 1
            self.low_state.crc = self.crc.Crc(self.low_state)

            self.publisher.Write(self.low_state)

        except Exception as e:
            print(f"g1_robot_dds [{self.node_name}] Error processing publish data: {e}")

    
    def dds_subscriber(self, msg: LowCmd_,datatype:str=None) -> Dict[str, Any]:
        """Process the subscribe data: convert the DDS command to the Isaac Lab format
        
        Return data format:
        {
            "mode_pr": int,
            "mode_machine": int,
            "motor_cmd": {
                "positions": [29 joint position commands],
                "velocities": [29 joint velocity commands],
                "torques": [29 joint torque commands],
                "kp": [29 position gains],
                "kd": [29 speed gains]
            }
        }
        """
        try:
            # verify the CRC
            if self.crc.Crc(msg) != msg.crc:
                print(f"g1_robot_dds [{self.node_name}] Warning: CRC verification failed!")
                return {}
            
            # extract the command data
            num_cmd_motors = len(msg.motor_cmd)
            cmd_data = {
                "mode_pr": int(msg.mode_pr),
                "mode_machine": int(msg.mode_machine),
                "motor_cmd": {
                    "positions": [float(msg.motor_cmd[i].q) for i in range(num_cmd_motors)],
                    "velocities": [float(msg.motor_cmd[i].dq) for i in range(num_cmd_motors)],
                    "torques": [float(msg.motor_cmd[i].tau) for i in range(num_cmd_motors)],
                    "kp": [float(msg.motor_cmd[i].kp) for i in range(num_cmd_motors)],
                    "kd": [float(msg.motor_cmd[i].kd) for i in range(num_cmd_motors)]
                }
            }
            self.output_shm.write_data(cmd_data)
            
        except Exception as e:
            print(f"g1_robot_dds [{self.node_name}] Error processing subscribe data: {e}")
            return {}
    
    def get_robot_command(self) -> Optional[Dict[str, Any]]:
        """Get the robot control command
        
        Returns:
            Dict: the robot control command, return None if there is no new command
        """
        if self.output_shm:
            return self.output_shm.read_data()
        return None
    
    def write_robot_state(self, joint_positions, joint_velocities, joint_torques, imu_data):
        """Write the robot state to the shared memory
        
        Args:
            joint_positions: the joint position list or torch.Tensor
            joint_velocities: the joint velocity list or torch.Tensor
            joint_torques: the joint torque list or torch.Tensor
            imu_data: the IMU data list or torch.Tensor
        """
        if self.input_shm is None:
            return
        try:
            state_data = {
                "joint_positions": joint_positions.tolist() if hasattr(joint_positions, 'tolist') else joint_positions,
                "joint_velocities": joint_velocities.tolist() if hasattr(joint_velocities, 'tolist') else joint_velocities,
                "joint_torques": joint_torques.tolist() if hasattr(joint_torques, 'tolist') else joint_torques,
                "imu_data": imu_data.tolist() if hasattr(imu_data, 'tolist') else imu_data
            }
            self.input_shm.write_data(state_data)
        except Exception as e:
            print(f"g1_robot_dds [{self.node_name}] Error writing robot state: {e}")

===== dds/gripper_dds.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
Gripper DDS communication class
Handle the state publishing and command receiving of the gripper
"""

import threading
from typing import Any, Dict, Optional
from dds.dds_base import DDSObject
from unitree_sdk2py.core.channel import ChannelPublisher, ChannelSubscriber
from unitree_sdk2py.idl.unitree_go.msg.dds_ import MotorCmds_, MotorStates_
from unitree_sdk2py.idl.default import unitree_go_msg_dds__MotorCmd_, unitree_go_msg_dds__MotorState_
from tools.data_convert import convert_to_joint_range, convert_to_gripper_range

class GripperDDS(DDSObject):
    """Gripper DDS communication class - singleton pattern
    
    Features:
    - Publish the state of the gripper to DDS (rt/unitree_actuator/state)
    - Receive the control command of the gripper (rt/unitree_actuator/cmd)
    """
    
    def __init__(self,node_name:str="gripper"):
        """Initialize the gripper DDS node"""
        # avoid duplicate initialization
        if hasattr(self, '_initialized'):
            return
            
        super().__init__()
        self.node_name = node_name
        
        # initialize the gripper state message (2 grippers)
        self.left_gripper_state = MotorStates_()
        self.right_gripper_state = MotorStates_()
        for i in range(1):
            motor_state = unitree_go_msg_dds__MotorState_()
            self.left_gripper_state.states.append(motor_state)
            self.right_gripper_state.states.append(motor_state)
        self._initialized = True
        self.existing_data = {"left_gripper_cmd": {}, "right_gripper_cmd": {}}
        # setup the shared memory
        self.setup_shared_memory(
            input_shm_name="isaac_gripper_state",  # read the state of the gripper from Isaac Lab
            input_size=512,
            output_shm_name="isaac_gripper_cmd",  # output the command to Isaac Lab
            output_size=512,  # output the command to Isaac Lab
        )
        
        print(f"[{self.node_name}] Gripper DDS node initialized")
    
    def setup_publisher(self) -> bool:
        """Setup the publisher of the gripper"""
        try:
            self.left_gripper_state_publisher = ChannelPublisher("rt/dex1/left/state", MotorStates_)
            self.left_gripper_state_publisher.Init()
            self.right_gripper_state_publisher = ChannelPublisher("rt/dex1/right/state", MotorStates_)
            self.right_gripper_state_publisher.Init()
            self.publisher=True
            print(f"[{self.node_name}] Gripper state publisher initialized")
            return True
        except Exception as e:
            print(f"gripper_dds [{self.node_name}] Gripper state publisher initialization failed: {e}")
            return False
    
    def setup_subscriber(self) -> bool:
        """Setup the subscriber of the gripper"""
        try:
            self.left_gripper_cmd_subscriber = ChannelSubscriber("rt/dex1/left/cmd", MotorCmds_)
            self.left_gripper_cmd_subscriber.Init(lambda msg: self.dds_subscriber(msg, "left"), 1)
            self.right_gripper_cmd_subscriber = ChannelSubscriber("rt/dex1/right/cmd", MotorCmds_)
            self.right_gripper_cmd_subscriber.Init(lambda msg: self.dds_subscriber(msg, "right"), 1)
            self.subscriber = True
            print(f"[{self.node_name}] Gripper command subscriber initialized")
            return True
        except Exception as e:
            print(f"gripper_dds [{self.node_name}] Gripper command subscriber initialization failed: {e}")
            return False
        
    def dds_subscriber(self, msg: Any, hand_side: str):
        """Subscribe message handler"""
        try:
            # process received message
            data = self._process_subscribe_data(msg, hand_side)
            if data and self.output_shm:
                # write to shared memory
                
                self.existing_data[f"{hand_side}_gripper_cmd"] = data
                self.output_shm.write_data(self.existing_data)
        except Exception as e:
            print(f"gripper_dds [{self.node_name}] Error processing subscribe message: {e}")
    def dds_publisher(self) -> Any:
        """Process the publish data: convert the Isaac Lab state to the DDS message
        
        Expected data format:
        {
            "positions": [2 gripper joint positions] (Isaac Lab joint angle range [-0.02, 0.03])
            "velocities": [2 gripper joint velocities],
            "torques": [2 gripper joint torques]
        }
        """
        try:
            data = self.input_shm.read_data() or {}
            # process the left hand data
            if "left_hand" in data:
                left_data = data["left_hand"]
                self._update_gripper_state(self.left_gripper_state, left_data)
                if self.left_gripper_state_publisher:
                    self.left_gripper_state_publisher.Write(self.left_gripper_state)
            
            # process the right hand data
            if "right_hand" in data:
                right_data = data["right_hand"]
                self._update_gripper_state(self.right_gripper_state, right_data)
                if self.right_gripper_state_publisher:
                    self.right_gripper_state_publisher.Write(self.right_gripper_state)

            return None
        except Exception as e:
            print(f"gripper_dds [{self.node_name}] Error processing publish data: {e}")    
            return None
    def _update_gripper_state(self, gripper_state, gripper_data: Dict[str, Any]):
        """Update the gripper state"""
        try:
            if all(key in gripper_data for key in ["positions", "velocities", "torques"]):
                positions = gripper_data["positions"]
                velocities = gripper_data["velocities"]
                torques = gripper_data["torques"]
                for i in range(min(1, len(positions))):  # at most 2 grippers
                    if i < len(positions):
                        gripper_state.states[i].q = convert_to_gripper_range(float(positions[i]))
                    if i < len(velocities):
                        gripper_state.states[i].dq = float(velocities[i])
                    if i < len(torques):
                        gripper_state.states[i].tau_est = float(torques[i])
        except Exception as e:
            print(f"gripper_dds [{self.node_name}] Error updating gripper state: {e}")
    def _process_subscribe_data(self, msg: Any, hand_side: str) -> Dict[str, Any]:
        """Process the subscribe data: convert the DDS command to the Isaac Lab format
        
        Returns:
            Dict: the gripper command, format as follows:
            {
                "positions": [2 gripper joint position target values] (Isaac Lab joint angle)
                "velocities": [2 gripper joint velocity target values],
                "torques": [2 gripper joint torque target values],
                "kp": [2 gripper position gains],
                "kd": [2 gripper speed gains]
            }
        """
        try:
            cmd_data = {
                "positions": [],
                "velocities": [],
                "torques": [],
                "kp": [],
                "kd": []
            }
            # process the gripper command (at most 2 grippers)
            for i in range(min(1, len(msg.cmds))):
                # convert the gripper control value to the Isaac Lab joint angle
                joint_angle = convert_to_joint_range(float(msg.cmds[i].q))
                
                cmd_data["positions"].append(joint_angle)
                cmd_data["velocities"].append(float(msg.cmds[i].dq))
                cmd_data["torques"].append(float(msg.cmds[i].tau))
                cmd_data["kp"].append(float(msg.cmds[i].kp))
                cmd_data["kd"].append(float(msg.cmds[i].kd))
            
            return cmd_data
            
        except Exception as e:
            print(f"gripper_dds [{self.node_name}] Error processing {hand_side} subscribe data: {e}")
            return {}
    
    def get_gripper_command(self) -> Optional[Dict[str, Any]]:
        """Get the gripper control command
        
        Returns:
            Dict: the gripper command, return None if there is no new command
        """
        if self.output_shm:
            return self.output_shm.read_data()
        return None
    
    def write_gripper_state(self, left_positions, left_velocities, left_torques, 
                        right_positions, right_velocities, right_torques):
        """Write the hand states to the shared memory directly
        
        Args:
            left_positions: the list or torch.Tensor of the left hand joint positions
            left_velocities: the list or torch.Tensor of the left hand joint velocities
            left_torques: the list or torch.Tensor of the left hand joint torques
            right_positions: the list or torch.Tensor of the right hand joint positions
            right_velocities: the list or torch.Tensor of the right hand joint velocities
            right_torques: the list or torch.Tensor of the right hand joint torques
        """
        try:
            # prepare the left hand data
            left_hand_data = {
                "positions": left_positions.tolist() if hasattr(left_positions, 'tolist') else left_positions,
                "velocities": left_velocities.tolist() if hasattr(left_velocities, 'tolist') else left_velocities,
                "torques": left_torques.tolist() if hasattr(left_torques, 'tolist') else left_torques
            }
            
            # prepare the right hand data
            right_hand_data = {
                "positions": right_positions.tolist() if hasattr(right_positions, 'tolist') else right_positions,
                "velocities": right_velocities.tolist() if hasattr(right_velocities, 'tolist') else right_velocities,
                "torques": right_torques.tolist() if hasattr(right_torques, 'tolist') else right_torques
            }
            
            # publish the states
            self.publish_hand_states(left_hand_data, right_hand_data)
            
        except Exception as e:
            print(f"dex3_dds [{self.node_name}] Error writing hand states: {e}")
    def publish_hand_states(self, left_hand_data: Dict[str, Any], right_hand_data: Dict[str, Any]):
        """Publish the left and right hand states
        
        Args:
            left_hand_data: the data of the left hand
            right_hand_data: the data of the right hand
        """
        try:
            combined_data = {
                "left_hand": left_hand_data,
                "right_hand": right_hand_data
            }
            
            # write to the input shared memory for publishing
            if self.input_shm:
                self.input_shm.write_data(combined_data)
                
        except Exception as e:
            print(f"dex3_dds [{self.node_name}] Error publishing hand states: {e}")



===== dds/inspire_dds.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
Gripper DDS communication class
Handle the state publishing and command receiving of the gripper
"""

import threading
from typing import Any, Dict, Optional
from dds.dds_base import DDSObject
from unitree_sdk2py.core.channel import ChannelPublisher, ChannelSubscriber
from unitree_sdk2py.idl.unitree_go.msg.dds_ import MotorCmds_, MotorStates_
from unitree_sdk2py.idl.default import unitree_go_msg_dds__MotorCmd_, unitree_go_msg_dds__MotorState_
import numpy as np

class InspireDDS(DDSObject):
    """Gripper DDS communication class - singleton pattern
    
    Features:
    - Publish the state of the gripper to DDS (rt/unitree_actuator/state)
    - Receive the control command of the gripper (rt/unitree_actuator/cmd)
    """
    
    def __init__(self,node_name:str="inspire"):
        """Initialize the gripper DDS node"""
        # avoid duplicate initialization
        if hasattr(self, '_initialized'):
            return
            
        super().__init__()
        self.node_name = node_name
        
        # initialize the gripper state message (2 grippers)
        self.inspire_hand_state = MotorStates_()
        # initialize 2 motor states
        self.inspire_hand_state.states = []
        for _ in range(12):
            motor_state = unitree_go_msg_dds__MotorState_()
            self.inspire_hand_state.states.append(motor_state)
        
        self._initialized = True
        
        # setup the shared memory
        self.setup_shared_memory(
            input_shm_name="isaac_inspire_state",  # read the state of the gripper from Isaac Lab
            input_size=1024,
            output_shm_name="isaac_inspire_cmd",  # output the command to Isaac Lab
            output_size=1024,  # output the command to Isaac Lab
        )
        
        print(f"[{self.node_name}] Inspire Hand DDS node initialized")
    
    def setup_publisher(self) -> bool:
        """Setup the publisher of the gripper"""
        try:
            self.publisher = ChannelPublisher("rt/inspire/state", MotorStates_)
            self.publisher.Init()
            
            print(f"[{self.node_name}] Inspire Hand state publisher initialized")
            return True
        except Exception as e:
            print(f"gripper_dds [{self.node_name}] Gripper state publisher initialization failed: {e}")
            return False
    
    def setup_subscriber(self) -> bool:
        """Setup the subscriber of the gripper"""
        try:
            self.subscriber = ChannelSubscriber("rt/inspire/cmd", MotorCmds_)
            self.subscriber.Init(lambda msg: self.dds_subscriber(msg, ""), 32)
            
            print(f"[{self.node_name}] Inspire Hand command subscriber initialized")
            return True
        except Exception as e:
            print(f"gripper_dds [{self.node_name}] Gripper command subscriber initialization failed: {e}")
            return False
    def normalize(self,val, min_val, max_val):
        return np.clip((max_val - val) / (max_val - min_val), 0.0, 1.0)
    def dds_publisher(self) -> Any:
        """Process the publish data: convert the Isaac Lab state to the DDS message
        
        Expected data format:
        {
            "positions": [2 gripper joint positions] (Isaac Lab joint angle range [-0.02, 0.03])
            "velocities": [2 gripper joint velocities],
            "torques": [2 gripper joint torques]
        }
        """
        try:
            data = self.input_shm.read_data() 
            if data is None:
                return
            if all(key in data for key in ["positions", "velocities", "torques"]):
                positions = data["positions"]
                velocities = data["velocities"]
                torques = data["torques"]
                for i in range(min(12, len(positions))):
                    if i < len(self.inspire_hand_state.states):
                        # convert the Isaac Lab joint angle to the gripper control value    
                        if i in [0,1,2,3,6,7,8,9]:
                            inspire_q_value = self.normalize(float(positions[i]),0.0,1.7)
                        elif i in [4,10]:
                            inspire_q_value = self.normalize(float(positions[i]),0.0,0.5)
                        elif i in [5,11]:
                            inspire_q_value = self.normalize(float(positions[i]),-0.1,1.3)
                        self.inspire_hand_state.states[i].q = inspire_q_value
                        if i < len(velocities):
                            self.inspire_hand_state.states[i].dq = float(velocities[i])
                        if i < len(torques):
                            self.inspire_hand_state.states[i].tau_est = float(torques[i])
            
                self.publisher.Write(self.inspire_hand_state)
            
        except Exception as e:
            print(f"inspire_dds [{self.node_name}] Error processing publish data: {e}")    
            return None
    def denormalize(self,norm_val, min_val, max_val):
        return (1.0 - np.clip(norm_val, 0.0, 1.0)) * (max_val - min_val) + min_val
    def dds_subscriber(self, msg: MotorCmds_,datatype:str=None) -> Dict[str, Any]:
        """Process the subscribe data: convert the DDS command to the Isaac Lab format
        
        Returns:
            Dict: the gripper command, format as follows:
            {
                "positions": [2 gripper joint position target values] (Isaac Lab joint angle)
                "velocities": [2 gripper joint velocity target values],
                "torques": [2 gripper joint torque target values],
                "kp": [2 gripper position gains],
                "kd": [2 gripper speed gains]
            }
        """
        try:
            cmd_data = {
                "positions": [],
                "velocities": [],
                "torques": [],
                "kp": [],
                "kd": []
            }
            # process the gripper command (at most 2 grippers)
            for i in range(min(12, len(msg.cmds))):
                # convert the gripper control value to the Isaac Lab joint angle
                if i in [0,1,2,3,6,7,8,9]:
                    joint_angle = self.denormalize(float(msg.cmds[i].q),0.0,1.7)
                elif i in [4,10]:
                    joint_angle = self.denormalize(float(msg.cmds[i].q),0.0,0.5)
                elif i in [5,11]:
                    joint_angle = self.denormalize(float(msg.cmds[i].q),-0.1,1.3)
                cmd_data["positions"].append(joint_angle)
                cmd_data["velocities"].append(float(msg.cmds[i].dq))
                cmd_data["torques"].append(float(msg.cmds[i].tau))
                cmd_data["kp"].append(float(msg.cmds[i].kp))
                cmd_data["kd"].append(float(msg.cmds[i].kd))
            self.output_shm.write_data(cmd_data)
            
        except Exception as e:
            print(f"inspire_dds [{self.node_name}] Error processing subscribe data: {e}")
            return None
    
    def get_inspire_hand_command(self) -> Optional[Dict[str, Any]]:
        """Get the gripper control command
        
        Returns:
            Dict: the gripper command, return None if there is no new command
        """
        if self.output_shm:
            return self.output_shm.read_data()
        return None
    
    def write_inspire_state(self, positions, velocities, torques):
        """Write the gripper state to the shared memory
        
        Args:
            positions: the gripper joint position list or torch.Tensor (Isaac Lab joint angle)
            velocities: the gripper joint velocity list or torch.Tensor  
            torques: the gripper joint torque list or torch.Tensor
        """
        try:
            # prepare the gripper data
            inspire_hand_data = {
                "positions": positions.tolist() if hasattr(positions, 'tolist') else positions,
                "velocities": velocities.tolist() if hasattr(velocities, 'tolist') else velocities,
                "torques": torques.tolist() if hasattr(torques, 'tolist') else torques
            }
            
            # write the input shared memory for publishing
            if self.input_shm:
                self.input_shm.write_data(inspire_hand_data)
                
        except Exception as e:
            print(f"gripper_dds [{self.node_name}] Error writing inspire hand state: {e}")

===== dds/reset_pose_dds.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
Reset pose DDS communication class
Specialized in receiving the reset pose command
"""

import threading
from typing import Any, Dict, Optional
from dds.dds_base import DDSObject
from unitree_sdk2py.core.channel import ChannelSubscriber
from unitree_sdk2py.idl.std_msgs.msg.dds_ import String_


class ResetPoseCmdDDS(DDSObject):
    """Reset pose command DDS node (singleton pattern)"""
    
    
    def __init__(self,node_name:str="reset_pose_dds"):
        """Initialize the reset pose DDS node"""
        # avoid duplicate initialization
        if hasattr(self, '_initialized'):
            return
        super().__init__()
        
        self._initialized = True
        self.node_name = node_name
        # setup the shared memory
        self.setup_shared_memory(
            output_shm_name="isaac_reset_pose_cmd", 
            output_size=512, 
            outputshm_flag=True,
            inputshm_flag=False,
        )
        print(f"[{self.node_name}] Reset pose DDS node initialized")

    
    def setup_publisher(self) -> bool:
        """Setup the reset pose command publisher (this node is mainly used for subscribe, the publisher is optional)"""
        pass
    
    def setup_subscriber(self) -> bool:
        """Setup the reset pose command subscriber"""
        try:
            self.subscriber = ChannelSubscriber("rt/reset_pose/cmd", String_)
            self.subscriber.Init(lambda msg: self.dds_subscriber(msg, ""), 1)
            
            print(f"[{self.node_name}] Reset pose command subscriber initialized")
            return True
        except Exception as e:
            print(f"reset_pose_dds [{self.node_name}] Failed to initialize the reset pose command subscriber: {e}")
            return False
    
    
    def dds_publisher(self) -> Any:
        """Process the publish data (this node is mainly used for subscribe, the publish function is optional)"""
        pass
    
    def dds_subscriber(self, msg: String_,datatype:str=None) -> Dict[str, Any]:
        """Process the subscribe data"""
        try:
            cmd_data = {
                "reset_category": msg.data
            }
            self.output_shm.write_data(cmd_data)
        except Exception as e:
            print(f"reset_pose_dds [{self.node_name}] Failed to process the subscribe data: {e}")
            return {}
    
    def get_reset_pose_command(self) -> Optional[Dict[str, Any]]:
        """Get the reset pose command
        
        Returns:
            Dict: the reset pose command, if no command return None
        """
        if self.output_shm:
            return self.output_shm.read_data()
        return None
    
    def write_reset_pose_command(self, flag_category):
        """Write the reset pose command to the shared memory
        
        Args:
            positions: the reset pose command, if no command return None
        """
        try:
            # prepare the reset pose data
            cmd_data = {
                "reset_category":flag_category
            }
            
            # write the reset pose data to the shared memory
            if self.output_shm:
                self.output_shm.write_data(cmd_data)
                
        except Exception as e:
            print(f"reset_pose_dds [{self.node_name}] Failed to write the reset pose command: {e}")

===== dds/rewards_dds.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
Sim state DDS communication class
Specialized in publishing and receiving sim state data
"""

import threading
import time
import torch
from typing import Any, Dict, Optional
from dds.dds_base import DDSObject
from unitree_sdk2py.core.channel import ChannelPublisher, ChannelSubscriber
from unitree_sdk2py.idl.std_msgs.msg.dds_ import String_
from unitree_sdk2py.idl.default import std_msgs_msg_dds__String_

import json

class RewardsDDS(DDSObject):
    """Sim state DDS node (singleton pattern)"""
    
    def __init__(self, env, task_name,node_name:str="rewards_dds"):
        """Initialize the sim state DDS node"""
        # avoid duplicate initialization
        if hasattr(self, '_initialized') and self._initialized:
            return
        super().__init__()
        self.node_name = node_name
        self.env = env
        self.task_name = task_name
        self._initialized = True
        self.rewards = std_msgs_msg_dds__String_()
        self.last_published_timestamp = None  # è®°å½•æœ€åå‘å¸ƒçš„æ—¶é—´æˆ³

        # setup the shared memory
        self.setup_shared_memory(
            input_shm_name="isaac_rewards",  # read rewards data for publishing
            input_size=256,
            outputshm_flag=False
        )

        print(f"[{self.node_name}] Rewards DDS node initialized")

    
    def setup_publisher(self) -> bool:
        """Setup the publisher of the rewards"""
        try:
            self.publisher = ChannelPublisher("rt/rewards_state", String_)
            self.publisher.Init()
            
            print(f"[{self.node_name}] Rewards publisher initialized")
            return True
        except Exception as e:
            print(f"rewards_dds [{self.node_name}] Rewards publisher initialization failed: {e}")
            return False
    
    def setup_subscriber(self) -> bool:
        """Setup the subscriber of the rewards"""
        try:
            self.subscriber = ChannelSubscriber("rt/rewards_state_cmd", String_)
            self.subscriber.Init(lambda msg: self.dds_subscriber(msg, ""), 1)
            
            print(f"[{self.node_name}] Rewards subscriber initialized")
            return True
        except Exception as e:
            print(f"rewards_dds [{self.node_name}] Rewards subscriber initialization failed: {e}")
            return False
    
    
    def dds_publisher(self) -> Any:
        """Process the publish data"""
        try:
            data = self.input_shm.read_data()
            
            if data is None:
                return
            
            # æ£€æŸ¥æ—¶é—´æˆ³ï¼Œé¿å…é‡å¤å‘å¸ƒ
            current_timestamp = data.get("timestamp", None)
            if current_timestamp is not None:
                if self.last_published_timestamp == current_timestamp:
                    # ç›¸åŒæ—¶é—´æˆ³çš„æ•°æ®å·²ç»å‘å¸ƒè¿‡ï¼Œè·³è¿‡
                    return
                # æ›´æ–°æœ€åå‘å¸ƒçš„æ—¶é—´æˆ³
                self.last_published_timestamp = current_timestamp
            
            # get rewards from environment
            rewards = json.dumps(data)
            self.rewards.data = rewards
            self.publisher.Write(self.rewards)
        except Exception as e:
            print(f"rewards_dds [{self.node_name}] Error processing publish data: {e}")
            return None
    
    def dds_subscriber(self, msg: String_,datatype:str=None) -> Dict[str, Any]:
        """Process the subscribe data"""
        try:
            # Parse received rewards command
            data = json.loads(msg.data)
            
            # Process the command (implement according to your needs)
            # For example, you might want to apply the received state to the environment
            return data
        except Exception as e:
            print(f"rewards_dds [{self.node_name}] Error processing subscribe data: {e}")
            return None

    def tensors_to_list(self, obj):
        if isinstance(obj, torch.Tensor):
            return obj.tolist()
        elif isinstance(obj, dict):
            return {k: self.tensors_to_list(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [self.tensors_to_list(i) for i in obj]
        return obj

    def rewards_to_json(self,data):
        data_serializable = self.tensors_to_list(data)
        json_str = json.dumps(data_serializable)
        return json_str

    def write_rewards_data(self, rewards_data=None):
        """Write rewards data to shared memory to trigger publishing
        
        Args:
            rewards_data: Optional rewards data. If None, will get current state from environment
        """
        try:
            if rewards_data is None:
                print(f"rewards_dds [{self.node_name}] Warning: rewards_data is None")
                return
            
            # Convert tensor to appropriate format and wrap in dictionary
            if isinstance(rewards_data, torch.Tensor):
                rewards_list = rewards_data.cpu().numpy().tolist()
                rewards_dict = {
                    "rewards": rewards_list,
                    "timestamp": time.time()
                }
            else:
                # If it's already a scalar or list, wrap it in a dictionary
                rewards_dict = {
                    "rewards": rewards_data if isinstance(rewards_data, list) else [rewards_data],
                    "timestamp": time.time()
                }
            self.input_shm.write_data(rewards_dict)
                
        except Exception as e:
            print(f"rewards_dds [{self.node_name}] Error writing rewards data: {e}")

    def get_rewards_command(self) -> Optional[Dict[str, Any]]:
        """Get the rewards control command
        
        Returns:
            Dict: the rewards command, return None if there is no new command
        """
        if self.output_shm:
            return self.output_shm.read_data()
        return None

===== dds/sharedmemorymanager.py =====

import json
import time
import threading
from typing import Dict, Any, Optional
from multiprocessing import shared_memory


class SharedMemoryManager:
    """Shared memory manager"""
    
    def __init__(self, name: str = None, size: int = 512):
        """Initialize shared memory manager
        
        Args:
            name: shared memory name, if None, create new one
            size: shared memory size (bytes)
        """
        self.size = size
        self.lock = threading.RLock()  # reentrant lock
        
        if name:
            try:
                self.shm = shared_memory.SharedMemory(name=name)
                self.shm_name = name
                self.created = False
            except FileNotFoundError:
                self.shm = shared_memory.SharedMemory(create=True, size=size)
                self.shm_name = self.shm.name
                self.created = True
        else:
            self.shm = shared_memory.SharedMemory(create=True, size=size)
            self.shm_name = self.shm.name
            self.created = True
    
    def write_data(self, data: Dict[str, Any]) -> bool:
        """Write data to shared memory
        
        Args:
            data: data to write
            
        Returns:
            bool: write success or not
        """
        try:
            with self.lock:
                json_str = json.dumps(data)
                json_bytes = json_str.encode('utf-8')
                
                if len(json_bytes) > self.size - 8:  # reserve 8 bytes for length and timestamp
                    print(f"Warning: Data too large for shared memory ({len(json_bytes)} > {self.size - 8})")
                    return False
                
                # write timestamp (4 bytes) and data length (4 bytes)
                timestamp = int(time.time()) & 0xFFFFFFFF  # 32-bit timestamp, use bitmask to ensure in range
                self.shm.buf[0:4] = timestamp.to_bytes(4, 'little')
                self.shm.buf[4:8] = len(json_bytes).to_bytes(4, 'little')
                
                # write data
                self.shm.buf[8:8+len(json_bytes)] = json_bytes
                return True
                
        except Exception as e:
            print(f"Error writing to shared memory: {e}")
            return False
    
    def read_data(self) -> Optional[Dict[str, Any]]:
        """Read data from shared memory
        
        Returns:
            Dict[str, Any]: read data dictionary, return None if failed
        """
        try:
            with self.lock:
                # read timestamp and data length
                timestamp = int.from_bytes(self.shm.buf[0:4], 'little')
                data_len = int.from_bytes(self.shm.buf[4:8], 'little')
                
                if data_len == 0:
                    return None
                
                # read data
                json_bytes = bytes(self.shm.buf[8:8+data_len])
                data = json.loads(json_bytes.decode('utf-8'))
                data['_timestamp'] = timestamp  # add timestamp information
                return data
                
        except Exception as e:
            print(f"Error reading from shared memory: {e}")
            return None
    
    def get_name(self) -> str:
        """Get shared memory name"""
        return self.shm_name
    
    def cleanup(self):
        """Clean up shared memory"""
        if hasattr(self, 'shm') and self.shm:
            self.shm.close()
            if self.created:
                try:
                    self.shm.unlink()
                except:
                    pass
    
    def __del__(self):
        """Destructor"""
        self.cleanup()


===== dds/sim_state_dds.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
Sim state DDS communication class
Specialized in publishing and receiving sim state data
"""

import threading
import torch
from typing import Any, Dict, Optional
from dds.dds_base import DDSObject
from unitree_sdk2py.core.channel import ChannelPublisher, ChannelSubscriber
from unitree_sdk2py.idl.std_msgs.msg.dds_ import String_
from unitree_sdk2py.idl.default import std_msgs_msg_dds__String_

import json

class SimStateDDS(DDSObject):
    """Sim state DDS node (singleton pattern)"""
    
    def __init__(self, env, task_name,node_name:str="sim_state_dds"):
        """Initialize the sim state DDS node"""
        # avoid duplicate initialization
        if hasattr(self, '_initialized') and self._initialized:
            return
        super().__init__()
        self.node_name = node_name
        self.env = env
        self.task_name = task_name
        self._initialized = True
        self.sim_state = std_msgs_msg_dds__String_()

        # setup the shared memory
        self.setup_shared_memory(
            input_shm_name="isaac_sim_state",  # read sim state data for publishing
            input_size=4096,
            outputshm_flag=False
        )

        print(f"[{self.node_name}] Sim state DDS node initialized")

    
    def setup_publisher(self) -> bool:
        """Setup the publisher of the sim state"""
        try:
            self.publisher = ChannelPublisher("rt/sim_state", String_)
            self.publisher.Init()
            
            print(f"[{self.node_name}] Sim state publisher initialized")
            return True
        except Exception as e:
            print(f"sim_state_dds [{self.node_name}] Sim state publisher initialization failed: {e}")
            return False
    
    def setup_subscriber(self) -> bool:
        """Setup the subscriber of the sim state"""
        try:
            self.subscriber = ChannelSubscriber("rt/sim_state_cmd", String_)
            self.subscriber.Init(lambda msg: self.dds_subscriber(msg, ""), 1)
            
            print(f"[{self.node_name}] Sim state subscriber initialized")
            return True
        except Exception as e:
            print(f"sim_state_dds [{self.node_name}] Sim state subscriber initialization failed: {e}")
            return False
    
    
    def dds_publisher(self) -> Any:
        """Process the publish data"""
        try:
            data = self.input_shm.read_data()
            if data is None:
                return
            # get sim state from environment
            sim_state = json.dumps(data)
            self.sim_state.data = sim_state
            self.publisher.Write(self.sim_state)
        except Exception as e:
            print(f"sim_state_dds [{self.node_name}] Error processing publish data: {e}")
            return None
    
    def dds_subscriber(self, msg: String_,datatype:str=None) -> Dict[str, Any]:
        """Process the subscribe data"""
        try:
            # Parse received sim state command
            data = json.loads(msg.data)
            
            # Process the command (implement according to your needs)
            # For example, you might want to apply the received state to the environment
            return data
        except Exception as e:
            print(f"sim_state_dds [{self.node_name}] Error processing subscribe data: {e}")
            return None

    def tensors_to_list(self, obj):
        if isinstance(obj, torch.Tensor):
            return obj.tolist()
        elif isinstance(obj, dict):
            return {k: self.tensors_to_list(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [self.tensors_to_list(i) for i in obj]
        return obj

    def sim_state_to_json(self,data):
        data_serializable = self.tensors_to_list(data)
        json_str = json.dumps(data_serializable)
        return json_str

    def write_sim_state_data(self, sim_state_data=None):
        """Write sim state data to shared memory to trigger publishing
        
        Args:
            sim_state_data: Optional sim state data. If None, will get current state from environment
        """
        try:
            if sim_state_data is None:
                # Get current sim state from environment
                sim_state_data = {"trigger": "publish_sim_state"}
            
            # write to the input shared memory for publishing
            if self.input_shm:
                self.input_shm.write_data(sim_state_data)
                
        except Exception as e:
            print(f"sim_state_dds [{self.node_name}] Error writing sim state data: {e}")

    def get_sim_state_command(self) -> Optional[Dict[str, Any]]:
        """Get the sim state control command
        
        Returns:
            Dict: the sim state command, return None if there is no new command
        """
        if self.output_shm:
            return self.output_shm.read_data()
        return None

===== doc/isaacsim4.5_install.md =====

## Isaac Sim 4.5.0 Environment Installation
### 2.1 Installation on Ubuntu 22.04 and Later(pip install)

- **Create Virtual Environment**

```
conda create -n unitree_sim_env python=3.10
conda activate unitree_sim_env
```
- **Install Pytorch**

This needs to be installed according to your CUDA version. Please refer to the [official PyTorch installation guide](https://pytorch.org/get-started/locally/). The following example uses CUDA 12:

```
pip install torch==2.5.1 torchvision==0.20.1 --index-url https://download.pytorch.org/whl/cu121
```
- **Install Isaac Sim 4.5.0**

```
pip install --upgrade pip

pip install 'isaacsim[all,extscache]==4.5.0' --extra-index-url https://pypi.nvidia.com
```
Verify successful installation:
```
isaacsim
```
First execution will show: Do you accept the EULA? (Yes/No):  Yes

-  **Install Isaac Lab**

The current IsaacLab version used is 91ad4944f2b7fad29d52c04a5264a082bcaad71d

```
git clone git@github.com:isaac-sim/IsaacLab.git

sudo apt install cmake build-essential

cd IsaacLab

./isaaclab.sh --install 

```

Verify successful installation:
```
python scripts/tutorials/00_sim/create_empty.py
or
./isaaclab.sh -p scripts/tutorials/00_sim/create_empty.py
```

- **Install unitree_sdk2_python**

```
git clone https://github.com/unitreerobotics/unitree_sdk2_python

cd unitree_sdk2_python

pip3 install -e .
```

- **Install other dependencies**
```
pip install -r requirements.txt
```

### 2.2 Installation on Ubuntu 20.04(binary install)

- **Download Isaac Sim Binary**

Download the [Isaac Sim 4.5.0 binary](https://docs.isaacsim.omniverse.nvidia.com/4.5.0/installation/download.html) and extract it.

Assume the path to Isaac Sim is ``/home/unitree/tools/isaac-sim``. Follow the steps below:

- **Set environment variables**

Please replace with your own path

```
export ISAACSIM_PATH="${HOME}/tools/isaac-sim"            
export ISAACSIM_PYTHON_EXE="${ISAACSIM_PATH}/python.sh"  
```
Verify the setup:
```
${ISAACSIM_PATH}/isaac-sim.sh
# or
${ISAACSIM_PYTHON_EXE} -c "print('Isaac Sim configuration is now complete.')"

Note: All conda environments (including base) must be deactivated before running this.
```
**Note:** You can add the above commands to your ~/.bashrc file for convenience.

- **Install Isaac Lab**

Using IsaacLab commit `91ad4944f2b7fad29d52c04a5264a082bcaad71d`

```
git clone git@github.com:isaac-sim/IsaacLab.git

sudo apt install cmake build-essential

cd IsaacLab

ln -s ${HOME}/tools/isaac-sim/ _isaac_sim     (Please replace with your own path)

./isaaclab.sh --conda unitree_sim_env

conda activate unitree_sim_env

./isaaclab.sh --install

```

- **Install unitree_sdk2_python**

```
git clone https://github.com/unitreerobotics/unitree_sdk2_python

cd unitree_sdk2_python

pip3 install -e .

```

- **Install other dependencies**

```
pip install -r requirements.txt
```

===== doc/isaacsim4.5_install_zh.md =====

## Isaac Sim 4.5.0ç¯å¢ƒå®‰è£…
### 2.1 Ubuntu 22.04 ä»¥åŠä»¥ä¸Šçš„å®‰è£…

-  åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ

```
conda create -n unitree_sim_env python=3.10
conda activate unitree_sim_env
```
- å®‰è£…Pytorch

è¿™ä¸ªéœ€è¦æ ¹æ®è‡ªå·±çš„CUDAç‰ˆæœ¬è¿›è¡Œå®‰è£…ï¼Œå…·ä½“å‚è€ƒ[Pytorchå®˜æ–¹æ•™ç¨‹](https://pytorch.org/get-started/locally/),ä¸‹é¢ä»¥CUDA 12ä¸ºä¾‹è¿›è¡Œå®‰è£…

```
pip install torch==2.5.1 torchvision==0.20.1 --index-url https://download.pytorch.org/whl/cu121
```
-  å®‰è£… Isaac Sim 4.5.0

```
pip install --upgrade pip

pip install 'isaacsim[all,extscache]==4.5.0' --extra-index-url https://pypi.nvidia.com

```
éªŒè¯æ˜¯å¦å®‰è£…æˆåŠŸ
```
isaacsim
```
ç¬¬ä¸€æ¬¡æ‰§è¡Œä¼šæœ‰:Do you accept the EULA? (Yes/No):  Yes



- å®‰è£…Isaac Lab

ç›®å‰ä½¿ç”¨çš„IsaacLab çš„ç‰ˆæœ¬å·æ˜¯91ad4944f2b7fad29d52c04a5264a082bcaad71d

```
git clone git@github.com:isaac-sim/IsaacLab.git

sudo apt install cmake build-essential

cd IsaacLab

./isaaclab.sh --install 

```

éªŒè¯å®‰è£…æ˜¯å¦æˆåŠŸ
```
python scripts/tutorials/00_sim/create_empty.py
or
./isaaclab.sh -p scripts/tutorials/00_sim/create_empty.py
```

- å®‰è£…unitree_sdk2_python

```
git clone https://github.com/unitreerobotics/unitree_sdk2_python

cd unitree_sdk2_python

pip3 install -e .
```
- å®‰è£…å…¶ä»–ä¾èµ–
```
pip install -r requirements.txt
```

### 2.2 Ubuntu 20.4(äºŒè¿›åˆ¶)å®‰è£…

- ä¸‹è½½äºŒè¿›åˆ¶çš„Isaaac Sim

ä¸‹è½½å¯¹åº”ç‰ˆæœ¬çš„
[äºŒè¿›åˆ¶Isaac Sim 4.5.0](https://docs.isaacsim.omniverse.nvidia.com/4.5.0/installation/download.html)å¹¶è§£å‹ï¼›

å‡è®¾isaac simæ”¾åœ¨`/home/unitree/tools/isaac-sim`,è¯·æŒ‰ç…§ä¸‹é¢çš„æ­¥éª¤è¿›è¡Œå®‰è£…ï¼›

- è®¾åœ¨ç¯å¢ƒå˜é‡

```
export ISAACSIM_PATH="${HOME}/tools/isaac-sim"

export ISAACSIM_PYTHON_EXE="${ISAACSIM_PATH}/python.sh"

```
æµ‹è¯•è®¾ç½®æ˜¯å¦æˆåŠŸ

```
${ISAACSIM_PATH}/isaac-sim.sh

æˆ–

${ISAACSIM_PYTHON_EXE} -c "print('Isaac Sim configuration is now complete.')" 

éœ€è¦é€€å‡ºåŒ…æ‹¬baseåœ¨å†…çš„æ‰€æœ‰çš„condaç¯å¢ƒ

```

**æ³¨æ„ï¼š** å¯ä»¥æŠŠä¸Šé¢å‘½ä»¤å†™åˆ°bashrcæ–‡ä»¶ä¸­

- å®‰è£… Isaac Lab

ç›®å‰ä½¿ç”¨çš„IsaacLab çš„ç‰ˆæœ¬å·æ˜¯91ad4944f2b7fad29d52c04a5264a082bcaad71d

```
git clone git@github.com:isaac-sim/IsaacLab.git

sudo apt install cmake build-essential

cd IsaacLab

ln -s ${HOME}/tools/isaac-sim/ _isaac_sim     (è¯·æ ¹æ®è‡ªå·±è·¯å¾„å¡«å†™)

./isaaclab.sh --conda unitree_sim_env

conda activate  unitree_sim_env

./isaaclab.sh --install

```

- å®‰è£… unitree_sdk2_python

```
git clone https://github.com/unitreerobotics/unitree_sdk2_python

cd unitree_sdk2_python

pip3 install -e .

```

- å®‰è£…å…¶ä»–çš„ä¾èµ–

```
pip install -r requirements.txt

```

===== doc/isaacsim5.0_install.md =====

## Isaac Sim 5.0.0 Environment Installation
### 2.1 Installation on Ubuntu 22.04 and Later(pip install)

- **Create Virtual Environment**

```
conda create -n unitree_sim_env python=3.11
conda activate unitree_sim_env
```
- **Install Pytorch**

This needs to be installed according to your CUDA version. Please refer to the [official PyTorch installation guide](https://pytorch.org/get-started/locally/). The following example uses CUDA 12:

```
pip install torch==2.7.0 torchvision==0.22.0 torchaudio==2.7.0 --index-url https://download.pytorch.org/whl/cu126
```
- **Install Isaac Sim 5.0.0**

```
pip install --upgrade pip

pip install "isaacsim[all,extscache]==5.0.0" --extra-index-url https://pypi.nvidia.com
```
Verify successful installation:
```
isaacsim
```
First execution will show: Do you accept the EULA? (Yes/No):  Yes

-  **Install Isaac Lab**

```
git clone git@github.com:isaac-sim/IsaacLab.git

sudo apt install cmake build-essential

cd IsaacLab

git checkout v2.2.0

./isaaclab.sh --install 

```

Verify successful installation:
```
python scripts/tutorials/00_sim/create_empty.py
or
./isaaclab.sh -p scripts/tutorials/00_sim/create_empty.py
```

- **Install unitree_sdk2_python**

```
git clone https://github.com/unitreerobotics/unitree_sdk2_python

cd unitree_sdk2_python

pip3 install -e .
```

- **Install other dependencies**
```
pip install -r requirements.txt
```

### 2.2 Installation on Ubuntu 20.04(binary install)

- **Download Isaac Sim Binary**

Download the [Isaac Sim 5.0.0 binary](https://docs.isaacsim.omniverse.nvidia.com/latest/installation/download.html#download-isaac-sim-shortl) and extract it.

Assume the path to Isaac Sim is ``/home/unitree/tools/isaac-sim``. Follow the steps below:

- **Set environment variables**

Please replace with your own path

```
export ISAACSIM_PATH="${HOME}/tools/isaac-sim"            
export ISAACSIM_PYTHON_EXE="${ISAACSIM_PATH}/python.sh"  
```
Verify the setup:
```
${ISAACSIM_PATH}/isaac-sim.sh
# or
${ISAACSIM_PYTHON_EXE} -c "print('Isaac Sim configuration is now complete.')"

Note: All conda environments (including base) must be deactivated before running this.
```
**Note:** You can add the above commands to your ~/.bashrc file for convenience.

- **Install Isaac Lab**

```
git clone git@github.com:isaac-sim/IsaacLab.git

sudo apt install cmake build-essential

cd IsaacLab

git checkout v2.2.0

ln -s ${HOME}/tools/isaac-sim/ _isaac_sim     (Please replace with your own path)

./isaaclab.sh --conda unitree_sim_env

conda activate unitree_sim_env

./isaaclab.sh --install

```

- **Install unitree_sdk2_python**

```
git clone https://github.com/unitreerobotics/unitree_sdk2_python

cd unitree_sdk2_python

pip3 install -e .

```

- **Install other dependencies**

```
pip install -r requirements.txt
```

**Problem:**

* 1 `libstdc++.so.6` version is too low

```
OSError: /home/unitree/tools/anaconda3/envs/env_isaaclab_tem/bin/../lib/libstdc++.so.6: version GLIBCXX_3.4.30' not found (required by /home/unitree/tools/anaconda3/envs/env_isaaclab_tem/lib/python3.11/site-packages/omni/libcarb.so)
```
**Solution:**
`conda install -c conda-forge libstdcxx-ng`

*  2 Installation Issue with `unitree_sdk2_python`

If you encounter the following error when installing `unitree_sdk2_python`:

```
Could not locate cyclonedds. Try to set CYCLONEDDS_HOME or CMAKE_PREFIX_PATH
```

or

```
Collecting cyclonedds==0.10.2 (from unitree_sdk2py==1.0.1)
  Downloading cyclonedds-0.10.2.tar.gz (156 kB)
  Installing build dependencies ... done
  Getting requirements to build wheel ... error
  error: subprocess-exited-with-error
  
  Ã— Getting requirements to build wheel did not run successfully.
  â”‚ exit code: 1
  â•°â”€> [1 lines of output]
      Could not locate cyclonedds. Try to set CYCLONEDDS_HOME or CMAKE_PREFIX_PATH
      [end of output]
  
  note: This error originates from a subprocess, and is likely not a problem with pip.
error: subprocess-exited-with-error

Ã— Getting requirements to build wheel did not run successfully.
â”‚ exit code: 1
â•°â”€> See above for output.

note: This error originates from a subprocess, and is likely not a problem with pip.
```

**Solution**: Please refer to the [unitree\_sdk2\_python FAQ](https://github.com/unitreerobotics/unitree_sdk2_python?tab=readme-ov-file#faq) for instructions.


===== doc/isaacsim5.0_install_zh.md =====

## Isaac Sim 5.0.0ç¯å¢ƒå®‰è£…
### 2.1 Ubuntu 22.04 ä»¥åŠä»¥ä¸Šçš„å®‰è£…(pip install)

-  åˆ›å»ºè™šæ‹Ÿç¯å¢ƒ

```
conda create -n unitree_sim_env python=3.11
conda activate unitree_sim_env
```
- å®‰è£…Pytorch

è¿™ä¸ªéœ€è¦æ ¹æ®è‡ªå·±çš„CUDAç‰ˆæœ¬è¿›è¡Œå®‰è£…ï¼Œå…·ä½“å‚è€ƒ[Pytorchå®˜æ–¹æ•™ç¨‹](https://pytorch.org/get-started/locally/),ä¸‹é¢ä»¥CUDA 12ä¸ºä¾‹è¿›è¡Œå®‰è£…

```
pip install torch==2.7.0 torchvision==0.22.0 torchaudio==2.7.0 --index-url https://download.pytorch.org/whl/cu126
```
-  å®‰è£… Isaac Sim 5.0.0

```
pip install --upgrade pip

pip install "isaacsim[all,extscache]==5.0.0" --extra-index-url https://pypi.nvidia.com

```
éªŒè¯æ˜¯å¦å®‰è£…æˆåŠŸ
```
isaacsim
```
ç¬¬ä¸€æ¬¡æ‰§è¡Œä¼šæœ‰:Do you accept the EULA? (Yes/No):  Yes



- å®‰è£…Isaac Lab

```
git clone git@github.com:isaac-sim/IsaacLab.git

sudo apt install cmake build-essential

cd IsaacLab

git checkout v2.2.0

./isaaclab.sh --install 

```

éªŒè¯å®‰è£…æ˜¯å¦æˆåŠŸ
```
python scripts/tutorials/00_sim/create_empty.py
or
./isaaclab.sh -p scripts/tutorials/00_sim/create_empty.py
```

- å®‰è£…unitree_sdk2_python

```
git clone https://github.com/unitreerobotics/unitree_sdk2_python

cd unitree_sdk2_python

pip3 install -e .
```
- å®‰è£…å…¶ä»–ä¾èµ–
```
pip install -r requirements.txt
```

### 2.2 Ubuntu 20.4å®‰è£…(äºŒè¿›åˆ¶å®‰è£…)

- ä¸‹è½½äºŒè¿›åˆ¶çš„Isaaac Sim

ä¸‹è½½å¯¹åº”ç‰ˆæœ¬çš„
[äºŒè¿›åˆ¶Isaac Sim 5.0.0](https://docs.isaacsim.omniverse.nvidia.com/latest/installation/download.html#download-isaac-sim-short)å¹¶è§£å‹ï¼›

å‡è®¾isaac simæ”¾åœ¨`/home/unitree/tools/isaac-sim`,è¯·æŒ‰ç…§ä¸‹é¢çš„æ­¥éª¤è¿›è¡Œå®‰è£…ï¼›

- è®¾åœ¨ç¯å¢ƒå˜é‡

```
export ISAACSIM_PATH="${HOME}/tools/isaac-sim"

export ISAACSIM_PYTHON_EXE="${ISAACSIM_PATH}/python.sh"

```
æµ‹è¯•è®¾ç½®æ˜¯å¦æˆåŠŸ

```
${ISAACSIM_PATH}/isaac-sim.sh

æˆ–

${ISAACSIM_PYTHON_EXE} -c "print('Isaac Sim configuration is now complete.')" 

éœ€è¦é€€å‡ºåŒ…æ‹¬baseåœ¨å†…çš„æ‰€æœ‰çš„condaç¯å¢ƒ

```

**æ³¨æ„ï¼š** å¯ä»¥æŠŠä¸Šé¢å‘½ä»¤å†™åˆ°bashrcæ–‡ä»¶ä¸­

- å®‰è£… Isaac Lab

```
git clone git@github.com:isaac-sim/IsaacLab.git

sudo apt install cmake build-essential

cd IsaacLab

git checkout v2.2.0

ln -s ${HOME}/tools/isaac-sim/ _isaac_sim     (è¯·æ ¹æ®è‡ªå·±è·¯å¾„å¡«å†™)

./isaaclab.sh --conda unitree_sim_env

conda activate  unitree_sim_env

./isaaclab.sh --install

```

- å®‰è£… unitree_sdk2_python

```
git clone https://github.com/unitreerobotics/unitree_sdk2_python

cd unitree_sdk2_python

pip3 install -e .

```

- å®‰è£…å…¶ä»–çš„ä¾èµ–

```
pip install -r requirements.txt

```


**é—®é¢˜:**
- 1 libstdc++.so.6ç‰ˆæœ¬ä½
```
OSError: /home/unitree/tools/anaconda3/envs/env_isaaclab_tem/bin/../lib/libstdc++.so.6: version GLIBCXX_3.4.30' not found (required by /home/unitree/tools/anaconda3/envs/env_isaaclab_tem/lib/python3.11/site-packages/omni/libcarb.so)
```
è§£å†³: conda install -c conda-forge libstdcxx-ng

- 2 å®‰è£…unitree_sdk2_python é—®é¢˜

å¦‚æœåœ¨å®‰è£…unitree_sdk2_python é‡åˆ°ä»¥ä¸‹é—®é¢˜

```
Could not locate cyclonedds. Try to set CYCLONEDDS_HOME or CMAKE_PREFIX_PATH

```
æˆ–

```
Collecting cyclonedds==0.10.2 (from unitree_sdk2py==1.0.1)
  Downloading cyclonedds-0.10.2.tar.gz (156 kB)
  Installing build dependencies ... done
  Getting requirements to build wheel ... error
  error: subprocess-exited-with-error
  
  Ã— Getting requirements to build wheel did not run successfully.
  â”‚ exit code: 1
  â•°â”€> [1 lines of output]
      Could not locate cyclonedds. Try to set CYCLONEDDS_HOME or CMAKE_PREFIX_PATH
      [end of output]
  
  note: This error originates from a subprocess, and is likely not a problem with pip.
error: subprocess-exited-with-error

Ã— Getting requirements to build wheel did not run successfully.
â”‚ exit code: 1
â•°â”€> See above for output.

note: This error originates from a subprocess, and is likely not a problem with pip.
```
è§£å†³: è¯·å‚è€ƒ[unitree_sdk2_python FAQ](https://github.com/unitreerobotics/unitree_sdk2_python?tab=readme-ov-file#faq)



===== fetch_assets.sh =====

#!/bin/bash

set -e  # Exit script if any command fails 
set -o pipefail

# 1. Clone repository
echo "Cloning repository..."
git lfs install
git clone https://huggingface.co/datasets/unitreerobotics/unitree_sim_isaaclab_usds

# 2. Enter repository directory
cd unitree_sim_isaaclab_usds

# 3. Check if assets.zip exists and is greater than 1GB
if [ ! -f "assets.zip" ]; then
    echo "Error: assets.zip does not exist"
    exit 1
fi

filesize=$(stat -c%s "assets.zip")
if [ "$filesize" -le $((1024 * 1024 * 1024)) ]; then
    echo "Error: assets.zip is less than 1GB"
    exit 1
fi

echo "assets.zip check passed, size is $((filesize / 1024 / 1024)) MB"

# 4. Unzip assets.zip
echo "Unzipping assets.zip..."
unzip -q assets.zip

# 5. Move assets folder to parent directory
if [ -d "assets" ]; then
    echo "Moving assets to parent directory..."
    mv assets ../
else
    echo "Error: assets unzip failed or folder does not exist"
    exit 1
fi

# 6. Return to parent directory and delete original folder
cd ..
echo "Deleting unitree_sim_isaaclab_usds folder..."
rm -rf unitree_sim_isaaclab_usds

echo "âœ… All done!"


===== g1_29dof_with_hand_rev_1_0.urdf =====

<robot name="g1_29dof_with_hand_rev_1_0">
  <material name="dark">
    <color rgba="0.2 0.2 0.2 1"/>
  </material>
  <material name="white">
    <color rgba="0.7 0.7 0.7 1"/>
  </material>

  <mujoco>
    <compiler meshdir="meshes" discardvisual="false"/>
  </mujoco>

  <!-- [CAUTION] uncomment when convert to mujoco -->
  <!-- <link name="world"></link>
  <joint name="floating_base_joint" type="floating">
    <parent link="world"/>
    <child link="pelvis"/>
  </joint> -->

  <link name="pelvis">
    <inertial>
      <origin xyz="0 0 -0.07605" rpy="0 0 0"/>
      <mass value="3.813"/>
      <inertia ixx="0.010549" ixy="0" ixz="2.1E-06" iyy="0.0093089" iyz="0" izz="0.0079184"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/pelvis.STL"/>
      </geometry>
      <material name="dark"/>
    </visual>
  </link>
  <link name="pelvis_contour_link">
    <inertial>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <mass value="0.001"/>
      <inertia ixx="1e-7" ixy="0" ixz="0" iyy="1e-7" iyz="0" izz="1e-7"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/pelvis_contour_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/pelvis_contour_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="pelvis_contour_joint" type="fixed">
    <parent link="pelvis"/>
    <child link="pelvis_contour_link"/>
  </joint>

  <!-- Legs -->
  <link name="left_hip_pitch_link">
    <inertial>
      <origin xyz="0.002741 0.047791 -0.02606" rpy="0 0 0"/>
      <mass value="1.35"/>
      <inertia ixx="0.001811" ixy="3.68E-05" ixz="-3.44E-05" iyy="0.0014193" iyz="0.000171" izz="0.0012812"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hip_pitch_link.STL"/>
      </geometry>
      <material name="dark"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hip_pitch_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_hip_pitch_joint" type="revolute">
    <origin xyz="0 0.064452 -0.1027" rpy="0 0 0"/>
    <parent link="pelvis"/>
    <child link="left_hip_pitch_link"/>
    <axis xyz="0 1 0"/>
    <limit lower="-2.5307" upper="2.8798" effort="88" velocity="32"/>
  </joint>
  <link name="left_hip_roll_link">
    <inertial>
      <origin xyz="0.029812 -0.001045 -0.087934" rpy="0 0 0"/>
      <mass value="1.52"/>
      <inertia ixx="0.0023773" ixy="-3.8E-06" ixz="-0.0003908" iyy="0.0024123" iyz="1.84E-05" izz="0.0016595"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hip_roll_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hip_roll_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_hip_roll_joint" type="revolute">
    <origin xyz="0 0.052 -0.030465" rpy="0 -0.1749 0"/>
    <parent link="left_hip_pitch_link"/>
    <child link="left_hip_roll_link"/>
    <axis xyz="1 0 0"/>
    <limit lower="-0.5236" upper="2.9671" effort="139" velocity="20"/>
  </joint>
  <link name="left_hip_yaw_link">
    <inertial>
      <origin xyz="-0.057709 -0.010981 -0.15078" rpy="0 0 0"/>
      <mass value="1.702"/>
      <inertia ixx="0.0057774" ixy="-0.0005411" ixz="-0.0023948" iyy="0.0076124" iyz="-0.0007072" izz="0.003149"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hip_yaw_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hip_yaw_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_hip_yaw_joint" type="revolute">
    <origin xyz="0.025001 0 -0.12412" rpy="0 0 0"/>
    <parent link="left_hip_roll_link"/>
    <child link="left_hip_yaw_link"/>
    <axis xyz="0 0 1"/>
    <limit lower="-2.7576" upper="2.7576" effort="88" velocity="32"/>
  </joint>
  <link name="left_knee_link">
    <inertial>
      <origin xyz="0.005457 0.003964 -0.12074" rpy="0 0 0"/>
      <mass value="1.932"/>
      <inertia ixx="0.011329" ixy="4.82E-05" ixz="-4.49E-05" iyy="0.011277" iyz="-0.0007146" izz="0.0015168"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_knee_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_knee_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_knee_joint" type="revolute">
    <origin xyz="-0.078273 0.0021489 -0.17734" rpy="0 0.1749 0"/>
    <parent link="left_hip_yaw_link"/>
    <child link="left_knee_link"/>
    <axis xyz="0 1 0"/>
    <limit lower="-0.087267" upper="2.8798" effort="139" velocity="20"/>
  </joint>
  <link name="left_ankle_pitch_link">
    <inertial>
      <origin xyz="-0.007269 0 0.011137" rpy="0 0 0"/>
      <mass value="0.074"/>
      <inertia ixx="8.4E-06" ixy="0" ixz="-2.9E-06" iyy="1.89E-05" iyz="0" izz="1.26E-05"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_ankle_pitch_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_ankle_pitch_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_ankle_pitch_joint" type="revolute">
    <origin xyz="0 -9.4445E-05 -0.30001" rpy="0 0 0"/>
    <parent link="left_knee_link"/>
    <child link="left_ankle_pitch_link"/>
    <axis xyz="0 1 0"/>
    <limit lower="-0.87267" upper="0.5236" effort="35" velocity="30"/>
  </joint>
  <link name="left_ankle_roll_link">
    <inertial>
      <origin xyz="0.026505 0 -0.016425" rpy="0 0 0"/>
      <mass value="0.608"/>
      <inertia ixx="0.0002231" ixy="2E-07" ixz="8.91E-05" iyy="0.0016161" iyz="-1E-07" izz="0.0016667"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_ankle_roll_link.STL"/>
      </geometry>
      <material name="dark"/>
    </visual>
    <collision>
      <origin xyz="-0.05 0.025 -0.03" rpy="0 0 0"/>
      <geometry>
        <sphere radius="0.005"/>
      </geometry>
    </collision>
    <collision>
      <origin xyz="-0.05 -0.025 -0.03" rpy="0 0 0"/>
      <geometry>
        <sphere radius="0.005"/>
      </geometry>
    </collision>
    <collision>
      <origin xyz="0.12 0.03 -0.03" rpy="0 0 0"/>
      <geometry>
        <sphere radius="0.005"/>
      </geometry>
    </collision>
    <collision>
      <origin xyz="0.12 -0.03 -0.03" rpy="0 0 0"/>
      <geometry>
        <sphere radius="0.005"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_ankle_roll_joint" type="revolute">
    <origin xyz="0 0 -0.017558" rpy="0 0 0"/>
    <parent link="left_ankle_pitch_link"/>
    <child link="left_ankle_roll_link"/>
    <axis xyz="1 0 0"/>
    <limit lower="-0.2618" upper="0.2618" effort="35" velocity="30"/>
  </joint>
  <link name="right_hip_pitch_link">
    <inertial>
      <origin xyz="0.002741 -0.047791 -0.02606" rpy="0 0 0"/>
      <mass value="1.35"/>
      <inertia ixx="0.001811" ixy="-3.68E-05" ixz="-3.44E-05" iyy="0.0014193" iyz="-0.000171" izz="0.0012812"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hip_pitch_link.STL"/>
      </geometry>
      <material name="dark"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hip_pitch_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_hip_pitch_joint" type="revolute">
    <origin xyz="0 -0.064452 -0.1027" rpy="0 0 0"/>
    <parent link="pelvis"/>
    <child link="right_hip_pitch_link"/>
    <axis xyz="0 1 0"/>
    <limit lower="-2.5307" upper="2.8798" effort="88" velocity="32"/>
  </joint>
  <link name="right_hip_roll_link">
    <inertial>
      <origin xyz="0.029812 0.001045 -0.087934" rpy="0 0 0"/>
      <mass value="1.52"/>
      <inertia ixx="0.0023773" ixy="3.8E-06" ixz="-0.0003908" iyy="0.0024123" iyz="-1.84E-05" izz="0.0016595"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hip_roll_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hip_roll_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_hip_roll_joint" type="revolute">
    <origin xyz="0 -0.052 -0.030465" rpy="0 -0.1749 0"/>
    <parent link="right_hip_pitch_link"/>
    <child link="right_hip_roll_link"/>
    <axis xyz="1 0 0"/>
    <limit lower="-2.9671" upper="0.5236" effort="139" velocity="20"/>
  </joint>
  <link name="right_hip_yaw_link">
    <inertial>
      <origin xyz="-0.057709 0.010981 -0.15078" rpy="0 0 0"/>
      <mass value="1.702"/>
      <inertia ixx="0.0057774" ixy="0.0005411" ixz="-0.0023948" iyy="0.0076124" iyz="0.0007072" izz="0.003149"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hip_yaw_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hip_yaw_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_hip_yaw_joint" type="revolute">
    <origin xyz="0.025001 0 -0.12412" rpy="0 0 0"/>
    <parent link="right_hip_roll_link"/>
    <child link="right_hip_yaw_link"/>
    <axis xyz="0 0 1"/>
    <limit lower="-2.7576" upper="2.7576" effort="88" velocity="32"/>
  </joint>
  <link name="right_knee_link">
    <inertial>
      <origin xyz="0.005457 -0.003964 -0.12074" rpy="0 0 0"/>
      <mass value="1.932"/>
      <inertia ixx="0.011329" ixy="-4.82E-05" ixz="4.49E-05" iyy="0.011277" iyz="0.0007146" izz="0.0015168"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_knee_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_knee_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_knee_joint" type="revolute">
    <origin xyz="-0.078273 -0.0021489 -0.17734" rpy="0 0.1749 0"/>
    <parent link="right_hip_yaw_link"/>
    <child link="right_knee_link"/>
    <axis xyz="0 1 0"/>
    <limit lower="-0.087267" upper="2.8798" effort="139" velocity="20"/>
  </joint>
  <link name="right_ankle_pitch_link">
    <inertial>
      <origin xyz="-0.007269 0 0.011137" rpy="0 0 0"/>
      <mass value="0.074"/>
      <inertia ixx="8.4E-06" ixy="0" ixz="-2.9E-06" iyy="1.89E-05" iyz="0" izz="1.26E-05"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_ankle_pitch_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_ankle_pitch_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_ankle_pitch_joint" type="revolute">
    <origin xyz="0 9.4445E-05 -0.30001" rpy="0 0 0"/>
    <parent link="right_knee_link"/>
    <child link="right_ankle_pitch_link"/>
    <axis xyz="0 1 0"/>
    <limit lower="-0.87267" upper="0.5236" effort="35" velocity="30"/>
  </joint>
  <link name="right_ankle_roll_link">
    <inertial>
      <origin xyz="0.026505 0 -0.016425" rpy="0 0 0"/>
      <mass value="0.608"/>
      <inertia ixx="0.0002231" ixy="-2E-07" ixz="8.91E-05" iyy="0.0016161" iyz="1E-07" izz="0.0016667"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_ankle_roll_link.STL"/>
      </geometry>
      <material name="dark"/>
    </visual>
    <collision>
      <origin xyz="-0.05 0.025 -0.03" rpy="0 0 0"/>
      <geometry>
        <sphere radius="0.005"/>
      </geometry>
    </collision>
    <collision>
      <origin xyz="-0.05 -0.025 -0.03" rpy="0 0 0"/>
      <geometry>
        <sphere radius="0.005"/>
      </geometry>
    </collision>
    <collision>
      <origin xyz="0.12 0.03 -0.03" rpy="0 0 0"/>
      <geometry>
        <sphere radius="0.005"/>
      </geometry>
    </collision>
    <collision>
      <origin xyz="0.12 -0.03 -0.03" rpy="0 0 0"/>
      <geometry>
        <sphere radius="0.005"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_ankle_roll_joint" type="revolute">
    <origin xyz="0 0 -0.017558" rpy="0 0 0"/>
    <parent link="right_ankle_pitch_link"/>
    <child link="right_ankle_roll_link"/>
    <axis xyz="1 0 0"/>
    <limit lower="-0.2618" upper="0.2618" effort="35" velocity="30"/>
  </joint>

  <!-- Torso -->
  <link name="waist_yaw_link">
    <inertial>
      <origin xyz="0.003494 0.000233 0.018034" rpy="0 0 0"/>
      <mass value="0.214"/>
      <inertia ixx="0.00010673" ixy="2.703E-06" ixz="-7.631E-06" iyy="0.00010422" iyz="-2.01E-07" izz="0.0001625"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/waist_yaw_link_rev_1_0.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
  </link>
  <joint name="waist_yaw_joint" type="revolute">
    <origin xyz="0 0 0" rpy="0 0 0"/>
    <parent link="pelvis"/>
    <child link="waist_yaw_link"/>
    <axis xyz="0 0 1"/>
    <limit lower="-2.618" upper="2.618" effort="88" velocity="32"/>
  </joint>
  <link name="waist_roll_link">
    <inertial>
      <origin xyz="0 2.3E-05 0" rpy="0 0 0"/>
      <mass value="0.086"/>
      <inertia ixx="7.079E-06" ixy="0" ixz="0" iyy="6.339E-06" iyz="0" izz="8.245E-06"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/waist_roll_link_rev_1_0.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
  </link>
  <joint name="waist_roll_joint" type="revolute">
    <origin xyz="-0.0039635 0 0.044" rpy="0 0 0"/>
    <parent link="waist_yaw_link"/>
    <child link="waist_roll_link"/>
    <axis xyz="1 0 0"/>
    <limit lower="-0.52" upper="0.52" effort="35" velocity="30"/>
  </joint>
  <link name="torso_link">
    <inertial>
      <origin xyz="0.000931 0.000346 0.15082" rpy="0 0 0"/>
      <mass value="6.78"/>
      <inertia ixx="0.05905" ixy="3.3302E-05" ixz="-0.0017715" iyy="0.047014" iyz="-2.2399E-05" izz="0.025652"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/torso_link_rev_1_0.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/torso_link_rev_1_0.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="waist_pitch_joint" type="revolute">
    <origin xyz="0 0 0" rpy="0 0 0"/>
    <parent link="waist_roll_link"/>
    <child link="torso_link"/>
    <axis xyz="0 1 0"/>
    <limit lower="-0.52" upper="0.52" effort="35" velocity="30"/>
  </joint>

  <!-- LOGO -->
  <joint name="logo_joint" type="fixed">
    <origin xyz="0.0039635 0 -0.044" rpy="0 0 0"/>
    <parent link="torso_link"/>
    <child link="logo_link"/>
  </joint>
  <link name="logo_link">
    <inertial>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <mass value="0.001"/>
      <inertia ixx="1e-7" ixy="0" ixz="0" iyy="1e-7" iyz="0" izz="1e-7"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/logo_link.STL"/>
      </geometry>
      <material name="dark"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/logo_link.STL"/>
      </geometry>
    </collision>
  </link>

  <!-- Head -->
  <link name="head_link">
    <inertial>
      <origin xyz="0.005267 0.000299 0.449869" rpy="0 0 0"/>
      <mass value="1.036"/>
      <inertia ixx="0.004085051" ixy="-2.543E-06" ixz="-6.9455E-05" iyy="0.004185212" iyz="-3.726E-06" izz="0.001807911"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/head_link.STL"/>
      </geometry>
      <material name="dark"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/head_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="head_joint" type="fixed">
    <origin xyz="0.0039635 0 -0.044" rpy="0 0 0"/>
    <parent link="torso_link"/>
    <child link="head_link"/>
  </joint>


  <!-- IMU -->
  <link name="imu_in_torso"></link>
  <joint name="imu_in_torso_joint" type="fixed">
    <origin xyz="-0.03959 -0.00224 0.14792" rpy="0 0 0"/>
    <parent link="torso_link"/>
    <child link="imu_in_torso"/>
  </joint>

  <link name="imu_in_pelvis"></link>
  <joint name="imu_in_pelvis_joint" type="fixed">
    <origin xyz="0.04525 0 -0.08339" rpy="0 0 0"/>
    <parent link="pelvis"/>
    <child link="imu_in_pelvis"/>
  </joint>

  <!-- d435 -->
  <link name="d435_link"></link>
  <joint name="d435_joint" type="fixed">
    <origin xyz="0.0576235 0.01753 0.42987" rpy="0 0.8307767239493009 0"/>
    <parent link="torso_link"/>
    <child link="d435_link"/>
  </joint>

  <!-- mid360 -->
  <link name="mid360_link"></link>
  <joint name="mid360_joint" type="fixed">
    <origin xyz="0.0002835 0.00003 0.41618" rpy="0 0.04014257279586953 0"/>
    <parent link="torso_link"/>
    <child link="mid360_link"/>
  </joint>

  <!-- Arm -->
  <link name="left_shoulder_pitch_link">
    <inertial>
      <origin xyz="0 0.035892 -0.011628" rpy="0 0 0"/>
      <mass value="0.718"/>
      <inertia ixx="0.0004291" ixy="-9.2E-06" ixz="6.4E-06" iyy="0.000453" iyz="2.26E-05" izz="0.000423"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_shoulder_pitch_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0.04 -0.01" rpy="0 1.5707963267948966 0"/>
      <geometry>
        <cylinder radius="0.03" length="0.05"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_shoulder_pitch_joint" type="revolute">
    <origin xyz="0.0039563 0.10022 0.24778" rpy="0.27931 5.4949E-05 -0.00019159"/>
    <parent link="torso_link"/>
    <child link="left_shoulder_pitch_link"/>
    <axis xyz="0 1 0"/>
    <limit lower="-3.0892" upper="2.6704" effort="25" velocity="37"/>
  </joint>
  <link name="left_shoulder_roll_link">
    <inertial>
      <origin xyz="-0.000227 0.00727 -0.063243" rpy="0 0 0"/>
      <mass value="0.643"/>
      <inertia ixx="0.0006177" ixy="-1E-06" ixz="8.7E-06" iyy="0.0006912" iyz="-5.3E-06" izz="0.0003894"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_shoulder_roll_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="-0.004 0.006 -0.053" rpy="0 0 0"/>
      <geometry>
        <cylinder radius="0.03" length="0.03"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_shoulder_roll_joint" type="revolute">
    <origin xyz="0 0.038 -0.013831" rpy="-0.27925 0 0"/>
    <parent link="left_shoulder_pitch_link"/>
    <child link="left_shoulder_roll_link"/>
    <axis xyz="1 0 0"/>
    <limit lower="-1.5882" upper="2.2515" effort="25" velocity="37"/>
  </joint>
  <link name="left_shoulder_yaw_link">
    <inertial>
      <origin xyz="0.010773 -0.002949 -0.072009" rpy="0 0 0"/>
      <mass value="0.734"/>
      <inertia ixx="0.0009988" ixy="7.9E-06" ixz="0.0001412" iyy="0.0010605" iyz="-2.86E-05" izz="0.0004354"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_shoulder_yaw_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_shoulder_yaw_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_shoulder_yaw_joint" type="revolute">
    <origin xyz="0 0.00624 -0.1032" rpy="0 0 0"/>
    <parent link="left_shoulder_roll_link"/>
    <child link="left_shoulder_yaw_link"/>
    <axis xyz="0 0 1"/>
    <limit lower="-2.618" upper="2.618" effort="25" velocity="37"/>
  </joint>
  <link name="left_elbow_link">
    <inertial>
      <origin xyz="0.064956 0.004454 -0.010062" rpy="0 0 0"/>
      <mass value="0.6"/>
      <inertia ixx="0.0002891" ixy="6.53E-05" ixz="1.72E-05" iyy="0.0004152" iyz="-5.6E-06" izz="0.0004197"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_elbow_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_elbow_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_elbow_joint" type="revolute">
    <origin xyz="0.015783 0 -0.080518" rpy="0 0 0"/>
    <parent link="left_shoulder_yaw_link"/>
    <child link="left_elbow_link"/>
    <axis xyz="0 1 0"/>
    <limit lower="-1.0472" upper="2.0944" effort="25" velocity="37"/>
  </joint>
  <joint name="left_wrist_roll_joint" type="revolute">
    <origin xyz="0.100 0.00188791 -0.010" rpy="0 0 0"/>
    <axis xyz="1 0 0"/>
    <parent link="left_elbow_link"/>
    <child link="left_wrist_roll_link"/>
    <limit effort="25" velocity="37" lower="-1.972222054" upper="1.972222054"/>
  </joint>
  <link name="left_wrist_roll_link">
    <inertial>
      <origin xyz="0.01713944778 0.00053759094 0.00000048864" rpy="0 0 0"/>
      <mass value="0.08544498"/>
      <inertia ixx="0.00004821544023" ixy="-0.00000424511021" ixz="0.00000000510599" iyy="0.00003722899093" iyz="-0.00000000123525" izz="0.00005482106541"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_wrist_roll_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_wrist_roll_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_wrist_pitch_joint" type="revolute">
    <origin xyz="0.038 0 0" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <parent link="left_wrist_roll_link"/>
    <child link="left_wrist_pitch_link"/>
    <limit effort="5" velocity="22" lower="-1.614429558" upper="1.614429558"/>
  </joint>
  <link name="left_wrist_pitch_link">
    <inertial>
      <origin xyz="0.02299989837 -0.00111685314 -0.00111658096" rpy="0 0 0"/>
      <mass value="0.48404956"/>
      <inertia ixx="0.00016579646273" ixy="-0.00001231206746" ixz="0.00001231699194" iyy="0.00042954057410" iyz="0.00000081417712" izz="0.00042953697654"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_wrist_pitch_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_wrist_pitch_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_wrist_yaw_joint" type="revolute">
    <origin xyz="0.046 0 0" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="left_wrist_pitch_link"/>
    <child link="left_wrist_yaw_link"/>
    <limit effort="5" velocity="22" lower="-1.614429558" upper="1.614429558"/>
  </joint>
  <link name="left_wrist_yaw_link">
    <inertial>
      <origin xyz="0.02200381568 0.00049485096 0.00053861123" rpy="0 0 0"/>
      <mass value="0.08457647"/>
      <inertia ixx="0.00004929128828" ixy="-0.00000045735494" ixz="0.00000445867591" iyy="0.00005973338134" iyz="0.00000043217198" izz="0.00003928083826"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_wrist_yaw_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_wrist_yaw_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_hand_palm_joint" type="fixed">
    <origin xyz="0.0415 0.003 0" rpy="0 0 0"/>
    <parent link="left_wrist_yaw_link"/>
    <child link="left_hand_palm_link"/>
  </joint>
  <link name="left_hand_palm_link">
    <inertial>
      <origin xyz="0.06214634836 -0.00050869656 -0.00058171093" rpy="0 0 0"/>
      <mass value="0.37283854"/>
      <inertia ixx="0.00027535181027" ixy="-0.00001595519465" ixz="-0.00000242161890" iyy="0.00053951827219" iyz="-0.00000042279435" izz="0.00039623390907"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_palm_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_palm_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_hand_thumb_0_joint" type="revolute">
    <origin xyz="0.0255 0 0" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <parent link="left_hand_palm_link"/>
    <child link="left_hand_thumb_0_link"/>
    <limit effort="2.45" velocity="3.14" lower="-1.04719755" upper="1.04719755"/>
  </joint>
  <link name="left_hand_thumb_0_link">
    <inertial>
      <origin xyz="-0.00088424580 -0.00863407079 0.00094429336" rpy="0 0 0"/>
      <mass value="0.08623657"/>
      <inertia ixx="0.00001602919238" ixy="0.00000010683177" ixz="0.00000016728875" iyy="0.00001451795012" iyz="-0.00000051094752" izz="0.00001637877663"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_thumb_0_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_thumb_0_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_hand_thumb_1_joint" type="revolute">
    <origin xyz="-0.0025 -0.0193 0" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="left_hand_thumb_0_link"/>
    <child link="left_hand_thumb_1_link"/>
    <limit effort="1.4" velocity="12" lower="-0.61086523" upper="1.04719755"/>
  </joint>
  <link name="left_hand_thumb_1_link">
    <inertial>
      <origin xyz="-0.00082788768 -0.03547435774 -0.00038089960" rpy="0 0 0"/>
      <mass value="0.05885070"/>
      <inertia ixx="0.00001274699945" ixy="-0.00000050770784" ixz="0.00000016088850" iyy="0.00000601573947" iyz="-0.00000027839003" izz="0.00001234543582"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_thumb_1_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="-0.001 -0.032 0" rpy="0 0 0"/>
      <geometry>
        <box size="0.02 0.03 0.02"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_hand_thumb_2_joint" type="revolute">
    <origin xyz="0 -0.0458 0" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="left_hand_thumb_1_link"/>
    <child link="left_hand_thumb_2_link"/>
    <limit effort="1.4" velocity="12" lower="0" upper="1.74532925"/>
  </joint>
  <link name="left_hand_thumb_2_link">
    <inertial>
      <origin xyz="-0.00171735242 -0.02628192939 0.00010778879" rpy="0 0 0"/>
      <mass value="0.02030626"/>
      <inertia ixx="0.00000461267817" ixy="-0.00000003422130" ixz="-0.00000000823881" iyy="0.00000153561368" iyz="-0.00000002549885" izz="0.00000386625776"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_thumb_2_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_thumb_2_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_hand_middle_0_joint" type="revolute">
    <origin xyz="0.0777 0.0016 -0.0285" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="left_hand_palm_link"/>
    <child link="left_hand_middle_0_link"/>
    <limit effort="1.4" velocity="12" lower="-1.57079632" upper="0"/>
  </joint>
  <link name="left_hand_middle_0_link">
    <inertial>
      <origin xyz="0.03547435774 0.00082788768 0.00038089960" rpy="0 0 0"/>
      <mass value="0.05885070"/>
      <inertia ixx="0.00000601573947" ixy="-0.00000050770784" ixz="-0.00000027839003" iyy="0.00001274699945" iyz="0.00000016088850" izz="0.00001234543582"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_middle_0_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_middle_0_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_hand_middle_1_joint" type="revolute">
    <origin xyz="0.0458 0 0" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="left_hand_middle_0_link"/>
    <child link="left_hand_middle_1_link"/>
    <limit effort="1.4" velocity="12" lower="-1.74532925" upper="0"/>
  </joint>
  <link name="left_hand_middle_1_link">
    <inertial>
      <origin xyz="0.02628192939 0.00171735242 -0.00010778879" rpy="0 0 0"/>
      <mass value="0.02030626"/>
      <inertia ixx="0.00000153561368" ixy="-0.00000003422130" ixz="-0.00000002549885" iyy="0.00000461267817" iyz="-0.00000000823881" izz="0.00000386625776"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_middle_1_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_middle_1_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_hand_index_0_joint" type="revolute">
    <origin xyz="0.0777 0.0016 0.0285" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="left_hand_palm_link"/>
    <child link="left_hand_index_0_link"/>
    <limit effort="1.4" velocity="12" lower="-1.57079632" upper="0"/>
  </joint>
  <link name="left_hand_index_0_link">
    <inertial>
      <origin xyz="0.03547435774 0.00082788768 0.00038089960" rpy="0 0 0"/>
      <mass value="0.05885070"/>
      <inertia ixx="0.00000601573947" ixy="-0.00000050770784" ixz="-0.00000027839003" iyy="0.00001274699945" iyz="0.00000016088850" izz="0.00001234543582"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_index_0_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_index_0_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="left_hand_index_1_joint" type="revolute">
    <origin xyz="0.0458 0 0" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="left_hand_index_0_link"/>
    <child link="left_hand_index_1_link"/>
    <limit effort="1.4" velocity="12" lower="-1.74532925" upper="0"/>
  </joint>
  <link name="left_hand_index_1_link">
    <inertial>
      <origin xyz="0.02628192939 0.00171735242 -0.00010778879" rpy="0 0 0"/>
      <mass value="0.02030626"/>
      <inertia ixx="0.00000153561368" ixy="-0.00000003422130" ixz="-0.00000002549885" iyy="0.00000461267817" iyz="-0.00000000823881" izz="0.00000386625776"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_index_1_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/left_hand_index_1_link.STL"/>
      </geometry>
    </collision>
  </link>
  <link name="right_shoulder_pitch_link">
    <inertial>
      <origin xyz="0 -0.035892 -0.011628" rpy="0 0 0"/>
      <mass value="0.718"/>
      <inertia ixx="0.0004291" ixy="9.2E-06" ixz="6.4E-06" iyy="0.000453" iyz="-2.26E-05" izz="0.000423"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_shoulder_pitch_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 -0.04 -0.01" rpy="0 1.5707963267948966 0"/>
      <geometry>
        <cylinder radius="0.03" length="0.05"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_shoulder_pitch_joint" type="revolute">
    <origin xyz="0.0039563 -0.10021 0.24778" rpy="-0.27931 5.4949E-05 0.00019159"/>
    <parent link="torso_link"/>
    <child link="right_shoulder_pitch_link"/>
    <axis xyz="0 1 0"/>
    <limit lower="-3.0892" upper="2.6704" effort="25" velocity="37"/>
  </joint>
  <link name="right_shoulder_roll_link">
    <inertial>
      <origin xyz="-0.000227 -0.00727 -0.063243" rpy="0 0 0"/>
      <mass value="0.643"/>
      <inertia ixx="0.0006177" ixy="1E-06" ixz="8.7E-06" iyy="0.0006912" iyz="5.3E-06" izz="0.0003894"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_shoulder_roll_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="-0.004 -0.006 -0.053" rpy="0 0 0"/>
      <geometry>
        <cylinder radius="0.03" length="0.03"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_shoulder_roll_joint" type="revolute">
    <origin xyz="0 -0.038 -0.013831" rpy="0.27925 0 0"/>
    <parent link="right_shoulder_pitch_link"/>
    <child link="right_shoulder_roll_link"/>
    <axis xyz="1 0 0"/>
    <limit lower="-2.2515" upper="1.5882" effort="25" velocity="37"/>
  </joint>
  <link name="right_shoulder_yaw_link">
    <inertial>
      <origin xyz="0.010773 0.002949 -0.072009" rpy="0 0 0"/>
      <mass value="0.734"/>
      <inertia ixx="0.0009988" ixy="-7.9E-06" ixz="0.0001412" iyy="0.0010605" iyz="2.86E-05" izz="0.0004354"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_shoulder_yaw_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_shoulder_yaw_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_shoulder_yaw_joint" type="revolute">
    <origin xyz="0 -0.00624 -0.1032" rpy="0 0 0"/>
    <parent link="right_shoulder_roll_link"/>
    <child link="right_shoulder_yaw_link"/>
    <axis xyz="0 0 1"/>
    <limit lower="-2.618" upper="2.618" effort="25" velocity="37"/>
  </joint>
  <link name="right_elbow_link">
    <inertial>
      <origin xyz="0.064956 -0.004454 -0.010062" rpy="0 0 0"/>
      <mass value="0.6"/>
      <inertia ixx="0.0002891" ixy="-6.53E-05" ixz="1.72E-05" iyy="0.0004152" iyz="5.6E-06" izz="0.0004197"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_elbow_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_elbow_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_elbow_joint" type="revolute">
    <origin xyz="0.015783 0 -0.080518" rpy="0 0 0"/>
    <parent link="right_shoulder_yaw_link"/>
    <child link="right_elbow_link"/>
    <axis xyz="0 1 0"/>
    <limit lower="-1.0472" upper="2.0944" effort="25" velocity="37"/>
  </joint>
  <joint name="right_wrist_roll_joint" type="revolute">
    <origin xyz="0.100 -0.00188791 -0.010" rpy="0 0 0"/>
    <axis xyz="1 0 0"/>
    <parent link="right_elbow_link"/>
    <child link="right_wrist_roll_link"/>
    <limit effort="25" velocity="37" lower="-1.972222054" upper="1.972222054"/>
  </joint>
  <link name="right_wrist_roll_link">
    <inertial>
      <origin xyz="0.01713944778 -0.00053759094 0.00000048864" rpy="0 0 0"/>
      <mass value="0.08544498"/>
      <inertia ixx="0.00004821544023" ixy="0.00000424511021" ixz="0.00000000510599" iyy="0.00003722899093" iyz="0.00000000123525" izz="0.00005482106541"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_wrist_roll_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_wrist_roll_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_wrist_pitch_joint" type="revolute">
    <origin xyz="0.038 0 0" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <parent link="right_wrist_roll_link"/>
    <child link="right_wrist_pitch_link"/>
    <limit effort="5" velocity="22" lower="-1.614429558" upper="1.614429558"/>
  </joint>
  <link name="right_wrist_pitch_link">
    <inertial>
      <origin xyz="0.02299989837 0.00111685314 -0.00111658096" rpy="0 0 0"/>
      <mass value="0.48404956"/>
      <inertia ixx="0.00016579646273" ixy="0.00001231206746" ixz="0.00001231699194" iyy="0.00042954057410" iyz="-0.00000081417712" izz="0.00042953697654"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_wrist_pitch_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_wrist_pitch_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_wrist_yaw_joint" type="revolute">
    <origin xyz="0.046 0 0" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="right_wrist_pitch_link"/>
    <child link="right_wrist_yaw_link"/>
    <limit effort="5" velocity="22" lower="-1.614429558" upper="1.614429558"/>
  </joint>
  <link name="right_wrist_yaw_link">
    <inertial>
      <origin xyz="0.02200381568 -0.00049485096 0.00053861123" rpy="0 0 0"/>
      <mass value="0.08457647"/>
      <inertia ixx="0.00004929128828" ixy="0.00000045735494" ixz="0.00000445867591" iyy="0.00005973338134" iyz="-0.00000043217198" izz="0.00003928083826"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_wrist_yaw_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_wrist_yaw_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_hand_palm_joint" type="fixed">
    <origin xyz="0.0415 -0.003 0" rpy="0 0 0"/>
    <parent link="right_wrist_yaw_link"/>
    <child link="right_hand_palm_link"/>
  </joint>
  <link name="right_hand_palm_link">
    <inertial>
      <origin xyz="0.06214634836 0.00050869656 -0.00058171093" rpy="0 0 0"/>
      <mass value="0.37283854"/>
      <inertia ixx="0.00027535181027" ixy="0.00001595519465" ixz="-0.00000242161890" iyy="0.00053951827219" iyz="0.00000042279435" izz="0.00039623390907"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_palm_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_palm_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_hand_thumb_0_joint" type="revolute">
    <origin xyz="0.0255 0 0" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <parent link="right_hand_palm_link"/>
    <child link="right_hand_thumb_0_link"/>
    <limit effort="2.45" velocity="3.14" lower="-1.04719755" upper="1.04719755"/>
  </joint>
  <link name="right_hand_thumb_0_link">
    <inertial>
      <origin xyz="-0.00088424580 0.00863407079 0.00094429336" rpy="0 0 0"/>
      <mass value="0.08623657"/>
      <inertia ixx="0.00001602919238" ixy="-0.00000010683177" ixz="0.00000016728875" iyy="0.00001451795012" iyz="0.00000051094752" izz="0.00001637877663"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_thumb_0_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_thumb_0_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_hand_thumb_1_joint" type="revolute">
    <origin xyz="-0.0025 0.0193 0" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="right_hand_thumb_0_link"/>
    <child link="right_hand_thumb_1_link"/>
    <limit effort="1.4" velocity="12" lower="-1.04719755" upper="0.61086523"/>
  </joint>
  <link name="right_hand_thumb_1_link">
    <inertial>
      <origin xyz="-0.00082788768 0.03547435774 -0.00038089960" rpy="0 0 0"/>
      <mass value="0.05885070"/>
      <inertia ixx="0.00001274699945" ixy="0.00000050770784" ixz="0.00000016088850" iyy="0.00000601573947" iyz="0.00000027839003" izz="0.00001234543582"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_thumb_1_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="-0.001 0.032 0" rpy="0 0 0"/>
      <geometry>
        <box size="0.02 0.03 0.02"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_hand_thumb_2_joint" type="revolute">
    <origin xyz="0 0.0458 0" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="right_hand_thumb_1_link"/>
    <child link="right_hand_thumb_2_link"/>
    <limit effort="1.4" velocity="12" lower="-1.74532925" upper="0"/>
  </joint>
  <link name="right_hand_thumb_2_link">
    <inertial>
      <origin xyz="-0.00171735242 0.02628192939 0.00010778879" rpy="0 0 0"/>
      <mass value="0.02030626"/>
      <inertia ixx="0.00000461267817" ixy="0.00000003422130" ixz="-0.00000000823881" iyy="0.00000153561368" iyz="0.00000002549885" izz="0.00000386625776"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_thumb_2_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_thumb_2_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_hand_middle_0_joint" type="revolute">
    <origin xyz="0.0777 -0.0016 -0.0285" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="right_hand_palm_link"/>
    <child link="right_hand_middle_0_link"/>
    <limit effort="1.4" velocity="12" lower="0" upper="1.57079632"/>
  </joint>
  <link name="right_hand_middle_0_link">
    <inertial>
      <origin xyz="0.03547435774 -0.00082788768 0.00038089960" rpy="0 0 0"/>
      <mass value="0.05885070"/>
      <inertia ixx="0.00000601573947" ixy="0.00000050770784" ixz="-0.00000027839003" iyy="0.00001274699945" iyz="-0.00000016088850" izz="0.00001234543582"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_middle_0_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_middle_0_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_hand_middle_1_joint" type="revolute">
    <origin xyz="0.0458 0 0" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="right_hand_middle_0_link"/>
    <child link="right_hand_middle_1_link"/>
    <limit effort="1.4" velocity="12" lower="0" upper="1.74532925"/>
  </joint>
  <link name="right_hand_middle_1_link">
    <inertial>
      <origin xyz="0.02628192939 -0.00171735242 -0.00010778879" rpy="0 0 0"/>
      <mass value="0.02030626"/>
      <inertia ixx="0.00000153561368" ixy="0.00000003422130" ixz="-0.00000002549885" iyy="0.00000461267817" iyz="0.00000000823881" izz="0.00000386625776"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_middle_1_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_middle_1_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_hand_index_0_joint" type="revolute">
    <origin xyz="0.0777 -0.0016 0.0285" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="right_hand_palm_link"/>
    <child link="right_hand_index_0_link"/>
    <limit effort="1.4" velocity="12" lower="0" upper="1.57079632"/>
  </joint>
  <link name="right_hand_index_0_link">
    <inertial>
      <origin xyz="0.03547435774 -0.00082788768 0.00038089960" rpy="0 0 0"/>
      <mass value="0.05885070"/>
      <inertia ixx="0.00000601573947" ixy="0.00000050770784" ixz="-0.00000027839003" iyy="0.00001274699945" iyz="-0.00000016088850" izz="0.00001234543582"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_index_0_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_index_0_link.STL"/>
      </geometry>
    </collision>
  </link>
  <joint name="right_hand_index_1_joint" type="revolute">
    <origin xyz="0.0458 0 0" rpy="0 0 0"/>
    <axis xyz="0 0 1"/>
    <parent link="right_hand_index_0_link"/>
    <child link="right_hand_index_1_link"/>
    <limit effort="1.4" velocity="12" lower="0" upper="1.74532925"/>
  </joint>
  <link name="right_hand_index_1_link">
    <inertial>
      <origin xyz="0.02628192939 -0.00171735242 -0.00010778879" rpy="0 0 0"/>
      <mass value="0.02030626"/>
      <inertia ixx="0.00000153561368" ixy="0.00000003422130" ixz="-0.00000002549885" iyy="0.00000461267817" iyz="0.00000000823881" izz="0.00000386625776"/>
    </inertial>
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_index_1_link.STL"/>
      </geometry>
      <material name="white"/>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <mesh filename="meshes/right_hand_index_1_link.STL"/>
      </geometry>
    </collision>
  </link>
</robot>

===== image_server/__init__.py =====



===== image_server/image_server.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
A ZMQ-based image server that reads multi-image data from shared memory and publishes it
"""

import cv2
import zmq
import time
import threading
from image_server.shared_memory_utils import MultiImageReader


class ImageServer:
    def __init__(self, fps=30, port=5555, Unit_Test=False):
        """
        Multi-image server - read multi-image data from shared memory and publish it
        """
        print("[Image Server] Initializing multi-image server from shared memory")
        
        self.fps = fps
        self.port = port
        self.Unit_Test = Unit_Test
        self.running = False
        self.publish_thread = None
        self.frame_count = 0

        # Initialize multi-image shared memory reader
        self.multi_image_reader = MultiImageReader()

        # Set ZeroMQ context and socket
        self.context = zmq.Context()
        self.socket = self.context.socket(zmq.PUB)
        self.socket.bind(f"tcp://*:{self.port}")

        if self.Unit_Test:
            self._init_performance_metrics()

        print(f"[Image Server] Multi-image server initialized on port {self.port}")
        
        # start the publishing thread
        self.start_publishing()

    def _init_performance_metrics(self):
        self.frame_count = 0
        self.time_window = 1.0
        self.frame_times = []
        self.start_time = time.time()

    def _update_performance_metrics(self, current_time):
        self.frame_times.append(current_time)
        # Remove timestamps outside the time window
        self.frame_times = [t for t in self.frame_times if t >= current_time - self.time_window]
        self.frame_count += 1

    def _print_performance_metrics(self, current_time):
        if self.frame_count % 30 == 0:
            elapsed_time = current_time - self.start_time
            real_time_fps = len(self.frame_times) / self.time_window if self.frame_times else 0
            print(f"[Image Server] Real-time FPS: {real_time_fps:.2f}, Total frames sent: {self.frame_count}, Elapsed time: {elapsed_time:.2f} sec")

    def send_process(self):
        """Read the concatenated images from shared memory and send them"""
        print("[Image Server] Starting send_process from shared memory...")
        
        try:
            while True:
                # read the concatenated images from shared memory
                concatenated_image = self.multi_image_reader.read_concatenated_image()
                
                if concatenated_image is None:
                    # if there is no image data, wait a moment and try again
                    time.sleep(0.01)
                    continue
                
                # show the concatenated images
                # cv2.imshow('Concatenated Images (Head + Left + Right)', concatenated_image)
                # key = cv2.waitKey(1) & 0xFF
                # if key == ord('q') or key == 27:  # 'q' æˆ– ESC é”®é€€å‡º
                #     print("[Image Server] User pressed quit key")
                #     break
                
                # encode the images
                ret, buffer = cv2.imencode('.jpg', concatenated_image)
                if not ret:
                    print("[Image Server] Frame imencode is failed.")
                    continue

                jpg_bytes = buffer.tobytes()

                # build the message
                message = jpg_bytes

                # send the message
                self.socket.send(message)
                self.frame_count += 1

        except KeyboardInterrupt:
            print("[Image Server] Interrupted by user.")
        finally:
            cv2.destroyAllWindows()  # close the display window
            self._close()

    def start_publishing(self):
        """Start the publishing thread"""
        if not self.running:
            self.running = True
            self.publish_thread = threading.Thread(target=self.send_process)
            self.publish_thread.daemon = True
            self.publish_thread.start()
            print("[Image Server] Multi-image publishing thread started")

    def stop_publishing(self):
        """Stop the publishing thread"""
        if self.running:
            self.running = False
            if self.publish_thread:
                self.publish_thread.join(timeout=1.0)
            print("[Image Server] Publishing thread stopped")

    def _close(self):
        """Close the server"""
        self.stop_publishing()
        cv2.destroyAllWindows()
        
        # close the shared memory reader
        if hasattr(self, 'multi_image_reader'):
            self.multi_image_reader.close()
            
        # close the network connection
        self.socket.close()
        self.context.term()
        print("[Image Server] Multi-image server closed")

    def __del__(self):
        """Destructor"""
        self._close()


if __name__ == "__main__":
    # use the send_process mode example
    server = ImageServer(fps=30, Unit_Test=False)
    
    # use the send_process method (blocking)
    server.send_process()
    
    # or use the thread mode
    # try:
    #     server.start_publishing()
    #     print("[Image Server] Server running... Press Ctrl+C to stop")
    #     while True:
    #         time.sleep(1)
    # except KeyboardInterrupt:
    #     print("\n[Image Server] Interrupted by user")
    # finally:
    #     server._close()

===== image_server/shared_memory_utils.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
A simplified multi-image shared memory tool module
When writing, concatenate three images (head, left, right) horizontally and write them
When reading, split the concatenated image into three independent images
"""

import ctypes
import time
import numpy as np
import cv2
from multiprocessing import shared_memory
from typing import Optional, Dict, List
import struct
import os

# shared memory configuration
SHM_NAME = "isaac_multi_image_shm"
SHM_SIZE = 640* 480 * 3 * 3 + 1024  # the size of the concatenated images + the header information buffer

# define the simplified header structure
class SimpleImageHeader(ctypes.Structure):
    """Simplified image header structure"""
    _fields_ = [
        ('timestamp', ctypes.c_uint64),    # timestamp
        ('height', ctypes.c_uint32),       # image height
        ('width', ctypes.c_uint32),        # total width after concatenation
        ('channels', ctypes.c_uint32),     # number of channels
        ('single_width', ctypes.c_uint32), # single image width
        ('image_count', ctypes.c_uint32),  # number of images
        ('data_size', ctypes.c_uint32),    # data size
        ('encoding', ctypes.c_uint32),     # 0=raw BGR, 1=JPEG
        ('quality', ctypes.c_uint32),      # JPEG quality (valid if encoding=1)
    ]


class MultiImageWriter:
    """A simplified multi-image shared memory writer"""
    
    def __init__(self, shm_name: str = SHM_NAME, shm_size: int = SHM_SIZE, *, enable_jpeg: bool = False, jpeg_quality: int = 85, skip_cvtcolor: bool = False):
        """Initialize the multi-image shared memory writer
        
        Args:
            shm_name: the name of the shared memory
            shm_size: the size of the shared memory
        """
        self.shm_name = shm_name
        self.shm_size = shm_size
        
        # 50 FPS é™é€Ÿï¼ˆé¿å…é«˜é¢‘é˜»å¡ä¸»å¾ªç¯ï¼‰
        self._min_interval_sec = 1.0 / 50.0
        self._last_write_ts_ms = 0
        
        # å‹ç¼©ä¸é¢œè‰²ç©ºé—´é…ç½®ï¼ˆç”±ä¸»è¿›ç¨‹æ³¨å…¥ï¼‰
        self._enable_jpeg = bool(enable_jpeg)
        self._jpeg_quality = int(jpeg_quality)
        self._skip_cvtcolor = bool(skip_cvtcolor)
        
        try:
            # try to open the existing shared memory
            self.shm = shared_memory.SharedMemory(name=shm_name)
        except FileNotFoundError:
            # if not exist, create a new shared memory
            self.shm = shared_memory.SharedMemory(create=True, size=shm_size, name=shm_name)
        
        print(f"[MultiImageWriter] Shared memory initialized: {shm_name}")

    def set_options(self, *, enable_jpeg: Optional[bool] = None, jpeg_quality: Optional[int] = None, skip_cvtcolor: Optional[bool] = None):
        if enable_jpeg is not None:
            self._enable_jpeg = bool(enable_jpeg)
        if jpeg_quality is not None:
            self._jpeg_quality = int(jpeg_quality)
        if skip_cvtcolor is not None:
            self._skip_cvtcolor = bool(skip_cvtcolor)

    def write_images(self, images: Dict[str, np.ndarray]) -> bool:
        """Write multiple images to the shared memory (concatenate and write)
        
        Args:
            images: the image dictionary, the key is the image name ('head', 'left', 'right'), the value is the image array
            
        Returns:
            bool: whether the writing is successful
        """
        if not images or self.shm is None:
            return False
        
        # è½»é‡é™é€Ÿï¼šæœ€å¤š 50 FPSï¼Œç›´æ¥è·³è¿‡å¤šä½™å†™å…¥ï¼Œé¿å…é˜»å¡ä¸»å¾ªç¯
        now_ms = int(time.time() * 1000)
        if self._last_write_ts_ms and (now_ms - self._last_write_ts_ms) < int(self._min_interval_sec * 1000):
            return True
            
        try:
            # get the images in order: head, left, right
            frames_to_concat = []
            image_order = ['head', 'left', 'right']
            
            for image_name in image_order:
                if image_name in images:
                    image = images[image_name]
                    # ç¡®ä¿è¿ç»­å†…å­˜å¸ƒå±€ï¼Œå°½é‡å‡å°‘æ‹·è´
                    if not image.flags['C_CONTIGUOUS']:
                        image = np.ascontiguousarray(image)
                    # OpenCV æœŸæœ› BGR æ ¼å¼ï¼›å¯é€šè¿‡é…ç½®è·³è¿‡è½¬æ¢
                    if image.ndim == 3 and image.shape[2] == 3:
                        if not self._skip_cvtcolor:
                            image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
                    frames_to_concat.append(image)
            
            if not frames_to_concat:
                return False
            
            # ä½¿ç”¨ OpenCV çš„ C å®ç°è¿›è¡Œæ¨ªå‘æ‹¼æ¥ï¼ˆé€šå¸¸æ¯” numpy æ›´å¿«ä¸”æ›´ç¨³å®šï¼‰
            if len(frames_to_concat) > 1:
                concatenated_image = cv2.hconcat(frames_to_concat)
            else:
                concatenated_image = frames_to_concat[0]
            
            # get the image information
            height, total_width, channels = concatenated_image.shape
            single_width = total_width // len(frames_to_concat)

            # å‡†å¤‡å¤´éƒ¨
            header = SimpleImageHeader()
            header.timestamp = now_ms  # millisecond timestamp
            header.height = height
            header.width = total_width
            header.channels = channels
            header.single_width = single_width
            header.image_count = len(frames_to_concat)

            # å‹ç¼©æˆ–åŸå§‹å†™å…¥
            header_size = ctypes.sizeof(SimpleImageHeader)
            header_view = memoryview(self.shm.buf)
            data_view = memoryview(self.shm.buf)

            if self._enable_jpeg:
                encode_params = [int(cv2.IMWRITE_JPEG_QUALITY), int(self._jpeg_quality)]
                ok, buffer = cv2.imencode('.jpg', concatenated_image, encode_params)
                if not ok:
                    return False
                jpg_bytes = buffer.tobytes()
                header.encoding = 1
                header.quality = int(self._jpeg_quality)
                header.data_size = len(jpg_bytes)
                if header_size + header.data_size > self.shm_size:
                    print(f"[MultiImageWriter] JPEG data too large for SHM: {header.data_size} > {self.shm_size - header_size}")
                    return False
                # å†™å¤´
                header_bytes = ctypes.string_at(ctypes.byref(header), header_size)
                header_view[:header_size] = header_bytes
                # å†™æ•°æ®
                data_view[header_size:header_size + header.data_size] = jpg_bytes
            else:
                header.encoding = 0
                header.quality = 0
                raw_bytes = concatenated_image.tobytes()
                header.data_size = len(raw_bytes)
                if header_size + header.data_size > self.shm_size:
                    print(f"[MultiImageWriter] RAW data too large for SHM: {header.data_size} > {self.shm_size - header_size}")
                    return False
                header_bytes = ctypes.string_at(ctypes.byref(header), header_size)
                header_view[:header_size] = header_bytes
                data_view[header_size:header_size + header.data_size] = raw_bytes
            
            self._last_write_ts_ms = now_ms
            return True
            
        except Exception as e:
            print(f"shared_memory_utils [MultiImageWriter] Error writing to shared memory: {e}")
            print(f"Images: {list(images.keys())}")
            return False

    def close(self):
        """Close the shared memory"""
        if hasattr(self, 'shm') and self.shm is not None:
            self.shm.close()
            print(f"[MultiImageWriter] Shared memory closed: {self.shm_name}")


class MultiImageReader:
    """A simplified multi-image shared memory reader"""
    
    def __init__(self, shm_name: str = SHM_NAME):
        """Initialize the multi-image shared memory reader
        
        Args:
            shm_name: the name of the shared memory
        """
        self.shm_name = shm_name
        self.last_timestamp = 0
        self.buffer = {}
        
        try:
            # open the shared memory
            self.shm = shared_memory.SharedMemory(name=shm_name)
            print(f"[MultiImageReader] Shared memory opened: {shm_name}")
        except FileNotFoundError:
            print(f"[MultiImageReader] Shared memory {shm_name} not found")
            self.shm = None

    def _read_header(self) -> Optional[SimpleImageHeader]:
        if self.shm is None:
            return None
        header_size = ctypes.sizeof(SimpleImageHeader)
        header_data = bytes(self.shm.buf[:header_size])
        return SimpleImageHeader.from_buffer_copy(header_data)

    def read_images(self) -> Optional[Dict[str, np.ndarray]]:
        """Read multiple images from the shared memory (read the concatenated images and split them)
        
        Returns:
            Dict[str, np.ndarray]: the image dictionary, the key is the image name, the value is the image array; if the reading fails, return None
        """
        if self.shm is None:
            return None
            
        try:
            header = self._read_header()
            if header is None:
                return None
            # check if there is new data
            if header.timestamp <= self.last_timestamp:
                return self.buffer
                
            # read the payload
            header_size = ctypes.sizeof(SimpleImageHeader)
            start_offset = header_size
            end_offset = start_offset + header.data_size
            payload = bytes(self.shm.buf[start_offset:end_offset])

            # decode if needed
            if header.encoding == 1:  # JPEG
                encoded = np.frombuffer(payload, dtype=np.uint8)
                concatenated_image = cv2.imdecode(encoded, cv2.IMREAD_COLOR)
                if concatenated_image is None:
                    return None
            else:  # RAW
                concatenated_image = np.frombuffer(payload, dtype=np.uint8)
                expected_size = header.height * header.width * header.channels
                if concatenated_image.size != expected_size:
                    print(f"[MultiImageReader] Data size mismatch: expected {expected_size}, got {concatenated_image.size}")
                    return None
                concatenated_image = concatenated_image.reshape(header.height, header.width, header.channels)
            
            # split the images
            images = {}
            image_names = ['head', 'left', 'right']
            single_width = header.single_width
            
            for i in range(header.image_count):
                if i < len(image_names):
                    start_col = i * single_width
                    end_col = start_col + single_width
                    single_image = concatenated_image[:, start_col:end_col, :]
                    images[image_names[i]] = single_image
            
            # update the buffer and timestamp
            self.buffer = images
            self.last_timestamp = header.timestamp
            return images
            
        except Exception as e:
            print(f"[MultiImageReader] Error reading from shared memory: {e}")
            return None

    def read_concatenated_image(self) -> Optional[np.ndarray]:
        """Read the concatenated image (without splitting)
        
        Returns:
            np.ndarray: the concatenated image array; if the reading fails, return None
        """
        if self.shm is None:
            return None
            
        try:
            header = self._read_header()
            if header is None:
                return None
            if header.timestamp <= self.last_timestamp:
                return None
            header_size = ctypes.sizeof(SimpleImageHeader)
            start_offset = header_size
            end_offset = start_offset + header.data_size
            payload = bytes(self.shm.buf[start_offset:end_offset])

            if header.encoding == 1:
                encoded = np.frombuffer(payload, dtype=np.uint8)
                concatenated_image = cv2.imdecode(encoded, cv2.IMREAD_COLOR)
                if concatenated_image is None:
                    return None
            else:
                concatenated_image = np.frombuffer(payload, dtype=np.uint8)
                expected_size = header.height * header.width * header.channels
                if concatenated_image.size != expected_size:
                    print(f"[MultiImageReader] Data size mismatch: expected {expected_size}, got {concatenated_image.size}")
                    return None
                concatenated_image = concatenated_image.reshape(header.height, header.width, header.channels)
            
            self.last_timestamp = header.timestamp
            return concatenated_image
            
        except Exception as e:
            print(f"[MultiImageReader] Error reading concatenated image from shared memory: {e}")
            return None

    def read_encoded_frame(self) -> Optional[bytes]:
        """Read encoded payload if available (e.g., JPEG). Returns bytes or None."""
        if self.shm is None:
            return None
        try:
            header = self._read_header()
            if header is None or header.encoding != 1:
                return None
            if header.timestamp <= self.last_timestamp:
                return None
            header_size = ctypes.sizeof(SimpleImageHeader)
            start_offset = header_size
            end_offset = start_offset + header.data_size
            payload = bytes(self.shm.buf[start_offset:end_offset])
            self.last_timestamp = header.timestamp
            return payload
        except Exception as e:
            print(f"[MultiImageReader] Error reading encoded frame: {e}")
            return None

    def close(self):
        """Close the shared memory"""
        if self.shm is not None:
            self.shm.close()
            print(f"[MultiImageReader] Shared memory closed: {self.shm_name}")


# backward compatible class (single image)
class SharedMemoryWriter:
    """Backward compatible single image writer"""
    
    def __init__(self, shm_name: str = SHM_NAME, shm_size: int = SHM_SIZE):
        self.multi_writer = MultiImageWriter(shm_name, shm_size)
    
    def write_image(self, image: np.ndarray) -> bool:
        """Write a single image (as the head image)"""
        return self.multi_writer.write_images({'head': image})
    
    def close(self):
        self.multi_writer.close()


class SharedMemoryReader:
    """Backward compatible single image reader"""
    
    def __init__(self, shm_name: str = SHM_NAME):
        self.multi_reader = MultiImageReader(shm_name)
    
    def read_image(self) -> Optional[np.ndarray]:
        """Read a single image (the head image)"""
        images = self.multi_reader.read_images()
        return images.get('head') if images else None
    
    def close(self):
        self.multi_reader.close() 

===== layeredcontrol/robot_control_system.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
A layered robot control system
"""

import time
from typing import Optional, Dict, Any
import torch
from dataclasses import dataclass
from action_provider.action_base import ActionProvider


@dataclass
class ControlConfig:
    """minimal control configuration"""
    step_hz: int = 500  # the frequency of the low-level execution
    replay_mode: bool = False
    use_rl_action_mode: bool = False


class RobotController:
    """robot controller
    """
    
    def __init__(self, env, config: ControlConfig):
        self.env = env
        self.config = config
        self.action_provider: Optional[ActionProvider] = None
        self.is_running = False
        
        
        # minimal frequency control
        self._step_interval = 1.0 / config.step_hz
        self._last_step_time = 0.0
        
        all_joint_names = env.scene["robot"].data.joint_names
        self._last_action = torch.zeros(len(all_joint_names), device=env.device)
        
        
        # pre-calculate the sleep threshold (avoid calculating every time)
        self._sleep_threshold = 0.0002
        self._sleep_adjustment = 0.0001
        
        # minimal statistics
        self.step_count = 0
        self._start_time = 0.0
        
        # minimal performance analysis
        self._profile_counter = 0
        self._profile_interval = 2000  # reduce the printing frequency
        
        # cache the function reference (reduce the lookup overhead)
        self._perf_counter = time.perf_counter
        self._time_sleep = time.sleep
        
        print(f"  - control frequency: {config.step_hz}Hz")
    
    def set_action_provider(self, provider: ActionProvider):
        """set the action provider"""
        if self.action_provider:
            self.action_provider.stop()
            self.action_provider.cleanup()
        
        self.action_provider = provider
        print(f"[SimpleController] set the action provider: {provider.name}")
    
    def start(self):
        """start the controller"""
        if self.is_running:
            return
        
        self.is_running = True
        self._start_time = time.time()
        self._last_step_time = self._perf_counter()
        
        # start the action provider
        if self.action_provider:
            self.action_provider.start()
        
        print("[SimpleController] the controller is started")
    
    def stop(self):
        """stop the controller"""
        if not self.is_running:
            return
            
        self.is_running = False
        
        if self.action_provider:
            self.action_provider.stop()
        
        print("[SimpleController] the controller is stopped")
    
    def step(self):
        """minimal control step - zero thread competition"""
        if not self.is_running:
            return
        
        # use the cached function reference
        perf_counter = self._perf_counter
        step_start = perf_counter()
        
        # 1. minimal action acquisition (synchronous, zero thread competition, pre-calculated strategy)
        action_start = perf_counter()
        action = None
        
        # try to get the action from the action provider
        if self.action_provider:
            action = self.action_provider.get_action(self.env)
            if action is not None:
                self._last_action = action
        
        # if no action is obtained, use the pre-calculated fallback strategy
        if action is None:
            action = self._last_action

        action_time = perf_counter() - action_start
        
        # 2. direct environment step
        env_start = perf_counter()
        with torch.inference_mode():
            if self.config.replay_mode or self.config.use_rl_action_mode:
                pass
                # self.env.sim.render()
            else:
                self.env.step(action)
            env_time = perf_counter() - env_start
            
            self.step_count += 1
        
        # 3. minimal frequency control (no rendering overhead, use the pre-calculated threshold)
        sleep_start = perf_counter()
        current_time = perf_counter()
        if self._last_step_time > 0:
            elapsed = current_time - self._last_step_time
            sleep_needed = self._step_interval - elapsed
            if sleep_needed > self._sleep_threshold:  # use the pre-calculated threshold
                self._time_sleep(sleep_needed - self._sleep_adjustment)  # use the pre-calculated adjustment value
        self._last_step_time = current_time
        sleep_time = perf_counter() - sleep_start
        
        # 4. minimal performance print
        self._profile_counter += 1
        if self._profile_counter >= self._profile_interval:
            total_time = perf_counter() - step_start
            print(f"[Performance] A:{action_time*1000:.1f}ms, E:{env_time*1000:.1f}ms, S:{sleep_time*1000:.1f}ms, T:{total_time*1000:.1f}ms")
            self._profile_counter = 0
    def cleanup(self):
        """clean up the resources"""
        self.stop()
        if self.action_provider:
            self.action_provider.cleanup()
    
    def set_profiling(self, enabled: bool, interval: int = 2000):
        """set the performance analysis"""
        if enabled:
            self._profile_interval = interval
        else:
            self._profile_interval = 999999999  # actually disable the printing


===== lula_config.yaml =====

# The robot description defines the generalized coordinates and how to map those
# to the underlying URDF dofs.

api_version: 1.0

# Defines the generalized coordinates. Each generalized coordinate is assumed
# to have an entry in the URDF.
# Lula will only use these joints to control the robot position.
cspace:
    - left_shoulder_pitch_joint
    - right_shoulder_pitch_joint
    - left_shoulder_roll_joint
    - right_shoulder_roll_joint
    - left_shoulder_yaw_joint
    - right_shoulder_yaw_joint
    - left_elbow_joint
    - right_elbow_joint
    - left_wrist_roll_joint
    - right_wrist_roll_joint
    - left_wrist_pitch_joint
    - right_wrist_pitch_joint
    - left_wrist_yaw_joint
    - right_wrist_yaw_joint
default_q: [
    0.0296,0.0295,-0.0023,0.0026,0.0002,1e-04,0.0353,0.0354,-0.0002,0.0002,0.0141,0.0141,1e-04,-0.0
]

acceleration_limits: [
   10,10,10,10,10,10,10,10,10,10,10,10,10,10
]

jerk_limits: [
   10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000
]

# Most dimensions of the cspace have a direct corresponding element
# in the URDF. This list of rules defines how unspecified coordinates
# should be extracted or how values in the URDF should be overwritten.

cspace_to_urdf_rules:
    - {name: left_hip_pitch_joint, rule: fixed, value: 0.0097}
    - {name: right_hip_pitch_joint, rule: fixed, value: 0.0097}
    - {name: waist_yaw_joint, rule: fixed, value: -0.0}
    - {name: left_hip_roll_joint, rule: fixed, value: 0.0006}
    - {name: right_hip_roll_joint, rule: fixed, value: -0.0006}
    - {name: waist_roll_joint, rule: fixed, value: -0.0027}
    - {name: left_hip_yaw_joint, rule: fixed, value: -1e-04}
    - {name: right_hip_yaw_joint, rule: fixed, value: 1e-04}
    - {name: waist_pitch_joint, rule: fixed, value: 0.1269}
    - {name: left_knee_joint, rule: fixed, value: 0.0021}
    - {name: right_knee_joint, rule: fixed, value: 0.0021}
    - {name: left_ankle_pitch_joint, rule: fixed, value: 0.0007}
    - {name: right_ankle_pitch_joint, rule: fixed, value: 0.0007}
    - {name: left_ankle_roll_joint, rule: fixed, value: 0.0}
    - {name: right_ankle_roll_joint, rule: fixed, value: -0.0}
    - {name: left_hand_index_0_joint, rule: fixed, value: 0.0}
    - {name: left_hand_middle_0_joint, rule: fixed, value: 0.0}
    - {name: left_hand_thumb_0_joint, rule: fixed, value: -0.0}
    - {name: right_hand_index_0_joint, rule: fixed, value: -0.0}
    - {name: right_hand_middle_0_joint, rule: fixed, value: -0.0}
    - {name: right_hand_thumb_0_joint, rule: fixed, value: -0.0}
    - {name: left_hand_index_1_joint, rule: fixed, value: -0.0}
    - {name: left_hand_middle_1_joint, rule: fixed, value: 0.0}
    - {name: left_hand_thumb_1_joint, rule: fixed, value: 0.0002}
    - {name: right_hand_index_1_joint, rule: fixed, value: 0.0}
    - {name: right_hand_middle_1_joint, rule: fixed, value: -0.0}
    - {name: right_hand_thumb_1_joint, rule: fixed, value: -0.0002}
    - {name: left_hand_thumb_2_joint, rule: fixed, value: 0.0}
    - {name: right_hand_thumb_2_joint, rule: fixed, value: -0.0}

# Lula uses collision spheres to define the robot geometry in order to avoid
# collisions with external obstacles.  If no spheres are specified, Lula will
# not be able to avoid obstacles.

collision_spheres:


===== record_demos.py =====

# Copyright (c) 2022-2025, The Isaac Lab Project Developers (https://github.com/isaac-sim/IsaacLab/blob/main/CONTRIBUTORS.md).
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause
"""
Script to record demonstrations with Isaac Lab environments using human teleoperation.

This script allows users to record demonstrations operated by human teleoperation for a specified task.
The recorded demonstrations are stored as episodes in a hdf5 file. Users can specify the task, teleoperation
device, dataset directory, and environment stepping rate through command-line arguments.

required arguments:
    --task                    Name of the task.

optional arguments:
    -h, --help                Show this help message and exit
    --teleop_device           Device for interacting with environment. (default: keyboard)
    --dataset_file            File path to export recorded demos. (default: "./datasets/dataset.hdf5")
    --step_hz                 Environment stepping rate in Hz. (default: 30)
    --num_demos               Number of demonstrations to record. (default: 0)
    --num_success_steps       Number of continuous steps with task success for concluding a demo as successful. (default: 10)
"""

"""Launch Isaac Sim Simulator first."""

# Standard library imports
import argparse
import contextlib

# Isaac Lab AppLauncher
from isaaclab.app import AppLauncher

# add argparse arguments
parser = argparse.ArgumentParser(description="Record demonstrations for Isaac Lab environments.")
parser.add_argument("--task", type=str, required=True, help="Name of the task.")
parser.add_argument("--teleop_device", type=str, default="keyboard", help="Device for interacting with environment.")
parser.add_argument(
    "--dataset_file", type=str, default="./datasets/dataset.hdf5", help="File path to export recorded demos."
)
parser.add_argument("--step_hz", type=int, default=30, help="Environment stepping rate in Hz.")
parser.add_argument(
    "--num_demos", type=int, default=0, help="Number of demonstrations to record. Set to 0 for infinite."
)
parser.add_argument(
    "--num_success_steps",
    type=int,
    default=10,
    help="Number of continuous steps with task success for concluding a demo as successful. Default is 10.",
)
parser.add_argument(
    "--enable_pinocchio",
    action="store_true",
    default=False,
    help="Enable Pinocchio.",
)

# append AppLauncher cli args
AppLauncher.add_app_launcher_args(parser)
# parse the arguments
args_cli = parser.parse_args()

# Validate required arguments
if args_cli.task is None:
    parser.error("--task is required")

app_launcher_args = vars(args_cli)

if args_cli.enable_pinocchio:
    # Import pinocchio before AppLauncher to force the use of the version installed by IsaacLab and not the one installed by Isaac Sim
    # pinocchio is required by the Pink IK controllers and the GR1T2 retargeter
    import pinocchio  # noqa: F401
if "handtracking" in args_cli.teleop_device.lower():
    app_launcher_args["xr"] = True

# launch the simulator
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app

"""Rest everything follows."""


# Third-party imports
import gymnasium as gym
import os
import time
import torch

# Omniverse logger
import omni.log
import omni.ui as ui

from isaaclab.devices import Se3Keyboard, Se3KeyboardCfg, Se3SpaceMouse, Se3SpaceMouseCfg
from isaaclab.devices.openxr import remove_camera_configs
from isaaclab.devices.teleop_device_factory import create_teleop_device

import isaaclab_mimic.envs  # noqa: F401
from isaaclab_mimic.ui.instruction_display import InstructionDisplay, show_subtask_instructions

if args_cli.enable_pinocchio:
    import isaaclab_tasks.manager_based.manipulation.pick_place  # noqa: F401

from collections.abc import Callable

from isaaclab.envs import DirectRLEnvCfg, ManagerBasedRLEnvCfg
from isaaclab.envs.mdp.recorders.recorders_cfg import ActionStateRecorderManagerCfg
from isaaclab.envs.ui import EmptyWindow
from isaaclab.managers import DatasetExportMode

import tasks
from isaaclab_tasks.utils.parse_cfg import parse_env_cfg


class RateLimiter:
    """Convenience class for enforcing rates in loops."""

    def __init__(self, hz: int):
        """Initialize a RateLimiter with specified frequency.

        Args:
            hz: Frequency to enforce in Hertz.
        """
        self.hz = hz
        self.last_time = time.time()
        self.sleep_duration = 1.0 / hz
        self.render_period = min(0.033, self.sleep_duration)

    def sleep(self, env: gym.Env):
        """Attempt to sleep at the specified rate in hz.

        Args:
            env: Environment to render during sleep periods.
        """
        next_wakeup_time = self.last_time + self.sleep_duration
        while time.time() < next_wakeup_time:
            time.sleep(self.render_period)
            env.sim.render()

        self.last_time = self.last_time + self.sleep_duration

        # detect time jumping forwards (e.g. loop is too slow)
        if self.last_time < time.time():
            while self.last_time < time.time():
                self.last_time += self.sleep_duration


def setup_output_directories() -> tuple[str, str]:
    """Set up output directories for saving demonstrations.

    Creates the output directory if it doesn't exist and extracts the file name
    from the dataset file path.

    Returns:
        tuple[str, str]: A tuple containing:
            - output_dir: The directory path where the dataset will be saved
            - output_file_name: The filename (without extension) for the dataset
    """
    # get directory path and file name (without extension) from cli arguments
    output_dir = os.path.dirname(args_cli.dataset_file)
    output_file_name = os.path.splitext(os.path.basename(args_cli.dataset_file))[0]

    # create directory if it does not exist
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        print(f"Created output directory: {output_dir}")

    return output_dir, output_file_name


def create_environment_config(
    output_dir: str, output_file_name: str
) -> tuple[ManagerBasedRLEnvCfg | DirectRLEnvCfg, object | None]:
    """Create and configure the environment configuration.

    Parses the environment configuration and makes necessary adjustments for demo recording.
    Extracts the success termination function and configures the recorder manager.

    Args:
        output_dir: Directory where recorded demonstrations will be saved
        output_file_name: Name of the file to store the demonstrations

    Returns:
        tuple[isaaclab_tasks.utils.parse_cfg.EnvCfg, Optional[object]]: A tuple containing:
            - env_cfg: The configured environment configuration
            - success_term: The success termination object or None if not available

    Raises:
        Exception: If parsing the environment configuration fails
    """
    # parse configuration
    try:
        env_cfg = parse_env_cfg(args_cli.task, device=args_cli.device, num_envs=1)
        env_cfg.env_name = args_cli.task.split(":")[-1]
    except Exception as e:
        omni.log.error(f"Failed to parse environment configuration: {e}")
        exit(1)

    # extract success checking function to invoke in the main loop
    success_term = None
    if hasattr(env_cfg.terminations, "success"):
        success_term = env_cfg.terminations.success
        env_cfg.terminations.success = None
    else:
        omni.log.warn(
            "No success termination term was found in the environment."
            " Will not be able to mark recorded demos as successful."
        )

    if args_cli.xr:
        # If cameras are not enabled and XR is enabled, remove camera configs
        if not args_cli.enable_cameras:
            env_cfg = remove_camera_configs(env_cfg)
        env_cfg.sim.render.antialiasing_mode = "DLSS"

    # modify configuration such that the environment runs indefinitely until
    # the goal is reached or other termination conditions are met
    env_cfg.terminations.time_out = None
    env_cfg.observations.policy.concatenate_terms = False

    env_cfg.recorders: ActionStateRecorderManagerCfg = ActionStateRecorderManagerCfg()
    env_cfg.recorders.dataset_export_dir_path = output_dir
    env_cfg.recorders.dataset_filename = output_file_name
    env_cfg.recorders.dataset_export_mode = DatasetExportMode.EXPORT_SUCCEEDED_ONLY

    return env_cfg, success_term


def create_environment(env_cfg: ManagerBasedRLEnvCfg | DirectRLEnvCfg) -> gym.Env:
    """Create the environment from the configuration.

    Args:
        env_cfg: The environment configuration object that defines the environment properties.
            This should be an instance of EnvCfg created by parse_env_cfg().

    Returns:
        gym.Env: A Gymnasium environment instance for the specified task.

    Raises:
        Exception: If environment creation fails for any reason.
    """
    try:
        env = gym.make(args_cli.task, cfg=env_cfg).unwrapped
        return env
    except Exception as e:
        omni.log.error(f"Failed to create environment: {e}")
        exit(1)


def setup_teleop_device(callbacks: dict[str, Callable]) -> object:
    """Set up the teleoperation device based on configuration.

    Attempts to create a teleoperation device based on the environment configuration.
    Falls back to default devices if the specified device is not found in the configuration.

    Args:
        callbacks: Dictionary mapping callback keys to functions that will be
                   attached to the teleop device

    Returns:
        object: The configured teleoperation device interface

    Raises:
        Exception: If teleop device creation fails
    """
    teleop_interface = None
    try:
        if hasattr(env_cfg, "teleop_devices") and args_cli.teleop_device in env_cfg.teleop_devices.devices:
            teleop_interface = create_teleop_device(args_cli.teleop_device, env_cfg.teleop_devices.devices, callbacks)
        else:
            omni.log.warn(f"No teleop device '{args_cli.teleop_device}' found in environment config. Creating default.")
            # Create fallback teleop device
            if args_cli.teleop_device.lower() == "keyboard":
                teleop_interface = Se3Keyboard(Se3KeyboardCfg(pos_sensitivity=0.2, rot_sensitivity=0.5))
            elif args_cli.teleop_device.lower() == "spacemouse":
                teleop_interface = Se3SpaceMouse(Se3SpaceMouseCfg(pos_sensitivity=0.2, rot_sensitivity=0.5))
            else:
                omni.log.error(f"Unsupported teleop device: {args_cli.teleop_device}")
                omni.log.error("Supported devices: keyboard, spacemouse, handtracking")
                exit(1)

            # Add callbacks to fallback device
            for key, callback in callbacks.items():
                teleop_interface.add_callback(key, callback)
    except Exception as e:
        omni.log.error(f"Failed to create teleop device: {e}")
        exit(1)

    if teleop_interface is None:
        omni.log.error("Failed to create teleop interface")
        exit(1)

    return teleop_interface


def setup_ui(label_text: str, env: gym.Env) -> InstructionDisplay:
    """Set up the user interface elements.

    Creates instruction display and UI window with labels for showing information
    to the user during demonstration recording.

    Args:
        label_text: Text to display showing current recording status
        env: The environment instance for which UI is being created

    Returns:
        InstructionDisplay: The configured instruction display object
    """
    instruction_display = InstructionDisplay(args_cli.teleop_device)
    if not args_cli.xr:
        window = EmptyWindow(env, "Instruction")
        with window.ui_window_elements["main_vstack"]:
            demo_label = ui.Label(label_text)
            subtask_label = ui.Label("")
            instruction_display.set_labels(subtask_label, demo_label)

    return instruction_display


def process_success_condition(env: gym.Env, success_term: object | None, success_step_count: int) -> tuple[int, bool]:
    """Process the success condition for the current step.

    Checks if the environment has met the success condition for the required
    number of consecutive steps. Marks the episode as successful if criteria are met.

    Args:
        env: The environment instance to check
        success_term: The success termination object or None if not available
        success_step_count: Current count of consecutive successful steps

    Returns:
        tuple[int, bool]: A tuple containing:
            - updated success_step_count: The updated count of consecutive successful steps
            - success_reset_needed: Boolean indicating if reset is needed due to success
    """
    if success_term is None:
        return success_step_count, False

    if bool(success_term.func(env, **success_term.params)[0]):
        success_step_count += 1
        if success_step_count >= args_cli.num_success_steps:
            env.recorder_manager.record_pre_reset([0], force_export_or_skip=False)
            env.recorder_manager.set_success_to_episodes(
                [0], torch.tensor([[True]], dtype=torch.bool, device=env.device)
            )
            env.recorder_manager.export_episodes([0])
            print("Success condition met! Recording completed.")
            return success_step_count, True
    else:
        success_step_count = 0

    return success_step_count, False


def handle_reset(
    env: gym.Env, success_step_count: int, instruction_display: InstructionDisplay, label_text: str
) -> int:
    """Handle resetting the environment.

    Resets the environment, recorder manager, and related state variables.
    Updates the instruction display with current status.

    Args:
        env: The environment instance to reset
        success_step_count: Current count of consecutive successful steps
        instruction_display: The display object to update
        label_text: Text to display showing current recording status

    Returns:
        int: Reset success step count (0)
    """
    print("Resetting environment...")
    env.sim.reset()
    env.recorder_manager.reset()
    env.reset()
    success_step_count = 0
    instruction_display.show_demo(label_text)
    return success_step_count


def run_simulation_loop(
    env: gym.Env,
    teleop_interface: object | None,
    success_term: object | None,
    rate_limiter: RateLimiter | None,
) -> int:
    """Run the main simulation loop for collecting demonstrations.

    Sets up callback functions for teleop device, initializes the UI,
    and runs the main loop that processes user inputs and environment steps.
    Records demonstrations when success conditions are met.

    Args:
        env: The environment instance
        teleop_interface: Optional teleop interface (will be created if None)
        success_term: The success termination object or None if not available
        rate_limiter: Optional rate limiter to control simulation speed

    Returns:
        int: Number of successful demonstrations recorded
    """
    current_recorded_demo_count = 0
    success_step_count = 0
    should_reset_recording_instance = False
    running_recording_instance = not args_cli.xr

    # Callback closures for the teleop device
    def reset_recording_instance():
        nonlocal should_reset_recording_instance
        should_reset_recording_instance = True
        print("Recording instance reset requested")

    def start_recording_instance():
        nonlocal running_recording_instance
        running_recording_instance = True
        print("Recording started")

    def stop_recording_instance():
        nonlocal running_recording_instance
        running_recording_instance = False
        print("Recording paused")

    # Set up teleoperation callbacks
    teleoperation_callbacks = {
        "R": reset_recording_instance,
        "START": start_recording_instance,
        "STOP": stop_recording_instance,
        "RESET": reset_recording_instance,
    }

    teleop_interface = setup_teleop_device(teleoperation_callbacks)
    teleop_interface.add_callback("R", reset_recording_instance)

    # Reset before starting
    env.sim.reset()
    env.reset()
    teleop_interface.reset()

    label_text = f"Recorded {current_recorded_demo_count} successful demonstrations."
    instruction_display = setup_ui(label_text, env)

    subtasks = {}

    with contextlib.suppress(KeyboardInterrupt) and torch.inference_mode():
        while simulation_app.is_running():
            # Get keyboard command
            action = teleop_interface.advance()
            # Expand to batch dimension
            actions = action.repeat(env.num_envs, 1)

            # Perform action on environment
            if running_recording_instance:
                # Compute actions based on environment
                obv = env.step(actions)
                if subtasks is not None:
                    if subtasks == {}:
                        subtasks = obv[0].get("subtask_terms")
                    elif subtasks:
                        show_subtask_instructions(instruction_display, subtasks, obv, env.cfg)
            else:
                env.sim.render()

            # Check for success condition
            success_step_count, success_reset_needed = process_success_condition(env, success_term, success_step_count)
            if success_reset_needed:
                should_reset_recording_instance = True

            # Update demo count if it has changed
            if env.recorder_manager.exported_successful_episode_count > current_recorded_demo_count:
                current_recorded_demo_count = env.recorder_manager.exported_successful_episode_count
                label_text = f"Recorded {current_recorded_demo_count} successful demonstrations."
                print(label_text)

            # Handle reset if requested
            if should_reset_recording_instance:
                success_step_count = handle_reset(env, success_step_count, instruction_display, label_text)
                should_reset_recording_instance = False

            # Check if we've reached the desired number of demos
            if args_cli.num_demos > 0 and env.recorder_manager.exported_successful_episode_count >= args_cli.num_demos:
                print(f"All {args_cli.num_demos} demonstrations recorded. Exiting the app.")
                break

            # Check if simulation is stopped
            if env.sim.is_stopped():
                break

            # Rate limiting
            if rate_limiter:
                rate_limiter.sleep(env)

    return current_recorded_demo_count


def main() -> None:
    """Collect demonstrations from the environment using teleop interfaces.

    Main function that orchestrates the entire process:
    1. Sets up rate limiting based on configuration
    2. Creates output directories for saving demonstrations
    3. Configures the environment
    4. Runs the simulation loop to collect demonstrations
    5. Cleans up resources when done

    Raises:
        Exception: Propagates exceptions from any of the called functions
    """
    # if handtracking is selected, rate limiting is achieved via OpenXR
    if args_cli.xr:
        rate_limiter = None
    else:
        rate_limiter = RateLimiter(args_cli.step_hz)

    # Set up output directories
    output_dir, output_file_name = setup_output_directories()

    # Create and configure environment
    global env_cfg  # Make env_cfg available to setup_teleop_device
    env_cfg, success_term = create_environment_config(output_dir, output_file_name)

    # Create environment
    env = create_environment(env_cfg)

    # Run simulation loop
    current_recorded_demo_count = run_simulation_loop(env, None, success_term, rate_limiter)

    # Clean up
    env.close()
    print(f"Recording session completed with {current_recorded_demo_count} successful demonstrations")
    print(f"Demonstrations saved to: {args_cli.dataset_file}")


if __name__ == "__main__":
    # run the main function
    main()
    # close sim app
    simulation_app.close()


===== requirements.txt =====

rerun-sdk==0.20.1
pyzmq==27.0.0
logging_mp==0.1.5
onnxruntime==1.22.1
onnx
pynput==1.8.1

===== reset_pose_test.py =====

#!/usr/bin/env python3
"""
publish reset category command to rt/reset_pose/cmd
"""

import time
from unitree_sdk2py.core.channel import ChannelPublisher, ChannelFactoryInitialize
from unitree_sdk2py.idl.std_msgs.msg.dds_ import String_

def publish_reset_category(category: int,publisher):
    # construct message
    msg = String_(data=str(category))  # pass data parameter directly during initialization

    # create publisher

    # publish message
    publisher.Write(msg)
    print(f"published reset category: {category}")

if __name__ == "__main__":
    # initialize DDS
    ChannelFactoryInitialize(1)
    publisher = ChannelPublisher("rt/reset_pose/cmd", String_)
    publisher.Init()

    for cat in [1]:
        publish_reset_category(cat,publisher)
        time.sleep(1)  # wait for 1 second
    print("test publish completed")

===== robots/unitree.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""Configuration for Unitree robots."""

import isaaclab.sim as sim_utils
from isaaclab.actuators import ActuatorNetMLPCfg, DCMotorCfg, ImplicitActuatorCfg
from isaaclab.assets.articulation import ArticulationCfg
from isaaclab.utils.assets import ISAACLAB_NUCLEUS_DIR
import os
project_root = os.environ.get("PROJECT_ROOT")
G129_CFG_WITH_DEX3_BASE_FIX = ArticulationCfg(
    spawn=sim_utils.UsdFileCfg(
        usd_path=f"{project_root}/assets/robots/g1-29dof-dex3-base-fix-usd/g1_29dof_with_dex3_base_fix.usd",
        activate_contact_sensors=True,
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            disable_gravity=False,
            retain_accelerations=False,
            linear_damping=0.0,
            angular_damping=0.0,
            max_linear_velocity=1000.0,
            max_angular_velocity=1000.0,
            max_depenetration_velocity=1.0,
        ),
        articulation_props=sim_utils.ArticulationRootPropertiesCfg(
            enabled_self_collisions=False, 
            solver_position_iteration_count=8,
            solver_velocity_iteration_count=4,

        ),

    ),
    init_state=ArticulationCfg.InitialStateCfg(
        pos=(0.0, 0.0, 0.75),
        joint_pos={
            # legs joints
            "left_hip_yaw_joint": 0.0,
            "left_hip_roll_joint": 0.0,
            "left_hip_pitch_joint": -0.05,
            "left_knee_joint": 0.2,
            "left_ankle_pitch_joint": -0.15,
            "left_ankle_roll_joint": 0.0,
            
            "right_hip_yaw_joint": 0.0,
            "right_hip_roll_joint": 0.0,
            "right_hip_pitch_joint": -0.05,
            "right_knee_joint": 0.2,
            "right_ankle_pitch_joint": -0.15,
            "right_ankle_roll_joint": 0.0,
            
            # waist joints
            "waist_yaw_joint": 0.0,
            "waist_roll_joint": 0.0,
            "waist_pitch_joint": 0.0,
            
            # arms joints
            "left_shoulder_pitch_joint": 0.0,
            "left_shoulder_roll_joint": 0.0,
            "left_shoulder_yaw_joint": 0.0,
            "left_elbow_joint": 0.0,
            "left_wrist_roll_joint": 0.0,
            "left_wrist_pitch_joint": 0.0,
            "left_wrist_yaw_joint": 0.0,
            
            "right_shoulder_pitch_joint": 0.0,
            "right_shoulder_roll_joint": 0.0,
            "right_shoulder_yaw_joint": 0.0,
            "right_elbow_joint": 0.0,
            "right_wrist_roll_joint": 0.0,
            "right_wrist_pitch_joint": 0.0,
            "right_wrist_yaw_joint": 0.0,
            
            # fingers joints
            "left_hand_index_0_joint": 0.0,
            "left_hand_middle_0_joint": 0.0,
            "left_hand_thumb_0_joint": 0.0,
            "left_hand_index_1_joint": 0.0,
            "left_hand_middle_1_joint": 0.0,
            "left_hand_thumb_1_joint": 0.0,
            "left_hand_thumb_2_joint": 0.0,
            
            "right_hand_index_0_joint": 0.0,
            "right_hand_middle_0_joint": 0.0,
            "right_hand_thumb_0_joint": 0.0,
            "right_hand_index_1_joint": 0.0,
            "right_hand_middle_1_joint": 0.0,
            "right_hand_thumb_1_joint": 0.0,
            "right_hand_thumb_2_joint": 0.0,
        },
        joint_vel={".*": 0.0},
    ),
    soft_joint_pos_limit_factor=0.9,

    actuators={
        "legs": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_hip_yaw_joint", 
                ".*_hip_roll_joint",
                ".*_hip_pitch_joint", 
                ".*_knee_joint",
            ],
            effort_limit=None,
            velocity_limit=None,
            stiffness=None,
            damping=None,
            armature=None,
        ),
        "waist": ImplicitActuatorCfg(
            joint_names_expr=[
                "waist_yaw_joint",
                "waist_roll_joint",
                "waist_pitch_joint"
            ],  
            effort_limit=1000.0,  # set a large torque limit
            velocity_limit=0.0,   # set the velocity limit to 0
            stiffness={
                "waist_yaw_joint": 10000.0,
                "waist_roll_joint": 10000.0,
                "waist_pitch_joint": 10000.0
            },
            damping={
                "waist_yaw_joint": 10000.0,
                "waist_roll_joint": 10000.0,
                "waist_pitch_joint": 10000.0
            },
            armature=None,
        ),
        "feet": ImplicitActuatorCfg(
            effort_limit=None,
            joint_names_expr=[".*_ankle_pitch_joint", ".*_ankle_roll_joint"],
            stiffness=None,
            damping=None,
            # armature=0.001,
        ),
        "arms": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_shoulder_.*_joint",
                ".*_elbow_joint",
                ".*_wrist_.*_joint"
            ],
            effort_limit=None,
            velocity_limit=None,
             stiffness={  # increase the stiffness (kp)
                 ".*_shoulder_.*_joint": 300.0,
                 ".*_elbow_joint": 400.0,
                 ".*_wrist_.*_joint": 400.0,
            },
             damping={    # increase the damping (kd)
                 ".*_shoulder_.*_joint": 3.0,
                 ".*_elbow_joint": 2.5,
                 ".*_wrist_.*_joint": 2.5,
             },
            armature=None,
        ),
        "hands": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_hand_index_.*_joint",
                ".*_hand_middle_.*_joint",
                ".*_hand_thumb_.*_joint"
            ],
            effort_limit=300,
            velocity_limit=100.0,
            stiffness={
                ".*": 100.0,
            },
            damping={
                ".*": 10.0,
            },
            armature={
                ".*": 0.1
            },
        ),
    },
)




G129_CFG_WITH_DEX1_BASE_FIX = ArticulationCfg(
    spawn=sim_utils.UsdFileCfg(
        usd_path=f"{project_root}/assets/robots/g1-29dof-dex1-base-fix-usd/g1_29dof_with_dex1_base_fix1.usd",
        activate_contact_sensors=True,
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            disable_gravity=False,
            retain_accelerations=False,
            linear_damping=0.0,
            angular_damping=0.0,
            max_linear_velocity=1000.0,
            max_angular_velocity=1000.0,
            max_depenetration_velocity=1.0,
        ),
        articulation_props=sim_utils.ArticulationRootPropertiesCfg(
            enabled_self_collisions=False, 
            solver_position_iteration_count=8,
            solver_velocity_iteration_count=4
        ),

    ),
    init_state=ArticulationCfg.InitialStateCfg(
        pos=(0.0, 0.0, 0.75),
        joint_pos={
            # legs joints
            "left_hip_yaw_joint": 0.0,
            "left_hip_roll_joint": 0.0,
            "left_hip_pitch_joint": -0.05,
            "left_knee_joint": 0.2,
            "left_ankle_pitch_joint": -0.15,
            "left_ankle_roll_joint": 0.0,
            
            "right_hip_yaw_joint": 0.0,
            "right_hip_roll_joint": 0.0,
            "right_hip_pitch_joint": -0.05,
            "right_knee_joint": 0.2,
            "right_ankle_pitch_joint": -0.15,
            "right_ankle_roll_joint": 0.0,
            
            # waist joints
            "waist_yaw_joint": 0.0,
            "waist_roll_joint": 0.0,
            "waist_pitch_joint": 0.0,
            
            # arms joints
            "left_shoulder_pitch_joint": 0.0,
            "left_shoulder_roll_joint": 0.0,
            "left_shoulder_yaw_joint": 0.0,
            "left_elbow_joint": 0.0,
            "left_wrist_roll_joint": 0.0,
            "left_wrist_pitch_joint": 0.0,
            "left_wrist_yaw_joint": 0.0,
            
            "right_shoulder_pitch_joint": 0.0,
            "right_shoulder_roll_joint": 0.0,
            "right_shoulder_yaw_joint": 0.0,
            "right_elbow_joint": 0.0,
            "right_wrist_roll_joint": 0.0,
            "right_wrist_pitch_joint": 0.0,
            "right_wrist_yaw_joint": 0.0,
            
            # fingers joints
            "left_hand_Joint1_1": 0.0,
            "left_hand_Joint2_1": 0.0,
            "right_hand_Joint1_1": 0.0,
            "right_hand_Joint2_1": 0.0,
            
        },
        joint_vel={".*": 0.0},
    ),
    soft_joint_pos_limit_factor=0.9,
    actuators={
        "legs": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_hip_yaw_joint", 
                ".*_hip_roll_joint",
                ".*_hip_pitch_joint", 
                ".*_knee_joint",
            ],
            effort_limit=None,
            velocity_limit=None,
            stiffness=None,
            damping=None,
            armature=None,
        ),
        "waist": ImplicitActuatorCfg(
            joint_names_expr=[
                "waist_yaw_joint",
                "waist_roll_joint",
                "waist_pitch_joint"
            ],  
            effort_limit=1000.0,  # set a large torque limit
            velocity_limit=0.0,   # set the velocity limit to 0
            stiffness={
                "waist_yaw_joint": 10000.0,
                "waist_roll_joint": 10000.0,
                "waist_pitch_joint": 10000.0
            },
            damping={
                "waist_yaw_joint": 10000.0,
                "waist_roll_joint": 10000.0,
                "waist_pitch_joint": 10000.0
            },
            armature=None,
        ),
        "feet": ImplicitActuatorCfg(
            effort_limit=None,
            joint_names_expr=[".*_ankle_pitch_joint", ".*_ankle_roll_joint"],
            stiffness=None,
            damping=None,
            # armature=0.001,
        ),
        "arms": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_shoulder_.*_joint",
                ".*_elbow_joint",
                ".*_wrist_.*_joint"
            ],
            effort_limit=None,
            velocity_limit=None,
            stiffness={  # increase the stiffness (kp)
                 ".*_shoulder_.*_joint": 25.0,
                 ".*_elbow_joint": 50.0,
                 ".*_wrist_.*_joint": 40.0,
            },
             damping={    # increase the damping (kd)
                 ".*_shoulder_.*_joint": 2.0,
                 ".*_elbow_joint": 2.0,
                 ".*_wrist_.*_joint": 2.0,
             },
            armature=None,
        ),
        "hands": ImplicitActuatorCfg(
            joint_names_expr=[
                "left_hand_Joint1_1",
                "left_hand_Joint2_1",
                "right_hand_Joint1_1",
                "right_hand_Joint2_1",
            ],
            effort_limit=None,  # increase the torque limit
            velocity_limit=None,  # set the velocity limit to 0
            stiffness=800.0,    # increase the stiffness (kp)
            damping=3.0,        # increase the damping (kd)
            friction=200.0,
            armature=None,
        ),

    },
)



G129_CFG_WITH_INSPIRE_HAND = ArticulationCfg(
    spawn=sim_utils.UsdFileCfg(
        usd_path=f"{project_root}/assets/robots/g1-29dof-inspire-base-fix-usd/g1_29dof_with_inspire_rev_1_0.usd",
        activate_contact_sensors=True,
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            disable_gravity=False,
            retain_accelerations=False,
            linear_damping=0.0,
            angular_damping=0.0,
            max_linear_velocity=1000.0,
            max_angular_velocity=1000.0,
            max_depenetration_velocity=1.0,
        ),
        articulation_props=sim_utils.ArticulationRootPropertiesCfg(
            enabled_self_collisions=False, 
            solver_position_iteration_count=8,
            solver_velocity_iteration_count=4
        ),

    ),
    init_state=ArticulationCfg.InitialStateCfg(
        pos=(0.0, 0.0, 0.75),
        joint_pos={
            # legs joints
            "left_hip_yaw_joint": 0.0,
            "left_hip_roll_joint": 0.0,
            "left_hip_pitch_joint": -0.05,
            "left_knee_joint": 0.2,
            "left_ankle_pitch_joint": -0.15,
            "left_ankle_roll_joint": 0.0,
            
            "right_hip_yaw_joint": 0.0,
            "right_hip_roll_joint": 0.0,
            "right_hip_pitch_joint": -0.05,
            "right_knee_joint": 0.2,
            "right_ankle_pitch_joint": -0.15,
            "right_ankle_roll_joint": 0.0,
            
            # waist joints
            "waist_yaw_joint": 0.0,
            "waist_roll_joint": 0.0,
            "waist_pitch_joint": 0.0,
            
            # arms joints
            "left_shoulder_pitch_joint": 0.0,
            "left_shoulder_roll_joint": 0.0,
            "left_shoulder_yaw_joint": 0.0,
            "left_elbow_joint": 0.0,
            "left_wrist_roll_joint": 0.0,
            "left_wrist_pitch_joint": 0.0,
            "left_wrist_yaw_joint": 0.0,
            
            "right_shoulder_pitch_joint": 0.0,
            "right_shoulder_roll_joint": 0.0,
            "right_shoulder_yaw_joint": 0.0,
            "right_elbow_joint": 0.0,
            "right_wrist_roll_joint": 0.0,
            "right_wrist_pitch_joint": 0.0,
            "right_wrist_yaw_joint": 0.0,
            
            # fingers joints
            "L_index_proximal_joint": 0.0,
            "L_index_intermediate_joint": 0.0,
            "L_middle_proximal_joint": 0.0,
            "L_middle_intermediate_joint": 0.0,
            "L_pinky_proximal_joint":0.0,
            "L_pinky_intermediate_joint":0.0,
            "L_ring_proximal_joint":0.0,
            "L_ring_intermediate_joint":0.0,
            "L_thumb_proximal_yaw_joint":0.0,
            "L_thumb_proximal_pitch_joint":0.0,
            "L_thumb_intermediate_joint":0.0,
            "L_thumb_distal_joint":0.0,

            "R_index_proximal_joint": 0.0,
            "R_index_intermediate_joint": 0.0,
            "R_middle_proximal_joint": 0.0,
            "R_middle_intermediate_joint": 0.0,
            "R_pinky_proximal_joint":0.0,
            "R_pinky_intermediate_joint":0.0,
            "R_ring_proximal_joint":0.0,
            "R_ring_intermediate_joint":0.0,
            "R_thumb_proximal_yaw_joint":0.0,
            "R_thumb_proximal_pitch_joint":0.0,
            "R_thumb_intermediate_joint":0.0,
            "R_thumb_distal_joint":0.0,
        },
        joint_vel={".*": 0.0},
    ),
    soft_joint_pos_limit_factor=0.9,
    actuators={
        "legs": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_hip_yaw_joint", 
                ".*_hip_roll_joint",
                ".*_hip_pitch_joint", 
                ".*_knee_joint",
            ],
            effort_limit=None,
            velocity_limit=None,
            stiffness=None,
            damping=None,
            armature=None,
        ),
        "waist": ImplicitActuatorCfg(
            joint_names_expr=[
                "waist_yaw_joint",
                "waist_roll_joint",
                "waist_pitch_joint"
            ],  
            effort_limit=1000.0,  # set a large torque limit
            velocity_limit=0.0,   # set the velocity limit to 0
            stiffness={
                "waist_yaw_joint": 10000.0,
                "waist_roll_joint": 10000.0,
                "waist_pitch_joint": 10000.0
            },
            damping={
                "waist_yaw_joint": 10000.0,
                "waist_roll_joint": 10000.0,
                "waist_pitch_joint": 10000.0
            },
            armature=None,
        ),
        "feet": ImplicitActuatorCfg(
            effort_limit=None,
            joint_names_expr=[".*_ankle_pitch_joint", ".*_ankle_roll_joint"],
            stiffness=None,
            damping=None,
            # armature=0.001,
        ),
        "arms": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_shoulder_.*_joint",
                ".*_elbow_joint",
                ".*_wrist_.*_joint"
            ],
            effort_limit=None,
            velocity_limit=None,
             stiffness={  # increase the stiffness (kp)
                 ".*_shoulder_.*_joint": 25.0,
                 ".*_elbow_joint": 50.0,
                 ".*_wrist_.*_joint": 40.0,
            },
             damping={    # increase the damping (kd)
                 ".*_shoulder_.*_joint": 2.0,
                 ".*_elbow_joint": 2.0,
                 ".*_wrist_.*_joint": 2.0,
             },
            armature=None,
        ),
        "hands": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_index_proximal_joint",
                ".*_index_intermediate_joint",
                ".*_middle_proximal_joint",
                ".*_middle_intermediate_joint",
                ".*_pinky_proximal_joint",
                ".*_pinky_intermediate_joint",
                ".*_ring_proximal_joint",
                ".*_ring_intermediate_joint",
                ".*_thumb_proximal_yaw_joint",
                ".*_thumb_proximal_pitch_joint",
                ".*_thumb_intermediate_joint",
                ".*_thumb_distal_joint",
            ],
            effort_limit=100.0,
            velocity_limit=50,
            stiffness={
                ".*_index_proximal_joint":1000.0,
                ".*_index_intermediate_joint":1000.0,
                ".*_middle_proximal_joint":1000.0,
                ".*_middle_intermediate_joint":1000.0,
                ".*_pinky_proximal_joint":1000.0,
                ".*_pinky_intermediate_joint":1000.0,
                ".*_ring_proximal_joint":1000.0,
                ".*_ring_intermediate_joint":1000.0,
                ".*_thumb_proximal_yaw_joint":1000.0,
                ".*_thumb_proximal_pitch_joint":1000.0,
                ".*_thumb_intermediate_joint":1000.0,
                ".*_thumb_distal_joint":1000.0,
            },
            damping={
                ".*_index_proximal_joint":15,
                ".*_index_intermediate_joint":15,
                ".*_middle_proximal_joint":15,
                ".*_middle_intermediate_joint":15,
                ".*_pinky_proximal_joint":15,
                ".*_pinky_intermediate_joint":15,
                ".*_ring_proximal_joint":15,
                ".*_ring_intermediate_joint":15,
                ".*_thumb_proximal_yaw_joint":15,
                ".*_thumb_proximal_pitch_joint":15,
                ".*_thumb_intermediate_joint":15,
                ".*_thumb_distal_joint":15,
            },
            armature={
                ".*": 0.0
            },
        ),

    },
)




G129_CFG_WITH_DEX1_WHOLEBODY = ArticulationCfg(
    spawn=sim_utils.UsdFileCfg(
        usd_path=f"{project_root}/assets/robots/g1-29dof_wholebody_dex1/g1_29dof_with_dex1_rev_1_0.usd", #f"{project_root}/assets/robots/g1/g1.usd",
        activate_contact_sensors=True,
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            disable_gravity=False,
            retain_accelerations=False,
            linear_damping=0.0,
            angular_damping=0.0,
            max_linear_velocity=1000.0,
            max_angular_velocity=1000.0,
            max_depenetration_velocity=1.0,
        ),
        articulation_props=sim_utils.ArticulationRootPropertiesCfg(
            enabled_self_collisions=False, solver_position_iteration_count=4, solver_velocity_iteration_count=1
        ),
    ),
    init_state=ArticulationCfg.InitialStateCfg(
        pos=(0.0, 0.0, 0.80),
        joint_pos={
            ".*_hip_pitch_joint": -0.20,
            ".*_knee_joint": 0.42,
            ".*_ankle_pitch_joint": -0.23,
            ".*_elbow_joint": 0.87,
            "left_shoulder_roll_joint": 0.18,
            "left_shoulder_pitch_joint": 0.35,
            "right_shoulder_roll_joint": -0.18,
            "right_shoulder_pitch_joint": 0.35,
            # fingers joints
            "left_hand_Joint1_1": 0.024,
            "left_hand_Joint2_1": 0.024,
            "right_hand_Joint1_1": 0.024,
            "right_hand_Joint2_1": 0.024,

        },
        joint_vel={".*": 0.0},
    ),
    soft_joint_pos_limit_factor=0.90,
    actuators={
        "legs": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_hip_yaw_joint",
                ".*_hip_roll_joint",
                ".*_hip_pitch_joint",
                ".*_knee_joint",
                ".*waist.*",
            ],
            effort_limit_sim={
                ".*_hip_yaw_joint": 88.0,
                ".*_hip_roll_joint": 139.0,
                ".*_hip_pitch_joint": 88.0,
                ".*_knee_joint": 139.0,
                ".*waist_yaw_joint": 88.0,
                ".*waist_roll_joint": 35.0,
                ".*waist_pitch_joint": 35.0,
            },
            velocity_limit_sim={
                ".*_hip_yaw_joint": 32.0,
                ".*_hip_roll_joint": 20.0,
                ".*_hip_pitch_joint": 32.0,
                ".*_knee_joint": 20.0,
                ".*waist_yaw_joint": 32.0,
                ".*waist_roll_joint": 30.0,
                ".*waist_pitch_joint": 30.0,
            },
            stiffness={
                ".*_hip_yaw_joint": 150.0,
                ".*_hip_roll_joint": 150.0,
                ".*_hip_pitch_joint": 200.0,
                ".*_knee_joint": 200.0,
                ".*waist.*": 200.0,
            },
            damping={
                ".*_hip_yaw_joint": 5.0,
                ".*_hip_roll_joint": 5.0,
                ".*_hip_pitch_joint": 5.0,
                ".*_knee_joint": 5.0,
                ".*waist.*": 5.0,
            },
            armature=0.01,
        ),
        "feet": ImplicitActuatorCfg(
            joint_names_expr=[".*_ankle_pitch_joint", ".*_ankle_roll_joint"],
            effort_limit_sim={
                ".*_ankle_pitch_joint": 35.0,
                ".*_ankle_roll_joint": 35.0,
            },
            velocity_limit_sim={
                ".*_ankle_pitch_joint": 30.0,
                ".*_ankle_roll_joint": 30.0,
            },
            stiffness=20.0,
            damping=2.0,
            armature=0.01,
        ),
        "shoulders": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_shoulder_pitch_joint",
                ".*_shoulder_roll_joint",
            ],
            effort_limit_sim={
                ".*_shoulder_pitch_joint": 25.0,
                ".*_shoulder_roll_joint": 25.0,
            },
            velocity_limit_sim={
                ".*_shoulder_pitch_joint": 37.0,
                ".*_shoulder_roll_joint": 37.0,
            },
            stiffness=100.0,
            damping=2.0,
            armature=0.01,
        ),
        "arms": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_shoulder_yaw_joint",
                ".*_elbow_joint",
            ],
            effort_limit_sim={
                ".*_shoulder_yaw_joint": 25.0,
                ".*_elbow_joint": 25.0,
            },
            velocity_limit_sim={
                ".*_shoulder_yaw_joint": 37.0,
                ".*_elbow_joint": 37.0,
            },
            stiffness=50.0,
            damping=2.0,
            armature=0.01,
        ),
        "wrist": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_wrist_.*",
            ],
            effort_limit_sim={
                ".*_wrist_yaw_joint": 5.0,
                ".*_wrist_roll_joint": 25.0,
                ".*_wrist_pitch_joint": 5.0,
            },
            velocity_limit_sim={
                ".*_wrist_yaw_joint": 22.0,
                ".*_wrist_roll_joint": 37.0,
                ".*_wrist_pitch_joint": 22.0,
            },
            stiffness=40.0,
            damping=2.0,
            armature=0.01,
        ),
        "hands": ImplicitActuatorCfg(
            joint_names_expr=[
                "left_hand_Joint1_1",
                "left_hand_Joint2_1",
                "right_hand_Joint1_1",
                "right_hand_Joint2_1",
            ],
            effort_limit=None,  # increase the torque limit
            velocity_limit=None,  # set the velocity limit to 0
            stiffness=800.0,    # increase the stiffness (kp)
            damping=3.0,        # increase the damping (kd)
            friction=200.0,
            armature=None,
        ),
    },
)


G129_CFG_WITH_DEX3_WHOLEBODY = ArticulationCfg(
    spawn=sim_utils.UsdFileCfg(
        usd_path=f"{project_root}/assets/robots/g1-29dof_wholebody_dex3/g1_29dof_with_dex3_rev_1_0.usd", #f"{project_root}/assets/robots/g1/g1.usd",
        activate_contact_sensors=True,
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            disable_gravity=False,
            retain_accelerations=False,
            linear_damping=0.0,
            angular_damping=0.0,
            max_linear_velocity=1000.0,
            max_angular_velocity=1000.0,
            max_depenetration_velocity=1.0,
        ),
        articulation_props=sim_utils.ArticulationRootPropertiesCfg(
            enabled_self_collisions=False, solver_position_iteration_count=4, solver_velocity_iteration_count=1
        ),
    ),
    init_state=ArticulationCfg.InitialStateCfg(
        pos=(0.0, 0.0, 0.80),
        joint_pos={
            ".*_hip_pitch_joint": -0.20,
            ".*_knee_joint": 0.42,
            ".*_ankle_pitch_joint": -0.23,
            ".*_elbow_joint": 0.87,
            "left_shoulder_roll_joint": 0.18,
            "left_shoulder_pitch_joint": 0.35,
            "right_shoulder_roll_joint": -0.18,
            "right_shoulder_pitch_joint": 0.35,
       
            # fingers joints
            "left_hand_index_0_joint": 0.0,
            "left_hand_middle_0_joint": 0.0,
            "left_hand_thumb_0_joint": 0.0,
            "left_hand_index_1_joint": 0.0,
            "left_hand_middle_1_joint": 0.0,
            "left_hand_thumb_1_joint": 0.0,
            "left_hand_thumb_2_joint": 0.0,
            
            "right_hand_index_0_joint": 0.0,
            "right_hand_middle_0_joint": 0.0,
            "right_hand_thumb_0_joint": 0.0,
            "right_hand_index_1_joint": 0.0,
            "right_hand_middle_1_joint": 0.0,
            "right_hand_thumb_1_joint": 0.0,
            "right_hand_thumb_2_joint": 0.0,

        },
        joint_vel={".*": 0.0},
    ),
    soft_joint_pos_limit_factor=0.90,
    actuators={
        "legs": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_hip_yaw_joint",
                ".*_hip_roll_joint",
                ".*_hip_pitch_joint",
                ".*_knee_joint",
                ".*waist.*",
            ],
            effort_limit_sim={
                ".*_hip_yaw_joint": 88.0,
                ".*_hip_roll_joint": 139.0,
                ".*_hip_pitch_joint": 88.0,
                ".*_knee_joint": 139.0,
                ".*waist_yaw_joint": 88.0,
                ".*waist_roll_joint": 35.0,
                ".*waist_pitch_joint": 35.0,
            },
            velocity_limit_sim={
                ".*_hip_yaw_joint": 32.0,
                ".*_hip_roll_joint": 20.0,
                ".*_hip_pitch_joint": 32.0,
                ".*_knee_joint": 20.0,
                ".*waist_yaw_joint": 32.0,
                ".*waist_roll_joint": 30.0,
                ".*waist_pitch_joint": 30.0,
            },
            stiffness={
                ".*_hip_yaw_joint": 150.0,
                ".*_hip_roll_joint": 150.0,
                ".*_hip_pitch_joint": 200.0,
                ".*_knee_joint": 200.0,
                ".*waist.*": 200.0,
            },
            damping={
                ".*_hip_yaw_joint": 5.0,
                ".*_hip_roll_joint": 5.0,
                ".*_hip_pitch_joint": 5.0,
                ".*_knee_joint": 5.0,
                ".*waist.*": 5.0,
            },
            armature=0.01,
        ),
        "feet": ImplicitActuatorCfg(
            joint_names_expr=[".*_ankle_pitch_joint", ".*_ankle_roll_joint"],
            effort_limit_sim={
                ".*_ankle_pitch_joint": 35.0,
                ".*_ankle_roll_joint": 35.0,
            },
            velocity_limit_sim={
                ".*_ankle_pitch_joint": 30.0,
                ".*_ankle_roll_joint": 30.0,
            },
            stiffness=20.0,
            damping=2.0,
            armature=0.01,
        ),
        "shoulders": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_shoulder_pitch_joint",
                ".*_shoulder_roll_joint",
            ],
            effort_limit_sim={
                ".*_shoulder_pitch_joint": 25.0,
                ".*_shoulder_roll_joint": 25.0,
            },
            velocity_limit_sim={
                ".*_shoulder_pitch_joint": 37.0,
                ".*_shoulder_roll_joint": 37.0,
            },
            stiffness=100.0,
            damping=2.0,
            armature=0.01,
        ),
        "arms": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_shoulder_yaw_joint",
                ".*_elbow_joint",
            ],
            effort_limit_sim={
                ".*_shoulder_yaw_joint": 25.0,
                ".*_elbow_joint": 25.0,
            },
            velocity_limit_sim={
                ".*_shoulder_yaw_joint": 37.0,
                ".*_elbow_joint": 37.0,
            },
            stiffness=50.0,
            damping=2.0,
            armature=0.01,
        ),
        "wrist": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_wrist_.*",
            ],
            effort_limit_sim={
                ".*_wrist_yaw_joint": 5.0,
                ".*_wrist_roll_joint": 25.0,
                ".*_wrist_pitch_joint": 5.0,
            },
            velocity_limit_sim={
                ".*_wrist_yaw_joint": 22.0,
                ".*_wrist_roll_joint": 37.0,
                ".*_wrist_pitch_joint": 22.0,
            },
            stiffness=40.0,
            damping=2.0,
            armature=0.01,
        ),
        "hands": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_hand_index_.*_joint",
                ".*_hand_middle_.*_joint",
                ".*_hand_thumb_.*_joint"
            ],
            effort_limit=300,
            velocity_limit=100.0,
            stiffness={
                ".*": 100.0,
            },
            damping={
                ".*": 10.0,
            },
            armature={
                ".*": 0.1
            },
        ),
    },
)


G129_CFG_WITH_INSPIRE_WHOLEBODY = ArticulationCfg(
    spawn=sim_utils.UsdFileCfg(
        usd_path=f"{project_root}/assets/robots/g1-29dof_wholebody_inspire/g1_29dof_with_inspire_rev_1_0.usd", #f"{project_root}/assets/robots/g1/g1.usd",
        activate_contact_sensors=True,
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            disable_gravity=False,
            retain_accelerations=False,
            linear_damping=0.0,
            angular_damping=0.0,
            max_linear_velocity=1000.0,
            max_angular_velocity=1000.0,
            max_depenetration_velocity=1.0,
        ),
        articulation_props=sim_utils.ArticulationRootPropertiesCfg(
            enabled_self_collisions=False, solver_position_iteration_count=4, solver_velocity_iteration_count=1
        ),
    ),
    init_state=ArticulationCfg.InitialStateCfg(
        pos=(0.0, 0.0, 0.80),
        joint_pos={
            ".*_hip_pitch_joint": -0.20,
            ".*_knee_joint": 0.42,
            ".*_ankle_pitch_joint": -0.23,
            ".*_elbow_joint": 0.87,
            "left_shoulder_roll_joint": 0.18,
            "left_shoulder_pitch_joint": 0.35,
            "right_shoulder_roll_joint": -0.18,
            "right_shoulder_pitch_joint": 0.35,

            
            # fingers joints
            "L_index_proximal_joint": 0.0,
            "L_index_intermediate_joint": 0.0,
            "L_middle_proximal_joint": 0.0,
            "L_middle_intermediate_joint": 0.0,
            "L_pinky_proximal_joint":0.0,
            "L_pinky_intermediate_joint":0.0,
            "L_ring_proximal_joint":0.0,
            "L_ring_intermediate_joint":0.0,
            "L_thumb_proximal_yaw_joint":0.0,
            "L_thumb_proximal_pitch_joint":0.0,
            "L_thumb_intermediate_joint":0.0,
            "L_thumb_distal_joint":0.0,

            "R_index_proximal_joint": 0.0,
            "R_index_intermediate_joint": 0.0,
            "R_middle_proximal_joint": 0.0,
            "R_middle_intermediate_joint": 0.0,
            "R_pinky_proximal_joint":0.0,
            "R_pinky_intermediate_joint":0.0,
            "R_ring_proximal_joint":0.0,
            "R_ring_intermediate_joint":0.0,
            "R_thumb_proximal_yaw_joint":0.0,
            "R_thumb_proximal_pitch_joint":0.0,
            "R_thumb_intermediate_joint":0.0,
            "R_thumb_distal_joint":0.0,

        },
        joint_vel={".*": 0.0},
    ),
    soft_joint_pos_limit_factor=0.90,
    actuators={
        "legs": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_hip_yaw_joint",
                ".*_hip_roll_joint",
                ".*_hip_pitch_joint",
                ".*_knee_joint",
                ".*waist.*",
            ],
            effort_limit_sim={
                ".*_hip_yaw_joint": 88.0,
                ".*_hip_roll_joint": 139.0,
                ".*_hip_pitch_joint": 88.0,
                ".*_knee_joint": 139.0,
                ".*waist_yaw_joint": 88.0,
                ".*waist_roll_joint": 35.0,
                ".*waist_pitch_joint": 35.0,
            },
            velocity_limit_sim={
                ".*_hip_yaw_joint": 32.0,
                ".*_hip_roll_joint": 20.0,
                ".*_hip_pitch_joint": 32.0,
                ".*_knee_joint": 20.0,
                ".*waist_yaw_joint": 32.0,
                ".*waist_roll_joint": 30.0,
                ".*waist_pitch_joint": 30.0,
            },
            stiffness={
                ".*_hip_yaw_joint": 150.0,
                ".*_hip_roll_joint": 150.0,
                ".*_hip_pitch_joint": 200.0,
                ".*_knee_joint": 200.0,
                ".*waist.*": 200.0,
            },
            damping={
                ".*_hip_yaw_joint": 5.0,
                ".*_hip_roll_joint": 5.0,
                ".*_hip_pitch_joint": 5.0,
                ".*_knee_joint": 5.0,
                ".*waist.*": 5.0,
            },
            armature=0.01,
        ),
        "feet": ImplicitActuatorCfg(
            joint_names_expr=[".*_ankle_pitch_joint", ".*_ankle_roll_joint"],
            effort_limit_sim={
                ".*_ankle_pitch_joint": 35.0,
                ".*_ankle_roll_joint": 35.0,
            },
            velocity_limit_sim={
                ".*_ankle_pitch_joint": 30.0,
                ".*_ankle_roll_joint": 30.0,
            },
            stiffness=20.0,
            damping=2.0,
            armature=0.01,
        ),
        "shoulders": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_shoulder_pitch_joint",
                ".*_shoulder_roll_joint",
            ],
            effort_limit_sim={
                ".*_shoulder_pitch_joint": 25.0,
                ".*_shoulder_roll_joint": 25.0,
            },
            velocity_limit_sim={
                ".*_shoulder_pitch_joint": 37.0,
                ".*_shoulder_roll_joint": 37.0,
            },
            stiffness=100.0,
            damping=2.0,
            armature=0.01,
        ),
        "arms": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_shoulder_yaw_joint",
                ".*_elbow_joint",
            ],
            effort_limit_sim={
                ".*_shoulder_yaw_joint": 25.0,
                ".*_elbow_joint": 25.0,
            },
            velocity_limit_sim={
                ".*_shoulder_yaw_joint": 37.0,
                ".*_elbow_joint": 37.0,
            },
            stiffness=50.0,
            damping=2.0,
            armature=0.01,
        ),
        "wrist": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_wrist_.*",
            ],
            effort_limit_sim={
                ".*_wrist_yaw_joint": 5.0,
                ".*_wrist_roll_joint": 25.0,
                ".*_wrist_pitch_joint": 5.0,
            },
            velocity_limit_sim={
                ".*_wrist_yaw_joint": 22.0,
                ".*_wrist_roll_joint": 37.0,
                ".*_wrist_pitch_joint": 22.0,
            },
            stiffness=40.0,
            damping=2.0,
            armature=0.01,
        ),
        "hands": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_index_proximal_joint",
                ".*_index_intermediate_joint",
                ".*_middle_proximal_joint",
                ".*_middle_intermediate_joint",
                ".*_pinky_proximal_joint",
                ".*_pinky_intermediate_joint",
                ".*_ring_proximal_joint",
                ".*_ring_intermediate_joint",
                ".*_thumb_proximal_yaw_joint",
                ".*_thumb_proximal_pitch_joint",
                ".*_thumb_intermediate_joint",
                ".*_thumb_distal_joint",
            ],
            effort_limit=100.0,
            velocity_limit=50,
            stiffness={
                ".*_index_proximal_joint":1000.0,
                ".*_index_intermediate_joint":1000.0,
                ".*_middle_proximal_joint":1000.0,
                ".*_middle_intermediate_joint":1000.0,
                ".*_pinky_proximal_joint":1000.0,
                ".*_pinky_intermediate_joint":1000.0,
                ".*_ring_proximal_joint":1000.0,
                ".*_ring_intermediate_joint":1000.0,
                ".*_thumb_proximal_yaw_joint":1000.0,
                ".*_thumb_proximal_pitch_joint":1000.0,
                ".*_thumb_intermediate_joint":1000.0,
                ".*_thumb_distal_joint":1000.0,
            },
            damping={
                ".*_index_proximal_joint":15,
                ".*_index_intermediate_joint":15,
                ".*_middle_proximal_joint":15,
                ".*_middle_intermediate_joint":15,
                ".*_pinky_proximal_joint":15,
                ".*_pinky_intermediate_joint":15,
                ".*_ring_proximal_joint":15,
                ".*_ring_intermediate_joint":15,
                ".*_thumb_proximal_yaw_joint":15,
                ".*_thumb_proximal_pitch_joint":15,
                ".*_thumb_intermediate_joint":15,
                ".*_thumb_distal_joint":15,
            },
            armature={
                ".*": 0.0
            },
        ),
    },
)






H12_CFG_WITH_INSPIRE_HAND = ArticulationCfg(
    spawn=sim_utils.UsdFileCfg(
        usd_path=f"{project_root}/assets/robots/h1_2-26dof-inspire-base-fix-usd/h1_2_26dof_with_inspire_rev_1_0.usd",
        activate_contact_sensors=True,
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            disable_gravity=False,
            retain_accelerations=False,
            linear_damping=0.0,
            angular_damping=0.0,
            max_linear_velocity=1000.0,
            max_angular_velocity=1000.0,
            max_depenetration_velocity=1.0,
        ),
        articulation_props=sim_utils.ArticulationRootPropertiesCfg(
            enabled_self_collisions=False, 
            solver_position_iteration_count=8,
            solver_velocity_iteration_count=4
        ),

    ),
    init_state=ArticulationCfg.InitialStateCfg(
        pos=(0.0, 0.0, 0.75),
        joint_pos={
            # legs joints
            "left_hip_yaw_joint": 0.0,
            "left_hip_roll_joint": 0.0,
            "left_hip_pitch_joint": -0.05,
            "left_knee_joint": 0.2,
            "left_ankle_pitch_joint": -0.15,
            "left_ankle_roll_joint": 0.0,
            
            "right_hip_yaw_joint": 0.0,
            "right_hip_roll_joint": 0.0,
            "right_hip_pitch_joint": -0.05,
            "right_knee_joint": 0.2,
            "right_ankle_pitch_joint": -0.15,
            "right_ankle_roll_joint": 0.0,
            
            
            # arms joints
            "left_shoulder_pitch_joint": 0.0,
            "left_shoulder_roll_joint": 0.0,
            "left_shoulder_yaw_joint": 0.0,
            "left_elbow_joint": 0.0,
            "left_wrist_roll_joint": 0.0,
            "left_wrist_pitch_joint": 0.0,
            "left_wrist_yaw_joint": 0.0,
            
            "right_shoulder_pitch_joint": 0.0,
            "right_shoulder_roll_joint": 0.0,
            "right_shoulder_yaw_joint": 0.0,
            "right_elbow_joint": 0.0,
            "right_wrist_roll_joint": 0.0,
            "right_wrist_pitch_joint": 0.0,
            "right_wrist_yaw_joint": 0.0,
            
            # fingers joints
            "L_index_proximal_joint": 0.0,
            "L_index_intermediate_joint": 0.0,
            "L_middle_proximal_joint": 0.0,
            "L_middle_intermediate_joint": 0.0,
            "L_pinky_proximal_joint":0.0,
            "L_pinky_intermediate_joint":0.0,
            "L_ring_proximal_joint":0.0,
            "L_ring_intermediate_joint":0.0,
            "L_thumb_proximal_yaw_joint":0.0,
            "L_thumb_proximal_pitch_joint":0.0,
            "L_thumb_intermediate_joint":0.0,
            "L_thumb_distal_joint":0.0,

            "R_index_proximal_joint": 0.0,
            "R_index_intermediate_joint": 0.0,
            "R_middle_proximal_joint": 0.0,
            "R_middle_intermediate_joint": 0.0,
            "R_pinky_proximal_joint":0.0,
            "R_pinky_intermediate_joint":0.0,
            "R_ring_proximal_joint":0.0,
            "R_ring_intermediate_joint":0.0,
            "R_thumb_proximal_yaw_joint":0.0,
            "R_thumb_proximal_pitch_joint":0.0,
            "R_thumb_intermediate_joint":0.0,
            "R_thumb_distal_joint":0.0,
        },
        joint_vel={".*": 0.0},
    ),
    soft_joint_pos_limit_factor=0.9,
    actuators={
        "legs": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_hip_yaw_joint", 
                ".*_hip_roll_joint",
                ".*_hip_pitch_joint", 
                ".*_knee_joint",
            ],
            effort_limit=None,
            velocity_limit=None,
            stiffness=None,
            damping=None,
            armature=None,
        ),
        "feet": ImplicitActuatorCfg(
            effort_limit=None,
            joint_names_expr=[".*_ankle_pitch_joint", ".*_ankle_roll_joint"],
            stiffness=None,
            damping=None,
            # armature=0.001,
        ),
        "arms": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_shoulder_.*_joint",
                ".*_elbow_joint",
                ".*_wrist_.*_joint"
            ],
            effort_limit=None,
            velocity_limit=None,
             stiffness={  # increase the stiffness (kp)
                 ".*_shoulder_.*_joint": 25.0,
                 ".*_elbow_joint": 50.0,
                 ".*_wrist_.*_joint": 40.0,
            },
             damping={    # increase the damping (kd)
                 ".*_shoulder_.*_joint": 2.0,
                 ".*_elbow_joint": 2.0,
                 ".*_wrist_.*_joint": 2.0,
             },
            armature=None,
        ),
        "hands": ImplicitActuatorCfg(
            joint_names_expr=[
                ".*_index_proximal_joint",
                ".*_index_intermediate_joint",
                ".*_middle_proximal_joint",
                ".*_middle_intermediate_joint",
                ".*_pinky_proximal_joint",
                ".*_pinky_intermediate_joint",
                ".*_ring_proximal_joint",
                ".*_ring_intermediate_joint",
                ".*_thumb_proximal_yaw_joint",
                ".*_thumb_proximal_pitch_joint",
                ".*_thumb_intermediate_joint",
                ".*_thumb_distal_joint",
            ],
            effort_limit=100.0,
            velocity_limit=50,
            stiffness={
                ".*_index_proximal_joint":1000.0,
                ".*_index_intermediate_joint":1000.0,
                ".*_middle_proximal_joint":1000.0,
                ".*_middle_intermediate_joint":1000.0,
                ".*_pinky_proximal_joint":1000.0,
                ".*_pinky_intermediate_joint":1000.0,
                ".*_ring_proximal_joint":1000.0,
                ".*_ring_intermediate_joint":1000.0,
                ".*_thumb_proximal_yaw_joint":1000.0,
                ".*_thumb_proximal_pitch_joint":1000.0,
                ".*_thumb_intermediate_joint":1000.0,
                ".*_thumb_distal_joint":1000.0,
            },
            damping={
                ".*_index_proximal_joint":15,
                ".*_index_intermediate_joint":15,
                ".*_middle_proximal_joint":15,
                ".*_middle_intermediate_joint":15,
                ".*_pinky_proximal_joint":15,
                ".*_pinky_intermediate_joint":15,
                ".*_ring_proximal_joint":15,
                ".*_ring_intermediate_joint":15,
                ".*_thumb_proximal_yaw_joint":15,
                ".*_thumb_proximal_pitch_joint":15,
                ".*_thumb_intermediate_joint":15,
                ".*_thumb_distal_joint":15,
            },
            armature={
                ".*": 0.0
            },
        ),

    },
)

===== send_commands_8bit.py =====

#!/usr/bin/env python3
"""
publish reset category command to rt/reset_pose/cmd
"""

import time
from unitree_sdk2py.core.channel import ChannelPublisher, ChannelFactoryInitialize
from unitree_sdk2py.idl.std_msgs.msg.dds_ import String_

import threading
import math
import numpy as np
import time
from evdev import InputDevice, categorize, ecodes, list_devices

# *********
# Left stick up/down controls robot forward/backward movement
# Left stick left/right controls robot left/right movement
# Right stick up/down controls robot crouch
# Right stick left/right controls robot rotation
# *********

class LowPassFilter:
    def __init__(self, alpha=0.15):
        self.alpha = alpha
        self._value = 0.0
        self._last_value = 0.0

    def update(self, new_value, max_accel=1.5):
        delta = new_value - self._last_value
        delta = np.clip(delta, -max_accel, max_accel)
        filtered = self.alpha * (self._last_value + delta) + (1 - self.alpha) * self._value
        self._last_value = filtered
        self._value = filtered
        return self._value


class GamepadController:
    def __init__(self):
        self.control_params = {
            'x_vel': 0.0,
            'y_vel': 0.0,
            'yaw_vel': 0.0,
            'height': 0.0
        }
        self.axis_state = {
            ecodes.ABS_X: 0,
            ecodes.ABS_Y: 0,
            ecodes.ABS_RX: 0,
            ecodes.ABS_RY: 0
        }
        self.param_lock = threading.Lock()

        self._filters = {
            'x_vel': LowPassFilter(alpha=0.15),
            'y_vel': LowPassFilter(alpha=0.15),
            'yaw_vel': LowPassFilter(alpha=0.15),
            'height': LowPassFilter(alpha=0.15)
        }

        self._last_active_time = {
            'x_vel': time.time(),
            'y_vel': time.time(),
            'yaw_vel': time.time(),
            'height': time.time()
        }

        self._default_values = {
            'x_vel': 0.0,
            'y_vel': 0.0,
            'yaw_vel': 0.0,
            'height': 0.0
        }

        self._timeout_secs = 0.3
        self._debug_count = 0

        self._button_states = {}  # BTN_A: True/False

        # Start threads
        self._listener_thread = threading.Thread(target=self._gamepad_listener)
        self._listener_thread.daemon = True
        self._listener_thread.start()

        self._recovery_thread = threading.Thread(target=self._recover_inactive_axes)
        self._recovery_thread.daemon = True
        self._recovery_thread.start()
        
        for name, code in ecodes.ecodes.items():
            print(f"{name}: {code}")
        gamepad = None
        devices = [InputDevice(path) for path in list_devices()]
        for dev in devices:
            if "8BitDo" in dev.name:  # 
                gamepad = dev
                break
        for code in gamepad.capabilities().get(ecodes.EV_ABS, []):
            axis_name = ecodes.ABS[code[0]]
            abs_info = gamepad.absinfo(code[0])
            print(f"{axis_name}: min={abs_info.min}, max={abs_info.max}, fuzz={abs_info.fuzz}, flat={abs_info.flat}, resolution={abs_info.resolution}")
    
    def _map_axis_with_deadzone(self, value, deadzone=0.05, output_min=-1.0, output_max=1.0):
        """
        Map the joystick axis value to the specified range, considering the dead zone
        
        Args:
            value: original axis value (-32768 to 32767)
            deadzone: dead zone ratio (0.0 to 1.0)
            output_min: output minimum value
            output_max: output maximum value
            
        Returns:
            mapped value
        """
    
        normalized = value / 32768.0
        
        # apply dead zone
        if abs(normalized) < deadzone:
            return 0.0
        
        # remap the value outside the dead zone
        if normalized > 0:
            # positive value: map from deadzone to 1, then linearly map to [0, output_max]
            t = (normalized - deadzone) / (1.0 - deadzone)
            smooth = 6*t**5 - 15*t**4 + 10*t**3  # smooth curve
            return output_max * smooth
        else:
            # negative value: map from -deadzone to -1, then linearly map to [output_min, 0]
            t = (-normalized - deadzone) / (1.0 - deadzone)
            smooth = 6*t**5 - 15*t**4 + 10*t**3  # smooth curve
            return output_min * smooth

    def _map_forward_velocity(self, value):
        """map forward velocity: [-0.6, 1.0], push the joystick forward (negative value) to positive forward velocity"""
        # normalize to [-1, 1]
        normalized = value / 32768.0
        
        # dead zone handling
        deadzone = 0.05
        if abs(normalized) < deadzone:
            return 0.0
        
        # push the joystick forward (negative value) -> positive forward velocity [0, 1.0]
        # pull the joystick backward (positive value) -> negative forward velocity [-0.6, 0]
        if normalized < 0:
            # negative value: map from -deadzone to -1, then map to [0, 1.0]
            t = (-normalized - deadzone) / (1.0 - deadzone)
            smooth = 6*t**5 - 15*t**4 + 10*t**3
            return 1.0 * smooth
        else:
            # positive value: map from deadzone to 1, then map to [-0.6, 0]
            t = (normalized - deadzone) / (1.0 - deadzone)
            smooth = 6*t**5 - 15*t**4 + 10*t**3
            return -0.6 * smooth
    
    def _map_lateral_velocity(self, value):
        """map lateral velocity: [-0.5, 0.5]"""
        # normalize to [-1, 1]
        normalized = value / 32768.0
        
        # dead zone handling
        deadzone = 0.05
        if abs(normalized) < deadzone:
            return 0.0
        
        # map to [-0.5, 0.5]
        if normalized < 0:
            # negative value map to [-0.5, 0]
            t = (-normalized - deadzone) / (1.0 - deadzone)
            smooth = 6*t**5 - 15*t**4 + 10*t**3
            return -0.5 * smooth
        else:
            # positive value map to [0, 0.5]
            t = (normalized - deadzone) / (1.0 - deadzone)
            smooth = 6*t**5 - 15*t**4 + 10*t**3
            return 0.5 * smooth
    
    def _map_yaw_velocity(self, value):
        """map yaw velocity: [-1.57, 1.57]"""
        # normalize to [-1, 1]
        normalized = value / 32768.0
        
        # dead zone handling
        deadzone = 0.05
        if abs(normalized) < deadzone:
            return 0.0
        
        # map to [-1.57, 1.57]
        if normalized < 0:
            # negative value map to [-1.57, 0]
            t = (-normalized - deadzone) / (1.0 - deadzone)
            smooth = 6*t**5 - 15*t**4 + 10*t**3
            return -1.57 * smooth
        else:
            # positive value map to [0, 1.57]
            t = (normalized - deadzone) / (1.0 - deadzone)
            smooth = 6*t**5 - 15*t**4 + 10*t**3
            return 1.57 * smooth
    
    def _map_height(self, value):
        """map height: [-0.5, 0], when not pressed, return 0, when pressed, map to [-0.5, 0]"""
        # normalize to [-1, 1]
        normalized = value / 32768.0
        
        # dead zone handling - when not pressed, return 0
        deadzone = 0.05
        if abs(normalized) < deadzone:
            return 0.0
        
        # when pressed, map to [-0.5, 0]
        # calculate the intensity of the press (0 to 1)
        intensity = (abs(normalized) - deadzone) / (1.0 - deadzone)
        
        # ensure intensity is in [0, 1]
        intensity = max(0.0, min(1.0, intensity))
        
        # apply smooth curve
        smooth = 6*intensity**5 - 15*intensity**4 + 10*intensity**3
        
        # ensure smooth is in [0, 1]
        smooth = max(0.0, min(1.0, smooth))
        
        # map to [-0.5, 0], the heavier the press, the closer to -0.5
        result = -0.7 * smooth
        
        # extra protection: ensure the result is never positive
        return min(0.0, result)

    def _init_gamepad(self):
        devices = [InputDevice(path) for path in list_devices()]
        for dev in devices:
            if "8BitDo" in dev.name:
                print(f"find device: {dev.name}")
                return InputDevice(dev.path)
        raise Exception("no compatible gamepad device found")

    def _gamepad_listener(self):
        device = self._init_gamepad()
        try:
            for event in device.read_loop():
                if event.type == ecodes.EV_ABS:
                    self._handle_axis_event(event)
                elif event.type == ecodes.EV_KEY:
                    self._handle_button_event(event)
        except Exception as e:
            print(f"gamepad connection exception: {str(e)}")

    def _handle_axis_event(self, event):
        code = event.code
        value = event.value
        self.axis_state[code] = value
        with self.param_lock:
            if code == ecodes.ABS_Y:
                # ABS_Y control forward velocity [-0.6, 1.0]
                raw = self._map_forward_velocity(value)
                filtered_value = self._filters['x_vel'].update(raw, max_accel=0.2)
                self.control_params['x_vel'] = filtered_value
                self._last_active_time['x_vel'] = time.time()
                # print(f"[ABS_Y] original value: {value:6d}, mapped value: {raw:6.3f}, filtered value: {filtered_value:6.3f}")
                
            elif code == ecodes.ABS_X:
                # ABS_X control lateral velocity [-0.5, 0.5]
                raw = self._map_lateral_velocity(value)
                filtered_value = self._filters['y_vel'].update(raw, max_accel=0.2)
                self.control_params['y_vel'] = filtered_value
                self._last_active_time['y_vel'] = time.time()
                # print(f"[ABS_X] original value: {value:6d}, mapped value: {raw:6.3f}, filtered value: {filtered_value:6.3f}")
                
            elif code == ecodes.ABS_RX:
                # ABS_RX control yaw velocity [-1.57, 1.57]
                raw = self._map_yaw_velocity(value)
                filtered_value = self._filters['yaw_vel'].update(raw, max_accel=0.5)
                self.control_params['yaw_vel'] = filtered_value
                self._last_active_time['yaw_vel'] = time.time()
                # print(f"[ABS_RX] original value: {value:6d}, mapped value: {raw:6.3f}, filtered value: {filtered_value:6.3f}")
                
            elif code == ecodes.ABS_RY:
                # ABS_RY control height [-0.5, 0] (can only be 0 or negative)
                raw = self._map_height(value)
                filtered_value = self._filters['height'].update(raw, max_accel=0.02)
                self.control_params['height'] = filtered_value
                self._last_active_time['height'] = time.time()
                # print(f"[ABS_RY] original value: {value:6d}, mapped value: {raw:6.3f}, filtered value: {filtered_value:6.3f}")

            # self._debug_count += 1
            # if self._debug_count % 50 == 0:
            #     print(f"[SUMMARY] x_vel: {self.control_params['x_vel']:.3f}, "
            #           f"y_vel: {self.control_params['y_vel']:.3f}, "
            #           f"yaw_vel: {self.control_params['yaw_vel']:.3f}, "
            #           f"height: {self.control_params['height']:.3f}")
            #     print("-" * 60)

    def _handle_button_event(self, event):
        key_event = categorize(event)
        key_code = key_event.keycode[0] if isinstance(key_event.keycode, list) else key_event.keycode
        is_pressed = event.value == 1

        with self.param_lock:
            self._button_states[key_code] = is_pressed
        # print(f"[BUTTON] {key_code}: {'Pressed' if is_pressed else 'Released'}")

    def _recover_inactive_axes(self):
        while True:
            now = time.time()
            with self.param_lock:
                for key in self.control_params:
                    # check if the current axis value is in the dead zone
                    current_axis_in_deadzone = self._is_axis_in_deadzone(key)
                    
                    # only when the axis value is in the dead zone and exceeds the timeout time, restore the default value
                    if current_axis_in_deadzone and now - self._last_active_time[key] > self._timeout_secs:
                        if self.control_params[key] != self._default_values[key]:
                            self.control_params[key] = self._default_values[key]
            time.sleep(0.1)
    
    def _is_axis_in_deadzone(self, param_key):
        """check if the corresponding axis is in the dead zone"""
        deadzone = 0.05
        
        # check the corresponding axis according to the parameter type
        if param_key == 'x_vel':  # ABS_Y control forward
            axis_value = self.axis_state.get(ecodes.ABS_Y, 0)
        elif param_key == 'y_vel':  # ABS_X control lateral
            axis_value = self.axis_state.get(ecodes.ABS_X, 0)
        elif param_key == 'yaw_vel':  # ABS_RX control yaw
            axis_value = self.axis_state.get(ecodes.ABS_RX, 0)
        elif param_key == 'height':  # ABS_RY control height
            axis_value = self.axis_state.get(ecodes.ABS_RY, 0)
        else:
            return True  # unknown parameter, default in dead zone
        
        # normalize and check if it is in the dead zone
        normalized = axis_value / 32768.0
        return abs(normalized) < deadzone

    # === external interface ===

    def get_control_params(self):
        with self.param_lock:
            return self.control_params.copy()

    def get_button_state(self, button_name):
        with self.param_lock:
            return self._button_states.get(button_name, False)

    def get_all_button_states(self):
        with self.param_lock:
            return self._button_states.copy()



def publish_reset_category(category: int,publisher):
    # construct message
    msg = String_(data=str(category))  # pass data parameter directly during initialization

    # create publisher

    # publish message
    publisher.Write(msg)
    # print(f"published reset category: {category}")

if __name__ == "__main__":
    # initialize DDS
    ChannelFactoryInitialize(1)
    publisher = ChannelPublisher("rt/run_command/cmd", String_)
    publisher.Init()
    gamepad_controller = GamepadController()
    default_higet=0.8
    while True:
        time.sleep(0.01)
        commands = gamepad_controller.get_control_params()
        commands['height']=default_higet+commands['height']
        
        # convert to list format string [x_vel, y_vel, yaw_vel, height]
        commands_list = [float(commands['x_vel']), -float(commands['y_vel']), -float(commands['yaw_vel']), float(commands['height'])]
        commands_str = str(commands_list)
        print(f"commands: {commands_str}")
        publish_reset_category(commands_str,publisher)

    print("test publish completed")

===== send_commands_keyboard.py =====

#!/usr/bin/env python3
"""
ä½¿ç”¨ pynput åº“å®ç°é”®ç›˜æ§åˆ¶
"""

import time
from unitree_sdk2py.core.channel import ChannelPublisher, ChannelFactoryInitialize
from unitree_sdk2py.idl.std_msgs.msg.dds_ import String_

import threading
import math
import numpy as np
import time
from pynput import keyboard


class LowPassFilter:
    def __init__(self, alpha=0.15):
        self.alpha = alpha
        self._value = 0.0
        self._last_value = 0.0

    def update(self, new_value, max_accel=1.5):
        delta = new_value - self._last_value
        delta = np.clip(delta, -max_accel, max_accel)
        filtered = self.alpha * (self._last_value + delta) + (1 - self.alpha) * self._value
        self._last_value = filtered
        self._value = filtered
        return self._value


class KeyboardController:
    def __init__(self):
        self.control_params = {
            'x_vel': 0.0,
            'y_vel': 0.0,
            'yaw_vel': 0.0,
            'height': 0.0
        }
        
        # Key increment step size   
        self.increment = 0.05
        
        # control range
        self.ranges = {
            'x_vel': (-0.6, 1.0),    # forward velocity
            'y_vel': (-0.5, 0.5),   # lateral velocity
            'yaw_vel': (-1.57, 1.57), # yaw velocity
            'height': (-0.5, 0.0)    # height
        }
        
        # key state
        self.key_states = {
            'w': False,  # forward
            's': False,  # backward
            'a': False,  # left
            'd': False,  # right
            'z': False,  # left rotation
            'x': False,  # right rotation
            'c': False,  # crouch
        }
        
        self.param_lock = threading.Lock()
        self.running = True

        self._filters = {
            'x_vel': LowPassFilter(alpha=0.3),
            'y_vel': LowPassFilter(alpha=0.3),
            'yaw_vel': LowPassFilter(alpha=0.3),
            'height': LowPassFilter(alpha=0.3)
        }

        self._default_values = {
            'x_vel': 0.0,
            'y_vel': 0.0,
            'yaw_vel': 0.0,
            'height': 0.0
        }

        # Start threads
        self._control_thread = threading.Thread(target=self._control_update)
        self._control_thread.daemon = True
        self._control_thread.start()

        # Start keyboard listener
        self._start_keyboard_listener()

    def _start_keyboard_listener(self):
        """start keyboard listener"""
        def on_press(key):
            """key press event"""
            try:
                key_char = key.char.lower() if hasattr(key, 'char') and key.char else None
                
                with self.param_lock:
                    if key_char in self.key_states:
                        if not self.key_states[key_char]:
                            self.key_states[key_char] = True
                            print(f"[KEY] {key_char.upper()}: press")
                    elif key_char == 'q':
                        print("exit program...")
                        self.running = False
                        return False  # stop listening
                        
            except AttributeError:
                # handle special keys
                pass

        def on_release(key):
            """æŒ‰é”®é‡Šæ”¾äº‹ä»¶"""
            try:
                key_char = key.char.lower() if hasattr(key, 'char') and key.char else None
                
                with self.param_lock:
                    if key_char in self.key_states:
                        if self.key_states[key_char]:
                            self.key_states[key_char] = False
                            print(f"[KEY] {key_char.upper()}: release")
                            
            except AttributeError:
                # handle special keys
                pass

        # start keyboard listener
        self.listener = keyboard.Listener(
            on_press=on_press,
            on_release=on_release
        )
        self.listener.start()
        
        print("keyboard listener started...")
        print("press W/A/S/D/Z/X/C keys to control")
        print("press Q key to exit program")

    def _control_update(self):
        """control parameter update thread"""
        while self.running:
            with self.param_lock:
                # update control parameters according to key states
                
                # forward/backward (x_vel)
                if self.key_states['w']:  # forward
                    self.control_params['x_vel'] = min(
                        self.control_params['x_vel'] + self.increment,
                        self.ranges['x_vel'][1]
                    )
                elif self.key_states['s']:  # backward
                    self.control_params['x_vel'] = max(
                        self.control_params['x_vel'] - self.increment,
                        self.ranges['x_vel'][0]
                    )
                else:
                    # release key, gradually return to default value
                    if self.control_params['x_vel'] > 0:
                        self.control_params['x_vel'] = max(0, self.control_params['x_vel'] - self.increment * 2)
                    elif self.control_params['x_vel'] < 0:
                        self.control_params['x_vel'] = min(0, self.control_params['x_vel'] + self.increment * 2)

                # left/right (y_vel)
                if self.key_states['a']:  # left
                    self.control_params['y_vel'] = max(
                        self.control_params['y_vel'] - self.increment,
                        self.ranges['y_vel'][0]
                    )
                elif self.key_states['d']:  # right
                    self.control_params['y_vel'] = min(
                        self.control_params['y_vel'] + self.increment,
                        self.ranges['y_vel'][1]
                    )
                else:
                    # release key, gradually return to default value
                    if self.control_params['y_vel'] > 0:
                        self.control_params['y_vel'] = max(0, self.control_params['y_vel'] - self.increment * 2)
                    elif self.control_params['y_vel'] < 0:
                        self.control_params['y_vel'] = min(0, self.control_params['y_vel'] + self.increment * 2)

                # left/right rotation (yaw_vel)
                if self.key_states['z']:  # left
                    self.control_params['yaw_vel'] = max(
                        self.control_params['yaw_vel'] - self.increment,
                        self.ranges['yaw_vel'][0]
                    )
                elif self.key_states['x']:  # right
                    self.control_params['yaw_vel'] = min(
                        self.control_params['yaw_vel'] + self.increment,
                        self.ranges['yaw_vel'][1]
                    )
                else:
                    # release key, gradually return to default value
                    if self.control_params['yaw_vel'] > 0:
                        self.control_params['yaw_vel'] = max(0, self.control_params['yaw_vel'] - self.increment * 2)
                    elif self.control_params['yaw_vel'] < 0:
                        self.control_params['yaw_vel'] = min(0, self.control_params['yaw_vel'] + self.increment * 2)

                # crouch (height)
                if self.key_states['c']:  # crouch
                    self.control_params['height'] = max(
                        self.control_params['height'] - self.increment,
                        self.ranges['height'][0]
                    )
                else:
                    # release key, gradually return to default value
                    if self.control_params['height'] < 0:
                        self.control_params['height'] = min(0, self.control_params['height'] + self.increment * 2)

                # round to avoid floating point precision issues
                for key in self.control_params:
                    self.control_params[key] = round(self.control_params[key], 3)

            time.sleep(0.02)  # 50Hz update frequency

    # === external interface ===

    def get_control_params(self):
        with self.param_lock:
            return self.control_params.copy()

    def get_key_states(self):
        with self.param_lock:
            return self.key_states.copy()
    
    def stop(self):
        """stop keyboard controller"""
        self.running = False
        if hasattr(self, 'listener'):
            self.listener.stop()


def publish_reset_category(category, publisher):
    # construct message
    msg = String_(data=str(category))  # pass data parameter directly during initialization

    # create publisher

    # publish message
    publisher.Write(msg)
    # print(f"published reset category: {category}")

if __name__ == "__main__":
    print("=" * 50)
    print("keyboard control instructions (pynput version):")
    print("W: forward    S: backward")
    print("A: left  D: right") 
    print("Z: left rotation  X: right rotation")
    print("C: crouch    Q: exit program")
    print("press and hold the key to increase, release the key to gradually return to the default value")
    print("")
    print("note: if the pynput library is missing, please install:")
    print("pip install pynput")
    print("=" * 50)
    
    try:
        # check if pynput library is available
        try:
            from pynput import keyboard
        except ImportError:
            print("error: pynput library missing")
            print("please install: pip install pynput")
            exit(1)
            
        # initialize DDS
        print("initializing DDS communication...")
        ChannelFactoryInitialize(1)
        publisher = ChannelPublisher("rt/run_command/cmd", String_)
        publisher.Init()
        print("DDS communication initialized")
        
        print("initializing keyboard controller...")
        keyboard_controller = KeyboardController()
        default_height = 0.8
        
        print("=" * 50)
        print("program started, waiting for keyboard input...")
        print("press Ctrl+C to exit program")
        print("=" * 50)
        
        # add a counter, only show when the command changes
        counter = 0
        last_commands = [0.0, 0.0, 0.0, 0.8]
        
        while keyboard_controller.running:
            time.sleep(0.01)
            commands = keyboard_controller.get_control_params()
            commands['height'] = default_height + commands['height']
            
            # convert to list format string [x_vel, y_vel, yaw_vel, height]
            commands_list = [float(commands['x_vel']), -float(commands['y_vel']), -float(commands['yaw_vel']), float(commands['height'])]
            commands_str = str(commands_list)
            
            # only show when the command changes
            counter += 1
            if commands_list != last_commands:
                print(f"commands: {commands_str}")
                last_commands = commands_list.copy()
                
            publish_reset_category(commands_str, publisher)
            
    except KeyboardInterrupt:
        print("\nprogram interrupted by user (Ctrl+C)")
        if 'keyboard_controller' in locals():
            keyboard_controller.stop()
    except Exception as e:
        print(f"\nprogram error: {e}")
        if 'keyboard_controller' in locals():
            keyboard_controller.stop()
    
    print("program ended") 

===== sim_main.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
#!/usr/bin/env python3
# main.py
import os

project_root = os.path.dirname(os.path.abspath(__file__))
os.environ["PROJECT_ROOT"] = project_root

import argparse
import contextlib
import time
import sys
import signal
import torch
import gymnasium as gym
from pathlib import Path

# Isaac Lab AppLauncher
from isaaclab.app import AppLauncher

from image_server.image_server import ImageServer
from dds.dds_create import create_dds_objects,create_dds_objects_replay
# add command line arguments
parser = argparse.ArgumentParser(description="Unitree Simulation")
parser.add_argument("--task", type=str, default="Isaac-PickPlace-G129-Head-Waist-Fix", help="task name")
parser.add_argument("--action_source", type=str, default="dds", 
                   choices=["dds", "file", "trajectory", "policy", "replay","dds_wholebody"], 
                   help="Action source")


parser.add_argument("--robot_type", type=str, default="g129", help="robot type")
parser.add_argument("--enable_dex1_dds", action="store_true", help="enable gripper DDS")
parser.add_argument("--enable_dex3_dds", action="store_true", help="enable dexterous hand DDS")
parser.add_argument("--enable_inspire_dds", action="store_true", help="enable inspire hand DDS")
parser.add_argument("--stats_interval", type=float, default=10.0, help="statistics print interval (seconds)")

parser.add_argument("--file_path", type=str, default="/home/unitree/Code/xr_teleoperate/teleop/utils/data", help="file path (when action_source=file)")
parser.add_argument("--generate_data_dir", type=str, default="./data", help="save data dir")
parser.add_argument("--generate_data", action="store_true", default=False, help="generate data")
parser.add_argument("--rerun_log", action="store_true", default=False, help="rerun log")
parser.add_argument("--replay_data",  action="store_true", default=False, help="replay data")

parser.add_argument("--modify_light",  action="store_true", default=False, help="modify light")
parser.add_argument("--modify_camera",  action="store_true", default=False,    help="modify camera")

# performance analysis parameters
parser.add_argument("--step_hz", type=int, default=100, help="control frequency")
parser.add_argument("--enable_profiling", action="store_true", default=True, help="enable performance analysis")
parser.add_argument("--profile_interval", type=int, default=500, help="performance analysis report interval (steps)")

parser.add_argument("--model_path", type=str, default="assets/model/policy.onnx", help="model path")
parser.add_argument("--reward_interval", type=int, default=10, help="step interval for reward calculation")
parser.add_argument("--enable_wholebody_dds", action="store_true", default=False, help="enable wh dds")

parser.add_argument("--physics_dt", type=float, default=None, help="physics time step, e.g., 0.005")
parser.add_argument("--render_interval", type=int, default=None, help="render interval steps (>=1)")
parser.add_argument("--camera_write_interval", type=int, default=None, help="camera write interval steps (>=1)")


parser.add_argument(
    "--no_render",
    action="store_true",
    default=False,
    help="disable rendering updates entirely (overrides render interval)",
)
parser.add_argument("--solver_iterations", type=int, default=None, help="physx solver iteration count (e.g., 4)")
parser.add_argument("--gravity_z", type=float, default=None, help="override gravity z (e.g., -9.8)")
parser.add_argument("--skip_cvtcolor", action="store_true", default=False, help="skip cv2.cvtColor if upstream already BGR")

parser.add_argument("--camera_jpeg", action="store_true", default=True, help="enable JPEG compression for camera frames")
parser.add_argument("--camera_jpeg_quality", type=int, default=85, help="JPEG quality (1-100)")

parser.add_argument("--physx_substeps", type=int, default=None, help="physx substeps per step")
parser.add_argument("--camera_include", type=str, default="front_camera,left_wrist_camera,right_wrist_camera", help="comma-separated camera names to enable")
parser.add_argument("--camera_exclude", type=str, default="world_camera", help="comma-separated camera names to disable")

parser.add_argument("--env_reward_interval", type=int, default=5, help="environment reward compute interval (steps)")
parser.add_argument("--seed", type=int, default=42, help="environment seed")

# add AppLauncher parameters
AppLauncher.add_app_launcher_args(parser)
args_cli = parser.parse_args()


if args_cli.enable_dex3_dds and args_cli.enable_dex1_dds and args_cli.enable_inspire_dds:
    print("Error: enable_dex3_dds and enable_dex1_dds and enable_inspire_dds cannot be enabled at the same time")
    print("Please select one of the options")
    sys.exit(1)


import pinocchio 
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app

from layeredcontrol.robot_control_system import (
    RobotController, 
    ControlConfig,
)

from dds.reset_pose_dds import *
import tasks
from isaaclab_tasks.utils.parse_cfg import parse_env_cfg

from tools.augmentation_utils import (
    update_light,
    batch_augment_cameras_by_name,
)

from tools.data_json_load import sim_state_to_json
from dds.sim_state_dds import *
from action_provider.create_action_provider import create_action_provider
from tools.get_stiffness import get_robot_stiffness_from_env
from tools.get_reward import get_step_reward_value,get_current_rewards

def setup_signal_handlers(controller,dds_manager=None):
    """set signal handlers"""
    def signal_handler(signum, frame):
        print(f"\nreceived signal {signum}, stopping controller...")
        try:
            controller.stop()
        except Exception as e:
            print(f"Failed to stop controller: {e}")
        try:
            if dds_manager is not None:
                dds_manager.stop_all_communication()
        except Exception as e:
            print(f"Failed to stop DDS: {e}")
    
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)



def main():
    """main function"""
    # import cProfile
    # import pstats
    # import io
    # profiler = cProfile.Profile()
    # profiler.enable()
    import os
    import atexit
    try:
        os.setpgrp()
        current_pgid = os.getpgrp()
        print(f"Setting process group: {current_pgid}")
        
        def cleanup_process_group():
            try:
                print(f"Cleaning up process group: {current_pgid}")
                import signal
                os.killpg(current_pgid, signal.SIGTERM)
            except Exception as e:
                print(f"Failed to clean up process group: {e}")
        
        atexit.register(cleanup_process_group)
        
    except Exception as e:
        print(f"Failed to set process group: {e}")
    print("=" * 60)
    print("robot control system started")
    print(f"Task: {args_cli.task}")
    print(f"Action source: {args_cli.action_source}")
    print("=" * 60)

    # parse environment configuration
    try:
        env_cfg = parse_env_cfg(args_cli.task, device=args_cli.device, num_envs=1)
        env_cfg.env_name = args_cli.task
    except Exception as e:
        print(f"Failed to parse environment configuration: {e}")
        return
    
    # create environment
    print("\ncreate environment...")
    try:
        env_cfg.seed = args_cli.seed
        env = gym.make(args_cli.task, cfg=env_cfg).unwrapped

        print("total_action_dim:", env.action_manager.total_action_dim)
        for name, term in env.action_manager._terms.items():
            print(name, term.action_dim)
        term = env.action_manager._terms["joint_pos"]
        dof_indices = getattr(term, "dof_indices", None) or getattr(term, "_dof_indices", None)
        if dof_indices is not None:
            print(f"dof_indices: {dof_indices}")
        print(f"Observation terms: {env.observation_manager.active_terms}")
        print(f"obs_buf keys: {env.obs_buf.keys()}")

        env.seed(args_cli.seed)
        try:
            sensors_dict = getattr(env.scene, "sensors", {})
            if sensors_dict:
                print("Sensors in the environment:")
                for name, sensor in sensors_dict.items():
                    print(name, sensor)
                print("="*60)
        except Exception as e:
            print(f"[sim] failed to list sensors: {e}")
        print(f"\ncreate environment success ...")
        try:
            env._reward_interval = max(1, int(args_cli.env_reward_interval))
            env._reward_counter = 0
            env._reward_last = None
            print(f"[env] reward compute interval set to {env._reward_interval} steps")
        except Exception as e:
            print(f"[env] failed to set reward interval: {e}")
        if args_cli.physics_dt is not None:
            try:
                env.sim.set_substep_time(args_cli.physics_dt)
                print(f"[sim] physics dt set to {args_cli.physics_dt}")
            except Exception:
                try:
                    env.sim.dt = args_cli.physics_dt
                    print(f"[sim] physics dt assigned to env.sim.dt={args_cli.physics_dt}")
                except Exception as e:
                    print(f"[sim] failed to set physics dt: {e}")
        headless_mode = bool(getattr(args_cli, "headless", False))
        render_interval = None
        if args_cli.render_interval is not None:
            try:
                render_interval = max(1, int(args_cli.render_interval))
            except Exception as e:
                print(f"[sim] invalid render_interval value {args_cli.render_interval}: {e}")
        try:
            if args_cli.no_render:
                env.sim.render_interval = 1_000_000
                env.sim.render_mode = "offscreen"
                print("[sim] rendering disabled via --no_render")
            elif headless_mode:
                env.sim.render_mode = "offscreen"
                env.sim.render_interval = render_interval or 1
                print(f"[sim] headless offscreen rendering every {env.sim.render_interval} steps")
            elif render_interval is not None:
                env.sim.render_interval = render_interval
                print(f"[sim] render_interval set to {env.sim.render_interval}")
        except Exception as e:
            print(f"[sim] failed to configure rendering: {e}")
        if args_cli.camera_write_interval is not None:
            try:
                import tasks.common_observations.camera_state as cam_state
                cam_state._camera_cache['write_interval_steps'] = max(1, int(args_cli.camera_write_interval))
                print(f"[camera] write interval steps set to {cam_state._camera_cache['write_interval_steps']}")
            except Exception as e:
                print(f"[camera] failed to set write interval: {e}")

        try:
            if args_cli.solver_iterations is not None:
                env.sim.physx.solver_iteration_count = int(args_cli.solver_iterations)
                print(f"[sim] solver_iteration_count={env.sim.physx.solver_iteration_count}")
            if args_cli.physx_substeps is not None:
                try:
                    env.sim.physx.substeps = int(args_cli.physx_substeps)
                except Exception:
                    try:
                        env.sim.set_substeps(int(args_cli.physx_substeps))
                    except Exception:
                        pass
                print(f"[sim] physx_substeps set to {args_cli.physx_substeps}")
            if args_cli.gravity_z is not None:
                g = float(args_cli.gravity_z)
                env.sim.physx.gravity = (0.0, 0.0, g)
                print(f"[sim] gravity set to {env.sim.physx.gravity}")
        except Exception as e:
            print(f"[sim] failed to set physx params: {e}")
        if args_cli.skip_cvtcolor:
            os.environ["CAMERA_SKIP_CVTCOLOR"] = "1"
        try:
            import tasks.common_observations.camera_state as cam_state
            enable_jpeg = bool(args_cli.camera_jpeg) or (os.getenv("CAMERA_JPEG") == "1")
            jpeg_quality = int(args_cli.camera_jpeg_quality if args_cli.camera_jpeg else os.getenv("CAMERA_JPEG_QUALITY", args_cli.camera_jpeg_quality))
            cam_state.set_writer_options(enable_jpeg=enable_jpeg, jpeg_quality=jpeg_quality, skip_cvtcolor=args_cli.skip_cvtcolor)
            include = [n.strip() for n in (args_cli.camera_include or "").split(',') if n.strip()]
            exclude = [n.strip() for n in (args_cli.camera_exclude or "").split(',') if n.strip()]
            try:
                cam_state.set_camera_allowlist(include)
            except Exception:
                pass
            try:
                sensors_dict = getattr(env.scene, "sensors", {})
                for name, sensor in sensors_dict.items():
                    lname = name.lower()
                    if "camera" not in lname:
                        continue
                    if exclude and name in exclude:
                        for attr_name, value in [("enabled", False), ("is_enabled", False)]:
                            if hasattr(sensor, attr_name):
                                try:
                                    setattr(sensor, attr_name, value)
                                except Exception:
                                    pass
                        for meth in ("set_active", "disable", "pause"):
                            if hasattr(sensor, meth):
                                try:
                                    getattr(sensor, meth)(False)
                                except Exception:
                                    pass
                        for attr_name in ("update_period", "_update_period"):
                            if hasattr(sensor, attr_name):
                                try:
                                    setattr(sensor, attr_name, 1e6)
                                except Exception:
                                    pass
                    elif include and name not in include:
                        for attr_name in ("update_period", "_update_period"):
                            if hasattr(sensor, attr_name):
                                try:
                                    setattr(sensor, attr_name, 1e6)
                                except Exception:
                                    pass
            except Exception as e:
                print(f"[camera] failed to tune sensors: {e}")
        except Exception as e:
            print(f"[camera] failed to apply writer options: {e}")
    except Exception as e:
        print(f"\nFailed to create environment: {e}")
        return
    
    # get robot stiffness and damping parameters from runtime environment
    print("\n" + "="*60)
    print("ğŸ” Getting robot stiffness and damping parameters from runtime environment")
    print("="*60)
    
    try:
        stiffness_data = get_robot_stiffness_from_env(env)
        if stiffness_data:
            print("âœ… Successfully got robot parameters!")
        else:
            print("âš ï¸ Failed to get robot parameters, will try again after environment reset")
    except Exception as e:
        print(f"âš ï¸ Error getting robot parameters: {e}")
    
    print("="*60)
    
    if not getattr(args_cli, "headless", False) and not args_cli.no_render:
        print("\n")
        print("***  Please left-click on the Sim window to activate rendering. ***")
        print("\n")
    else:
        print("\n")
        print("***  Running without GUI; rendering handled offscreen. ***")
        print("\n")
    # reset environment
    if args_cli.modify_light:
        update_light(
            prim_path="/World/light",
            color=(0.75, 0.75, 0.75),
            intensity=500.0,
            # position=(1.0, 2.0, 3.0),
            radius=0.1,
            enabled=True,
            cast_shadows=True
        )
    if args_cli.modify_camera:
        batch_augment_cameras_by_name(
            names=["front_cam"],
            focal_length=3.0,
            horizontal_aperture=22.0,
            vertical_aperture=16.0,
            exposure=0.8,
            focus_distance=1.2
        )
    env.sim.reset()
    env.reset()
    
    # create simplified control configuration
    try:    
        control_config = ControlConfig(
            step_hz=args_cli.step_hz,
            replay_mode=args_cli.replay_data
        )
    except Exception as e:
        print(f"Failed to create control configuration: {e}")
        return
    
    # create controller

    if not args_cli.replay_data:
        print("========= create image server =========")
        try:
            server = ImageServer(fps=30, Unit_Test=False)
        except Exception as e:
            print(f"Failed to create image server: {e}")
            return
        print("========= create image server success =========")
        print("========= create dds =========")
        try:
            reset_pose_dds,sim_state_dds,dds_manager = create_dds_objects(args_cli,env)
        except Exception as e:
            print(f"Failed to create dds: {e}")
            return
        print("========= create dds success =========")
    else:
        print("========= create dds =========")
        try:
            create_dds_objects_replay(args_cli,env)
        except Exception as e:
            print(f"Failed to create dds: {e}")
            return
        print("========= create dds success =========")
        from tools.data_json_load import get_data_json_list
        print("========= get data json list =========")
        data_idx=0
        data_json_list = get_data_json_list(args_cli.file_path)
        if args_cli.action_source != "replay":
            args_cli.action_source = "replay"
        print("========= get data json list success =========")
    # create action provider
    
    print(f"\ncreate action provider: {args_cli.action_source}...")
    try:
        print(f"args_cli.task: {args_cli.task}")
        if not args_cli.replay_data and ("Wholebody" in args_cli.task or args_cli.enable_wholebody_dds):
            args_cli.action_source = "dds_wholebody"
            args_cli.enable_wholebody_dds = True
            control_config.use_rl_action_mode = True
        action_provider = create_action_provider(env,args_cli)
        if action_provider is None:
            print("action provider creation failed, exiting")
            return
    except Exception as e:
        print(f"Failed to create action provider: {e}")
        return
    
    # set action provider
    print("========= create controller =========")
    controller = RobotController(env, control_config)
    controller.set_action_provider(action_provider)
    print("========= create controller success =========")
    
    # configure performance analysis
    if args_cli.enable_profiling:
        controller.set_profiling(True, args_cli.profile_interval)
        print(f"performance analysis enabled, report every {args_cli.profile_interval} steps")
    else:
        controller.set_profiling(False)
        print("performance analysis disabled")


    # set signal handlers
    if not args_cli.replay_data:
        setup_signal_handlers(controller,dds_manager)
    else:
        setup_signal_handlers(controller)
    print("Note: The DDS in Sim transmits messages on channel 1. Please ensure that other DDS instances use the same channel for message exchange by setting: ChannelFactoryInitialize(1).")
    try:
        # start controller - start asynchronous components
        print("========= start controller =========")
        controller.start()
        print("========= start controller success =========")
        
        # main loop - execute in main thread to support rendering
        last_stats_time = time.time()
        loop_start_time = time.time()
        loop_count = 0
        last_loop_time = time.time()
        recent_loop_times = []  # for calculating moving average frequency
        
        
        reward_interval = max(1, args_cli.reward_interval)

        # use torch.inference_mode() and exception suppression
        with contextlib.suppress(KeyboardInterrupt), torch.inference_mode():
            while simulation_app.is_running() and controller.is_running:
                current_time = time.time()
                loop_count += 1
                if not args_cli.replay_data:
                    try:
                        env_state = env.scene.get_state()
                        env_state_json =  sim_state_to_json(env_state)
                        sim_state = {"init_state":env_state_json,"task_name":args_cli.task}
                    except Exception as e:
                        print(f"Failed to get env state: {e}")
                        raise e
                    try:
                    # sim_state = json.dumps(sim_state)
                        sim_state_dds.write_sim_state_data(sim_state)
                    except Exception as e:
                        print(f"Failed to write sim state: {e}")
                        raise e
                    # print(f"reset_pose_dds: {reset_pose_dds}")
                    try:
                        reset_pose_cmd = reset_pose_dds.get_reset_pose_command()
                    except Exception as e:
                        print(f"Failed to get reset pose command: {e}")
                        raise e
                    # # print(f"reset_pose_cmd: {reset_pose_cmd}")
                    # Compute current reward values manually if needed for debugging
                    try:
                        if (loop_count % reward_interval) == 0:
                            pass
                            # current_reward = get_step_reward_value(env)
                            # print(f"reward: {current_reward}")
                    except Exception as e:
                        print(f"å¥–åŠ±è®¡ç®—å¤±è´¥: {e}")
                        pass
                    
                    if reset_pose_cmd is not None:
                        try:
                            reset_category = reset_pose_cmd.get("reset_category")
                            # print(f"reset_category: {reset_category}")
                            if (args_cli.enable_wholebody_dds and (reset_category == '1' or reset_category == '2')) or (not args_cli.enable_wholebody_dds and reset_category == '1'):
                                print("reset object")
                                env_cfg.event_manager.trigger("reset_object_self", env)
                                reset_pose_dds.write_reset_pose_command(-1)
                            elif reset_category == '2' and not args_cli.enable_wholebody_dds:
                                print("reset all")
                                env_cfg.event_manager.trigger("reset_all_self", env)
                                reset_pose_dds.write_reset_pose_command(-1)
                        except Exception as e:
                            print(f"Failed to write reset pose command: {e}")
                            raise e
                else:
                    if action_provider.get_start_loop() and data_idx<len(data_json_list):
                        print(f"data_idx: {data_idx}")
                        try:
                            sim_state,task_name = action_provider.load_data(data_json_list[data_idx])
                            if task_name!=args_cli.task:
                                raise ValueError(f" The {task_name} in the dataset is different from the {args_cli.task} being executed .")
                        except Exception as e:
                            print(f"Failed to load data: {e}")
                            raise e
                        try:
                            print(f"initial state: {sim_state}")
                            env.reset_to(sim_state, torch.tensor([0], device=env.device), is_relative=True)
                            env.sim.reset()
                            time.sleep(1)
                            action_provider.start_replay()
                            data_idx+=1
                        except Exception as e:
                            print(f"Failed to start replay: {e}")
                            raise e
                # print(f"env_state: {env_state}")
                # calculate instantaneous loop time
                loop_dt = current_time - last_loop_time
                last_loop_time = current_time
                recent_loop_times.append(loop_dt)
                
                # keep recent 100 loop times
                if len(recent_loop_times) > 100:
                    recent_loop_times.pop(0)
                
                # execute control step (in main thread, support rendering)
                controller.step()

                # print statistics and loop frequency periodically
                if current_time - last_stats_time >= args_cli.stats_interval:
                    # calculate while loop execution frequency
                    elapsed_time = current_time - loop_start_time
                    loop_frequency = loop_count / elapsed_time if elapsed_time > 0 else 0
                    
                    # calculate moving average frequency (based on recent loop times)
                    if recent_loop_times:
                        avg_loop_time = sum(recent_loop_times) / len(recent_loop_times)
                        moving_avg_frequency = 1.0 / avg_loop_time if avg_loop_time > 0 else 0
                        min_loop_time = min(recent_loop_times)
                        max_loop_time = max(recent_loop_times)
                        max_freq = 1.0 / min_loop_time if min_loop_time > 0 else 0
                        min_freq = 1.0 / max_loop_time if max_loop_time > 0 else 0
                    else:
                        moving_avg_frequency = 0
                        min_freq = max_freq = 0
                    
                    print(f"\n=== While loop execution frequency statistics ===")
                    print(f"loop execution count: {loop_count}")
                    print(f"running time: {elapsed_time:.2f} seconds")
                    print(f"overall average frequency: {loop_frequency:.2f} Hz")
                    print(f"moving average frequency: {moving_avg_frequency:.2f} Hz (last {len(recent_loop_times)} times)")
                    print(f"frequency range: {min_freq:.2f} - {max_freq:.2f} Hz")
                    print(f"average loop time: {(elapsed_time/loop_count*1000):.2f} ms")
                    if recent_loop_times:
                        print(f"recent loop time: {(avg_loop_time*1000):.2f} ms")
                    print(f"=============================")
                    
                    # print_stats(controller)
                    last_stats_time = current_time
       
                # check environment state
                if env.sim.is_stopped():
                    print("\nenvironment stopped")
                    break
                # rate_limiter.sleep(env)
    except KeyboardInterrupt:
        print("\nuser interrupted program")
    
    except Exception as e:
        print(f"\nprogram exception: {e}")
    
    finally:
        # clean up resources
        print("\nclean up resources...")
        controller.cleanup()
        
        env.close()
        print("cleanup completed")
    # profiler.disable()
    # s = io.StringIO()
    # ps = pstats.Stats(profiler, stream=s).strip_dirs().sort_stats("time")
    # ps.print_stats(30)  

    # print(s.getvalue())

if __name__ == "__main__":
    try:
        main()
    finally:
        print("Performing final cleanup...")
        
        # Get current process information
        import os
        import subprocess
        import signal
        import time
        
        current_pid = os.getpid()
        print(f"Current main process PID: {current_pid}")
        
        try:
            # Find all related Python processes
            result = subprocess.run(['pgrep', '-f', 'sim_main.py'], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                pids = result.stdout.strip().split('\n')
                print(f"Found related processes: {pids}")
                
                for pid in pids:
                    if pid and pid != str(current_pid):
                        try:
                            print(f"Terminating child process: {pid}")
                            os.kill(int(pid), signal.SIGTERM)
                        except ProcessLookupError:
                            print(f"Process {pid} does not exist")
                        except Exception as e:
                            print(f"Failed to terminate process {pid}: {e}")
                
                # Wait for processes to exit
                time.sleep(2)
                
                # Check if there are any remaining processes, force kill them
                result2 = subprocess.run(['pgrep', '-f', 'sim_main.py'], 
                                       capture_output=True, text=True)
                if result2.returncode == 0:
                    remaining_pids = result2.stdout.strip().split('\n')
                    for pid in remaining_pids:
                        if pid and pid != str(current_pid):
                            try:
                                print(f"Force killing process: {pid}")
                                os.kill(int(pid), signal.SIGKILL)
                            except Exception as e:
                                print(f"Failed to force kill process {pid}: {e}")
                                
        except Exception as e:
            print(f"Error during process cleanup: {e}")
        
        try:
            simulation_app.close()
        except Exception as e:
            print(f"Failed to close simulation application: {e}")
            
        print("Program exit completed")
        
        # Force exit
        os._exit(0)

# python sim_main.py --device cpu  --enable_cameras  --task  Isaac-PickPlace-Cylinder-G129-Dex1-Joint   --enable_dex1_dds --robot_type g129
# python sim_main.py --device cpu  --enable_cameras  --task Isaac-PickPlace-Cylinder-G129-Dex3-Joint    --enable_dex3_dds --robot_type g129
# python sim_main.py --device cpu  --enable_cameras  --task Isaac-PickPlace-Cylinder-G129-Inspire-Joint    --enable_inspire_dds --robot_type g129

# python sim_main.py --device cpu  --enable_cameras  --task Isaac-PickPlace-RedBlock-G129-Dex1-Joint     --enable_dex1_dds --robot_type g129
# python sim_main.py --device cpu  --enable_cameras  --task Isaac-PickPlace-RedBlock-G129-Dex3-Joint    --enable_dex3_dds --robot_type g129
# python sim_main.py --device cpu  --enable_cameras  --task  Isaac-PickPlace-RedBlock-G129-Inspire-Joint    --enable_inspire_dds --robot_type g129


# python sim_main.py --device cpu  --enable_cameras  --task Isaac-Stack-RgyBlock-G129-Dex1-Joint     --enable_dex1_dds --robot_type g129
# python sim_main.py --device cpu  --enable_cameras  --task Isaac-Stack-RgyBlock-G129-Dex3-Joint     --enable_dex3_dds --robot_type g129
# python sim_main.py --device cpu  --enable_cameras  --task Isaac-Stack-RgyBlock-G129-Inspire-Joint     --enable_inspire_dds --robot_type g129




# python sim_main.py --device cpu  --enable_cameras  --task Isaac-Move-Cylinder-G129-Dex1-Wholebody  --robot_type g129 --enable_dex1_dds 
# python sim_main.py --device cpu  --enable_cameras  --task Isaac-Move-Cylinder-G129-Dex3-Wholebody  --robot_type g129 --enable_dex3_dds 
# python sim_main.py --device cpu  --enable_cameras  --task Isaac-Move-Cylinder-G129-Inspire-Wholebody  --robot_type g129 --enable_inspire_dds 


# python sim_main.py --device cpu  --enable_cameras  --task Isaac-PickPlace-Cylinder-H12-27dof-Inspire-Joint  --enable_inspire_dds --robot_type h1_2
# python sim_main.py --device cpu  --enable_cameras  --task Isaac-PickPlace-RedBlock-H12-27dof-Inspire-Joint  --enable_inspire_dds --robot_type h1_2
# python sim_main.py --device cpu  --enable_cameras  --task Isaac-Stack-RgyBlock-H12-27dof-Inspire-Joint --enable_inspire_dds --robot_type h1_2


===== tasks/__init__.py =====

# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""Package containing task implementations for various robotic environments."""

import os
import toml

# Conveniences to other module directories via relative paths
ISAACLAB_TASKS_EXT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "./"))
"""Path to the extension source directory."""

ISAACLAB_TASKS_METADATA = toml.load(os.path.join(ISAACLAB_TASKS_EXT_DIR, "config", "extension.toml"))
"""Extension metadata dictionary parsed from the extension.toml file."""

# Configure the module-level variables
__version__ = ISAACLAB_TASKS_METADATA["package"]["version"]

##
# Register Gym environments.
##

from .utils import import_packages

# The blacklist is used to prevent importing configs from sub-packages
# TODO(@ashwinvk): Remove pick_place from the blacklist once pinocchio from Isaac Sim is compatibility
_BLACKLIST_PKGS = ["utils", ".mdp", "pick_place"]
# Import all configs in this package
import_packages(__name__, _BLACKLIST_PKGS)


===== tasks/common_config/__init__.py =====

"""
å…¬å…±é…ç½®æ¨¡å—
æä¾›å¯å¤ç”¨çš„æœºå™¨äººå’Œç›¸æœºé…ç½®
"""

from .robot_configs import RobotBaseCfg, H12RobotPresets, RobotJointTemplates,G1RobotPresets
from .camera_configs import CameraBaseCfg, CameraPresets

__all__ = [
    "RobotBaseCfg",
    "G1RobotPresets",
    "H12RobotPresets",
    "RobotJointTemplates", 
    "CameraBaseCfg",
    "CameraPresets"
] 

===== tasks/common_config/camera_configs.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
public camera configuration
include the basic configuration for different types of cameras, support scene-specific parameter customization
"""

import isaaclab.sim as sim_utils
from isaaclab.sensors import CameraCfg
from isaaclab.utils import configclass
import os


@configclass
class CameraBaseCfg:
    """camera base configuration class
    
    provide the default configuration for different types of cameras, support scene-specific parameter customization
    """
    
    @classmethod
    def get_camera_config(
        cls,
        prim_path: str = "/World/envs/env_.*/Robot/d435_link/front_cam",
        update_period: float = 0.02,
        height: int = 480,
        width: int =  640,
        focal_length: float = 7.6,
        focus_distance: float = 400.0,
        horizontal_aperture: float = 20.0,
        clipping_range: tuple = (0.1, 1.0e5),
        pos_offset: tuple = (0, 0.0, 0),
        rot_offset: tuple = (0.5, -0.5, 0.5, -0.5),
        data_types: list = None
    ) -> CameraCfg:
        """get the front camera configuration
        
        Args:
            prim_path: the path of the camera in the scene
            update_period: update period (seconds)
            height: image height (pixels)
            width: image width (pixels)
            focal_length: focal length
            focus_distance: focus distance
            horizontal_aperture: horizontal aperture
            clipping_range: clipping range (near clipping plane, far clipping plane)
            pos_offset: position offset (x, y, z)
            rot_offset: rotation offset quaternion
            data_types: data type list
            
        Returns:
            CameraCfg: camera configuration
        """
        if data_types is None:
            data_types = ["rgb"]

        return CameraCfg(
            prim_path=prim_path,
            update_period=update_period,
            height=height,
            width=width,
            data_types=data_types,
            spawn=sim_utils.PinholeCameraCfg(
                focal_length=focal_length,
                focus_distance=focus_distance,
                horizontal_aperture=horizontal_aperture,
                clipping_range=clipping_range
            ),
            offset=CameraCfg.OffsetCfg(
                pos=pos_offset,
                rot=rot_offset,
                convention="ros"
            )
        )
    



@configclass
class CameraPresets:
    """camera preset configuration collection
    
    include the common camera configuration preset for different scenes
    """
    
    @classmethod
    def g1_front_camera(cls) -> CameraCfg:
        """front camera configuration"""
        return CameraBaseCfg.get_camera_config()
    @classmethod
    def h12_front_camera(cls) -> CameraCfg:
        """front camera configuration"""
        return CameraBaseCfg.get_camera_config(prim_path = "/World/envs/env_.*/Robot/camera_link/front_cam")
    @classmethod
    def g1_world_camera(cls) -> CameraCfg:
        """front camera configuration"""
        return CameraBaseCfg.get_camera_config(prim_path="/World/envs/env_.*/Robot/d435_link/PerspectiveCamera_robot",
                                                    pos_offset=(-0.9, 0.0, 0.0),
                                                    rot_offset=( -0.51292,0.51292,-0.48674, 0.48674),
                                                    focal_length = 12,
                                                    horizontal_aperture=27)
    @classmethod
    def h12_world_camera(cls) -> CameraCfg:
        """front camera configuration"""
        return CameraBaseCfg.get_camera_config(prim_path="/World/envs/env_.*/Robot/camera_link/PerspectiveCamera_robot",
                                                    pos_offset=(-0.9, 0.0, 0.0),
                                                    rot_offset=( -0.51292,0.51292,-0.48674, 0.48674),
                                                    focal_length = 12,
                                                    horizontal_aperture=27)
    @classmethod
    def left_gripper_wrist_camera(cls) -> CameraCfg:
        """left wrist camera configuration"""
        return CameraBaseCfg.get_camera_config(
            prim_path="/World/envs/env_.*/Robot/left_hand_base_link/left_wrist_camera",
            height=480,
            width=640,
            update_period=0.02,
            data_types=["rgb"],
            focal_length=12,
            focus_distance=400.0,
            horizontal_aperture=20.0,
            clipping_range=(0.1, 1.0e5),
            pos_offset=(0.02541028, 0.045, 0.135),
            rot_offset=(-0.34202, 0.93969, 0, 0),
        )
    @classmethod
    def right_gripper_wrist_camera(cls) -> CameraCfg:
        """right wrist camera configuration"""
        return CameraBaseCfg.get_camera_config(
            prim_path="/World/envs/env_.*/Robot/right_hand_base_link/right_wrist_camera",
            height=480,
            width=640,
            update_period=0.02,
            data_types=["rgb"],
            focal_length=12,
            focus_distance=400.0,
            horizontal_aperture=20.0,
            clipping_range=(0.1, 1.0e5),
            pos_offset=(-0.02541028, 0.045, 0.135),
            rot_offset=(-0.34202, 0.93969, 0, 0),
        ) 
    @classmethod
    def left_dex3_wrist_camera(cls) -> CameraCfg:
        """left wrist camera configuration"""
        return CameraBaseCfg.get_camera_config(
            prim_path="/World/envs/env_.*/Robot/left_hand_camera_base_link/left_wrist_camera",
            height=480,
            width=640,
            update_period=0.02,
            data_types=["rgb"],
            focal_length=12.0,
            focus_distance=400.0,
            horizontal_aperture=20.0,
            clipping_range=(0.1, 1.0e5),
            pos_offset=(-0.04012, -0.07441 ,0.15711),
            rot_offset=(0.00539,0.86024,0.0424, 0.50809),
        )
    @classmethod
    def right_dex3_wrist_camera(cls) -> CameraCfg:
        """right wrist camera configuration"""
        return CameraBaseCfg.get_camera_config(
            prim_path="/World/envs/env_.*/Robot/right_hand_camera_base_link/right_wrist_camera",
            height=480,
            width=640,
            update_period=0.02,
            data_types=["rgb"],
            focal_length=12.0,
            focus_distance=400.0,
            horizontal_aperture=20.0,
            clipping_range=(0.1, 1.0e5),
            pos_offset=(-0.04012, 0.07441 ,0.15711),
            rot_offset=(0.00539,0.86024,0.0424, 0.50809),
        ) 
    
    @classmethod
    def left_inspire_wrist_camera(cls) -> CameraCfg:
        """left wrist camera configuration"""
        return CameraBaseCfg.get_camera_config(
            prim_path="/World/envs/env_.*/Robot/left_hand_camera_base_link/left_wrist_camera",
            height=480,
            width=640,
            update_period=0.02,
            data_types=["rgb"],
            focal_length=12.0,
            focus_distance=400.0,
            horizontal_aperture=20.0,
            clipping_range=(0.1, 1.0e5),
            pos_offset=(-0.04012, -0.07441 ,0.15711),
            rot_offset=(0.00539,0.86024,0.0424, 0.50809),
        )
    @classmethod
    def right_inspire_wrist_camera(cls) -> CameraCfg:
        """right wrist camera configuration"""
        return CameraBaseCfg.get_camera_config(
            prim_path="/World/envs/env_.*/Robot/right_hand_camera_base_link/right_wrist_camera",
            height=480,
            width=640,
            update_period=0.02,
            data_types=["rgb"],
            focal_length=12.0,
            focus_distance=400.0,
            horizontal_aperture=20.0,
            clipping_range=(0.1, 1.0e5),
            pos_offset=(-0.04012, 0.07441 ,0.15711),
            rot_offset=(0.00539,0.86024,0.0424, 0.50809),
        ) 

===== tasks/common_config/robot_configs.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
public robot configuration
include the basic configuration for different robots, support scene-specific parameter customization
support different robot variants: with/without waist joint, different finger configurations
"""

from isaaclab.assets import ArticulationCfg
from isaaclab.utils import configclass
from robots.unitree import G129_CFG_WITH_DEX1_BASE_FIX,G129_CFG_WITH_DEX3_BASE_FIX,G129_CFG_WITH_INSPIRE_HAND,G129_CFG_WITH_DEX1_WHOLEBODY,G129_CFG_WITH_DEX3_WHOLEBODY,G129_CFG_WITH_INSPIRE_WHOLEBODY,H12_CFG_WITH_INSPIRE_HAND
from typing import Optional, Dict, Tuple, Literal


@configclass
class RobotJointTemplates:
    """G1 robot joint template collection
    
    provide different types of joint configuration templates
    """
    
    @classmethod
    def get_leg_joints(cls) -> Dict[str, float]:
        """get the default position of the leg joints"""
        return {
            # left leg joint - locked in standing position
            "left_hip_pitch_joint": 0.0,
            "left_hip_roll_joint": 0.0,
            "left_hip_yaw_joint": 0.0,
            "left_knee_joint": 0.0,
            "left_ankle_pitch_joint": 0.0,
            "left_ankle_roll_joint": 0.0,
            
            # right leg joint - locked in standing position
            "right_hip_pitch_joint": 0.0,
            "right_hip_roll_joint": 0.0,
            "right_hip_yaw_joint": 0.0,
            "right_knee_joint": 0.0,
            "right_ankle_pitch_joint": 0.0,
            "right_ankle_roll_joint": 0.0,
        }
    
    @classmethod
    def get_waist_joints(cls, include_waist: bool = True) -> Dict[str, float]:
        """get the position of the waist joints
        
        Args:
            include_waist: whether to include the waist joint
            
        Returns:
            waist joint position dictionary, if not included, return an empty dictionary
        """
        if not include_waist:
            return {}
        
        return {
            "waist_yaw_joint": 0.0,
            "waist_roll_joint": 0.0,
            "waist_pitch_joint": 0.0,
        }
    
    @classmethod
    def get_arm_joints(cls) -> Dict[str, float]:
        """get the default position of the arm joints"""
        return {
            # left arm joint
            "left_shoulder_pitch_joint": 0.0,
            "left_shoulder_roll_joint": 0.0,
            "left_shoulder_yaw_joint": 0.0,
            "left_elbow_joint": 0.0,
            "left_wrist_roll_joint": 0.0,
            "left_wrist_pitch_joint": 0.0,
            "left_wrist_yaw_joint": 0.0,
            
            # right arm joint
            "right_shoulder_pitch_joint": 0.0,
            "right_shoulder_roll_joint": 0.0,
            "right_shoulder_yaw_joint": 0.0,
            "right_elbow_joint": 0.0,
            "right_wrist_roll_joint": 0.0,
            "right_wrist_pitch_joint": 0.0,
            "right_wrist_yaw_joint": 0.0,
        }
    
    @classmethod
    def get_hand_joints(cls, hand_type: Literal["gripper", "dex3","inspire"] = "gripper") -> Dict[str, float]:
        """get the default position of the hand joints
        
        Args:
            hand_type: hand type
                - "gripper": simple gripper (2 joints)
                - "dex3": dexterous hand (14 joints)
                
        Returns:
            hand joint position dictionary
        """
        if hand_type == "gripper":
            return {
                # simple gripper joint
                "left_hand_Joint1_1": 0.0,
                "left_hand_Joint2_1": 0.0,
                "right_hand_Joint1_1": 0.0,
                "right_hand_Joint2_1": 0.0,
            }
        elif hand_type == "dex3":
            return {
                # dexterous hand joint - left hand
                "left_hand_index_0_joint": 0.0,
                "left_hand_middle_0_joint": 0.0,
                "left_hand_thumb_0_joint": 0.0,
                "left_hand_index_1_joint": 0.0,
                "left_hand_middle_1_joint": 0.0,
                "left_hand_thumb_1_joint": 0.0,
                "left_hand_thumb_2_joint": 0.0,
                
                # dexterous hand joint - right hand
                "right_hand_index_0_joint": 0.0,
                "right_hand_middle_0_joint": 0.0,
                "right_hand_thumb_0_joint": 0.0,
                "right_hand_index_1_joint": 0.0,
                "right_hand_middle_1_joint": 0.0,
                "right_hand_thumb_1_joint": 0.0,
                "right_hand_thumb_2_joint": 0.0,
            }
        elif hand_type == "inspire":
            return {
            # fingers joints
            "L_index_proximal_joint": 0.0,
            "L_index_intermediate_joint": 0.0,
            "L_middle_proximal_joint": 0.0,
            "L_middle_intermediate_joint": 0.0,
            "L_pinky_proximal_joint":0.0,
            "L_pinky_intermediate_joint":0.0,
            "L_ring_proximal_joint":0.0,
            "L_ring_intermediate_joint":0.0,
            "L_thumb_proximal_yaw_joint":0.0,
            "L_thumb_proximal_pitch_joint":0.0,
            "L_thumb_intermediate_joint":0.0,
            "L_thumb_distal_joint":0.0,

            "R_index_proximal_joint": 0.0,
            "R_index_intermediate_joint": 0.0,
            "R_middle_proximal_joint": 0.0,
            "R_middle_intermediate_joint": 0.0,
            "R_pinky_proximal_joint":0.0,
            "R_pinky_intermediate_joint":0.0,
            "R_ring_proximal_joint":0.0,
            "R_ring_intermediate_joint":0.0,
            "R_thumb_proximal_yaw_joint":0.0,
            "R_thumb_proximal_pitch_joint":0.0,
            "R_thumb_intermediate_joint":0.0,
            "R_thumb_distal_joint":0.0,
            }
        else:
            raise ValueError(f"Unsupported hand type: {hand_type}. Supported: 'gripper', 'dex3'")


@configclass
class RobotBaseCfg:
    """G1 robot base configuration class
    
    provide the flexible configuration for G1 robot, support:
    - with/without waist joint
    - simple gripper/dexterous hand
    - basic articulation configuration
    - default joint position
    - scene-specific parameter customization
    """
    
    @classmethod
    def get_base_config(
        cls,
        prim_path: str = "/World/envs/env_.*/Robot",
        init_pos: Tuple[float, float, float] = (-0.15, 0.0, 0.744),
        init_rot: Tuple[float, float, float, float] = (0.7071, 0, 0, 0.7071),
        include_waist: bool = True,
        hand_type: Literal["gripper", "dex3", "inspire"] = "gripper",
        base_config = None,
        custom_joint_pos: Optional[Dict[str, float]] = None,
        is_have_hand: bool = True,
        update_default_joint_pos: bool = True,
        robot_type: Literal["g129dof", "h1_2"] = "g129dof",
    ) -> ArticulationCfg:
        """get the base configuration for G1 robot
        
        Args:
            prim_path: the path of the robot in the scene
            init_pos: initial position (x, y, z)
            init_rot: initial rotation quaternion (w, x, y, z)
            include_waist: whether to include the waist joint
            hand_type: hand type ("simple" or "dexterous")
            base_config: base robot configuration, default using G129_CFG_WITH_DEX1_WAIST_FIX
            custom_joint_pos: custom joint position dictionary, will override the default value
            
        Returns:
            ArticulationCfg: robot configuration
        """
        
        # use the default base configuration
        if base_config is None and robot_type == "g129dof":
            base_config = G129_CFG_WITH_DEX1_BASE_FIX
        elif base_config is None and robot_type == "h1_2":
            base_config = H12_CFG_WITH_INSPIRE_HAND
        
        if update_default_joint_pos:
            # build the complete default joint position
            default_joint_pos = {}
            # add the leg joints
            default_joint_pos.update(RobotJointTemplates.get_leg_joints())
            
            # add the waist joints (if enabled)
            if robot_type == "g129dof":
                default_joint_pos.update(RobotJointTemplates.get_waist_joints(include_waist))
            
            # add the arm joints
            default_joint_pos.update(RobotJointTemplates.get_arm_joints())
            
            # add the hand joints
            if is_have_hand:
                default_joint_pos.update(RobotJointTemplates.get_hand_joints(hand_type))
        else:
            default_joint_pos = base_config.init_state.joint_pos.copy()
        
        # if the custom joint position is provided, merge it
        if custom_joint_pos:
            joint_pos = {**default_joint_pos, **custom_joint_pos}
        else:
            joint_pos = default_joint_pos
        
        # create the base configuration
        return base_config.replace(
            prim_path=prim_path,
            init_state=ArticulationCfg.InitialStateCfg(
                pos=init_pos,
                rot=init_rot,
                joint_pos=joint_pos,
                joint_vel={".*": 0.0}
            ),
        )


@configclass 
class G1RobotPresets:
    """G1 robot preset configuration collection
    
    include the common robot configuration preset for different scenes, support different robot variants
    """
    
    # === pick-place task preset ===
    
    @classmethod
    def g1_29dof_dex1_base_fix(cls,init_pos: Tuple[float, float, float] = (-0.15, 0.0, 0.76),
        init_rot: Tuple[float, float, float, float] = (0.7071, 0, 0, 0.7071)) -> ArticulationCfg:
        """pick-place task configuration - simple gripper"""
        return RobotBaseCfg.get_base_config(
            init_pos=init_pos,
            init_rot=init_rot,
            include_waist=False,
            hand_type="gripper"
        )
    
    @classmethod
    def g1_29dof_dex3_base_fix(cls,init_pos: Tuple[float, float, float] = (-0.15, 0.0, 0.76),
        init_rot: Tuple[float, float, float, float] = (0.7071, 0, 0, 0.7071)) -> ArticulationCfg:
        """pick-place task configuration - dex3 hand"""
        return RobotBaseCfg.get_base_config(
            init_pos=init_pos,
            init_rot=init_rot,
            include_waist=False,
            hand_type="dex3",
            base_config=G129_CFG_WITH_DEX3_BASE_FIX
        )


    @classmethod
    def g1_29dof_inspire_base_fix(cls,init_pos: Tuple[float, float, float] = (-0.15, 0.0, 0.76),
        init_rot: Tuple[float, float, float, float] = (0.7071, 0, 0, 0.7071)) -> ArticulationCfg:
        """pick-place task configuration - inspire hand"""
        return RobotBaseCfg.get_base_config(
            init_pos=init_pos,
            init_rot=init_rot,
            include_waist=False,
            hand_type="inspire",
            base_config=G129_CFG_WITH_INSPIRE_HAND
        )
    @classmethod
    def g1_29dof_dex1_wholebody(cls,init_pos: Tuple[float, float, float] = (-0.15, 0.0, 0.80),
        init_rot: Tuple[float, float, float, float] = (0.7071, 0, 0, 0.7071)) -> ArticulationCfg:
        """pick-place task configuration - inspire hand"""
        return RobotBaseCfg.get_base_config(
            init_pos=init_pos,
            init_rot=init_rot,
            include_waist=True,
            is_have_hand=False,
            base_config=G129_CFG_WITH_DEX1_WHOLEBODY,
            update_default_joint_pos=False )
    @classmethod
    def g1_29dof_dex3_wholebody(cls,init_pos: Tuple[float, float, float] = (-0.15, 0.0, 0.80),
        init_rot: Tuple[float, float, float, float] = (0.7071, 0, 0, 0.7071)) -> ArticulationCfg:
        """pick-place task configuration - inspire hand"""
        return RobotBaseCfg.get_base_config(
            init_pos=init_pos,
            init_rot=init_rot,
            include_waist=True,
            is_have_hand=False,
            base_config=G129_CFG_WITH_DEX3_WHOLEBODY,
            update_default_joint_pos=False )
    @classmethod
    def g1_29dof_inspire_wholebody(cls,init_pos: Tuple[float, float, float] = (-0.15, 0.0, 0.80),
        init_rot: Tuple[float, float, float, float] = (0.7071, 0, 0, 0.7071)) -> ArticulationCfg:
        """pick-place task configuration - inspire hand"""
        return RobotBaseCfg.get_base_config(
            init_pos=init_pos,
            init_rot=init_rot,
            include_waist=True,
            is_have_hand=False,
            base_config=G129_CFG_WITH_INSPIRE_WHOLEBODY,
            update_default_joint_pos=False )

@configclass
class H12RobotPresets:
    """H1 robot preset configuration collection
    
    include the common robot configuration preset for different scenes, support different robot variants
    """
    
    @classmethod
    def h12_27dof_inspire_base_fix(cls,init_pos: Tuple[float, float, float] = (-0.15, 0.0, 0.76),
        init_rot: Tuple[float, float, float, float] = (0.7071, 0, 0, 0.7071)) -> ArticulationCfg:   
        return RobotBaseCfg.get_base_config(
            init_pos=init_pos,
            init_rot=init_rot,
            include_waist=False,
            hand_type="inspire",
            base_config=H12_CFG_WITH_INSPIRE_HAND,
            robot_type="h1_2"
        )

===== tasks/common_event/event_manager.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
event manager
"""
import torch
from isaaclab.managers import SceneEntityCfg
import isaaclab.envs.mdp as base_mdp


class SimpleEvent:
    def __init__(self, func, params=None):
        self.func = func
        self.params = params or {}

    def trigger(self, env):
        return self.func(env, **self.params)


class MultiObjectEvent:
    """æ”¯æŒå¤šä¸ªç‰©ä½“æ“ä½œçš„äº‹ä»¶ç±»"""
    
    def __init__(self, reset_configs=None):
        """
        Args:
            reset_configs: å¤šç‰©ä½“é‡ç½®é…ç½®åˆ—è¡¨ï¼Œæ ¼å¼ä¸º:
            [
                {
                    "asset_cfg": SceneEntityCfg("red_block"),
                    "pose_range": {"x": [-0.05, 0.05], "y": [-0.05, 0.05]},
                    "velocity_range": {}
                },
                {
                    "asset_cfg": SceneEntityCfg("yellow_block"),
                    "pose_range": {"x": [-0.03, 0.03], "y": [-0.03, 0.03]},
                    "velocity_range": {}
                }
            ]
        """
        self.reset_configs = reset_configs or []
    
    def trigger(self, env):
        """
        è§¦å‘å¤šç‰©ä½“é‡ç½®äº‹ä»¶
        """
        env_ids = torch.arange(env.num_envs, device=env.device)
        results = []
        
        for config in self.reset_configs:
            try:
                result = base_mdp.reset_root_state_uniform(
                    env=env,
                    env_ids=env_ids,
                    pose_range=config.get("pose_range", {}),
                    velocity_range=config.get("velocity_range", {}),
                    asset_cfg=config["asset_cfg"]
                )
                results.append(result)
                print(f"é‡ç½®ç‰©ä½“: {config['asset_cfg'].name}")
            except Exception as e:
                print(f"ç‰©ä½“ {config['asset_cfg'].name} é‡ç½®å¤±è´¥: {e}")
        
        return results


class BatchObjectEvent:
    """æ‰¹é‡ç‰©ä½“äº‹ä»¶ç±» - æ›´çµæ´»çš„é…ç½®æ–¹å¼"""
    
    def __init__(self, object_names=None, pose_ranges=None, velocity_ranges=None):
        """
        Args:
            object_names: ç‰©ä½“åç§°åˆ—è¡¨ï¼Œå¦‚ ["red_block", "yellow_block", "green_block"]
            pose_ranges: ä½ç½®èŒƒå›´é…ç½®ï¼Œå¯ä»¥æ˜¯:
                - å•ä¸ªé…ç½®ï¼ˆæ‰€æœ‰ç‰©ä½“ä½¿ç”¨ç›¸åŒèŒƒå›´ï¼‰: {"x": [-0.05, 0.05], "y": [-0.05, 0.05]}
                - å­—å…¸é…ç½®ï¼ˆæ¯ä¸ªç‰©ä½“ä¸åŒèŒƒå›´ï¼‰: {"red_block": {...}, "yellow_block": {...}}
            velocity_ranges: é€Ÿåº¦èŒƒå›´é…ç½®ï¼Œæ ¼å¼åŒpose_ranges
        """
        self.object_names = object_names or []
        self.pose_ranges = pose_ranges or {}
        self.velocity_ranges = velocity_ranges or {}
    
    def trigger(self, env):
        """è§¦å‘æ‰¹é‡é‡ç½®"""
        env_ids = torch.arange(env.num_envs, device=env.device)
        results = []
        
        for obj_name in self.object_names:
            try:
                # è·å–è¯¥ç‰©ä½“çš„pose_rangeé…ç½®
                if isinstance(self.pose_ranges, dict) and obj_name in self.pose_ranges:
                    pose_range = self.pose_ranges[obj_name]
                elif isinstance(self.pose_ranges, dict) and "x" in self.pose_ranges:
                    # å•ä¸ªé…ç½®ï¼Œæ‰€æœ‰ç‰©ä½“ä½¿ç”¨ç›¸åŒé…ç½®
                    pose_range = self.pose_ranges
                else:
                    pose_range = {}
                
                # è·å–è¯¥ç‰©ä½“çš„velocity_rangeé…ç½®
                if isinstance(self.velocity_ranges, dict) and obj_name in self.velocity_ranges:
                    velocity_range = self.velocity_ranges[obj_name]
                elif isinstance(self.velocity_ranges, dict) and "linear" in self.velocity_ranges:
                    # å•ä¸ªé…ç½®ï¼Œæ‰€æœ‰ç‰©ä½“ä½¿ç”¨ç›¸åŒé…ç½®
                    velocity_range = self.velocity_ranges
                else:
                    velocity_range = {}
                
                result = base_mdp.reset_root_state_uniform(
                    env=env,
                    env_ids=env_ids,
                    pose_range=pose_range,
                    velocity_range=velocity_range,
                    asset_cfg=SceneEntityCfg(obj_name)
                )
                results.append(result)
                print(f"âœ… é‡ç½®ç‰©ä½“: {obj_name}")
                
            except Exception as e:
                print(f"âŒ ç‰©ä½“ {obj_name} é‡ç½®å¤±è´¥: {e}")
        
        return results


class SimpleEventManager:
    def __init__(self):
        self._events = {}

    def register(self, name, event):
        self._events[name] = event

    def trigger(self, name, env):
        event = self._events.get(name)
        if event:
            return event.trigger(env)
        else:
            print(f"Event {name} not registered")
    
    def register_multi_object_reset(self, name, object_names, pose_ranges=None, velocity_ranges=None):
        """
        ä¾¿æ·æ–¹æ³•ï¼šæ³¨å†Œå¤šç‰©ä½“é‡ç½®äº‹ä»¶
        
        Args:
            name: äº‹ä»¶åç§°
            object_names: ç‰©ä½“åç§°åˆ—è¡¨
            pose_ranges: ä½ç½®èŒƒå›´é…ç½®
            velocity_ranges: é€Ÿåº¦èŒƒå›´é…ç½®
        """
        event = BatchObjectEvent(
            object_names=object_names,
            pose_ranges=pose_ranges,
            velocity_ranges=velocity_ranges
        )
        self.register(name, event)

===== tasks/common_observations/camera_state.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
camera state
"""     

from __future__ import annotations

from typing import TYPE_CHECKING
import torch
import sys
import os
import threading
import queue

# add the project root directory to the path, so that the shared memory tool can be imported
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
from image_server.shared_memory_utils import MultiImageWriter

if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedRLEnv

# create the global multi-image shared memory writer
multi_image_writer = MultiImageWriter()

def set_writer_options(enable_jpeg: bool = False, jpeg_quality: int = 85, skip_cvtcolor: bool = False):
    try:
        multi_image_writer.set_options(enable_jpeg=enable_jpeg, jpeg_quality=jpeg_quality, skip_cvtcolor=skip_cvtcolor)
        print(f"[camera_state] writer options: jpeg={enable_jpeg}, quality={jpeg_quality}, skip_cvtcolor={skip_cvtcolor}")
    except Exception as e:
        print(f"[camera_state] failed to set writer options: {e}")


_camera_cache = {
    'available_cameras': None,
    'camera_keys': None,
    'last_scene_id': None,
    'frame_step': 0,
    'write_interval_steps': 2,
}


_return_placeholder = None
_async_queue = None
_async_thread = None
_async_started = False

def _async_writer_loop(q: "queue.Queue", writer: MultiImageWriter):
    while True:
        try:
            item = q.get()
            if item is None:
                break
            writer.write_images(item)
        except Exception as e:
            print(f"[camera_state] Async writer error: {e}")

def _ensure_async_started():
    global _async_started, _async_queue, _async_thread
    if not _async_started:
        _async_queue = queue.Queue(maxsize=1)
        _async_thread = threading.Thread(target=_async_writer_loop, args=(_async_queue, multi_image_writer), daemon=True)
        _async_thread.start()
        _async_started = True


def get_camera_image(
    env: ManagerBasedRLEnv,
) -> dict:
    # pass
    """get multiple camera images and write them to shared memory
    
    Args:
        env: ManagerBasedRLEnv - reinforcement learning environment instance
    
    Returns:
        dict: dictionary containing multiple camera images
    """
    global _return_placeholder
    if _return_placeholder is None:
        _return_placeholder = torch.zeros((1, 480, 640, 3))


    _camera_cache['frame_step'] = (_camera_cache['frame_step'] + 1) % max(1, _camera_cache['write_interval_steps'])


    scene_id = id(env.scene)
    if _camera_cache['last_scene_id'] != scene_id:
        _camera_cache['camera_keys'] = list(env.scene.keys())
        _camera_cache['available_cameras'] = [name for name in _camera_cache['camera_keys'] if "camera" in name.lower()]
        _camera_cache['last_scene_id'] = scene_id


    if _camera_cache['frame_step'] == 0:
        try:
            dt = getattr(env, 'physics_dt', 0.02)
            if hasattr(env.scene, 'sensors') and env.scene.sensors:
                for sensor in env.scene.sensors.values():
                    try:
                        sensor.update(dt, force_recompute=False)
                    except Exception:
                        pass
        except Exception:
            pass
    
    # get the camera images
    images = {}
    # env.sim.render()
    

    camera_keys = _camera_cache['camera_keys']
    # Head camera (front camera)
    if "front_camera" in camera_keys:
        head_image = env.scene["front_camera"].data.output["rgb"][0]  # [batch, height, width, 3]

        if head_image.device.type == 'cpu':
            images["head"] = head_image.numpy()
        else:
            images["head"] = head_image.cpu().numpy()
    
    # Left camera (left wrist camera)
    if "left_wrist_camera" in camera_keys:
        left_image = env.scene["left_wrist_camera"].data.output["rgb"][0]
        if left_image.device.type == 'cpu':
            images["left"] = left_image.numpy()
        else:
            images["left"] = left_image.cpu().numpy()
    
    # Right camera (right wrist camera)  
    if "right_wrist_camera" in camera_keys:
        right_image = env.scene["right_wrist_camera"].data.output["rgb"][0]
        if right_image.device.type == 'cpu':
            images["right"] = right_image.numpy()
        else:
            images["right"] = right_image.cpu().numpy()
    
    # if no camera with the specified name is found, try other common camera names
    if not images:

        available_cameras = _camera_cache['available_cameras']
        if available_cameras:
            print(f"[camera_state] No standard cameras found. Available cameras: {available_cameras}")
            
            # if there are available cameras, use the first three as head, left, right
            for i, camera_name in enumerate(available_cameras[:3]):
                camera_image = env.scene[camera_name].data.output["rgb"][0]
                
               
                if camera_image.device.type == 'cpu':
                    numpy_image = camera_image.numpy()
                else:
                    numpy_image = camera_image.cpu().numpy()
                
                if i == 0:
                    images["head"] = numpy_image
                elif i == 1:
                    images["left"] = numpy_image
                elif i == 2:
                    images["right"] = numpy_image
    

    if images and _camera_cache['frame_step'] == 0:
        _ensure_async_started()
        try:
            
            if _async_queue.full():
                _async_queue.get_nowait()
            _async_queue.put_nowait(images)
        except Exception:
            pass
    elif not images:
        print("[camera_state] No camera images found in the environment")
    
    return _return_placeholder



===== tasks/common_observations/dex3_state.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
dex3 state
"""     
from __future__ import annotations

import torch
from typing import TYPE_CHECKING
import sys
import os
if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedRLEnv


import torch


_obs_cache = {
    "device": None,
    "batch": None,
    "hand_idx_t": None,
    "hand_idx_batch": None,
    "pos_buf": None,
    "vel_buf": None,
    "torque_buf": None,
    "dds_last_ms": 0,
    "dds_min_interval_ms": 20,
}

def get_robot_girl_joint_names() -> list[str]:
    return [
        # hand joints (14)
        # left hand (7)
        "left_hand_thumb_0_joint",
        "left_hand_thumb_1_joint",
        "left_hand_thumb_2_joint",
        "left_hand_middle_0_joint",
        "left_hand_middle_1_joint",
        "left_hand_index_0_joint",
        "left_hand_index_1_joint",
        # right hand (7)
        "right_hand_thumb_0_joint",
        "right_hand_thumb_1_joint",
        "right_hand_thumb_2_joint",
        "right_hand_middle_0_joint",
        "right_hand_middle_1_joint",
        "right_hand_index_0_joint",
        "right_hand_index_1_joint",
    ]

# global variable to cache the DDS instance
_dex3_dds = None
_dds_initialized = False

def _get_dex3_dds_instance():
    """get the DDS instance, delay initialization"""
    global _dex3_dds, _dds_initialized
    
    if not _dds_initialized or _dex3_dds is None:
        try:
            # dynamically import the DDS module
            sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(__file__)), 'dds'))
            from dds.dds_master import dds_manager
            
            _dex3_dds = dds_manager.get_object("dex3")
            print("[Observations Dex3] DDS communication instance obtained")
            
            # register the cleanup function
            import atexit
            def cleanup_dds():
                try:
                    if _dex3_dds:
                        dds_manager.unregister_object("dex3")
                        print("[dex3_state] DDS communication closed correctly")
                except Exception as e:
                    print(f"[dex3_state] Error closing DDS: {e}")
            atexit.register(cleanup_dds)
            
        except Exception as e:
            print(f"[Observations Dex3] Failed to get DDS instances: {e}")
            _dex3_dds = None
        
        _dds_initialized = True
    
    return _dex3_dds

def get_robot_dex3_joint_states(
    env: ManagerBasedRLEnv,
    enable_dds: bool = True,
) -> torch.Tensor:
    """get the robot gripper joint states and publish them to DDS
    
    Args:
        env: ManagerBasedRLEnv - reinforcement learning environment instance
        enable_dds: bool - whether to enable the DDS publish function
    
    Returns:
        torch.Tensor
    """
    # get the gripper joint positions, velocities, torques
    joint_pos = env.scene["robot"].data.joint_pos
    joint_vel = env.scene["robot"].data.joint_vel  
    joint_torque = env.scene["robot"].data.applied_torque
    device = joint_pos.device
    batch = joint_pos.shape[0]
    

    global _obs_cache
    if _obs_cache["device"] != device or _obs_cache["hand_idx_t"] is None:
        gripper_joint_indices=[31, 37, 41, 30, 36, 29, 35, 34, 40, 42, 33, 39, 32, 38]
        _obs_cache["hand_idx_t"] = torch.tensor(gripper_joint_indices, dtype=torch.long, device=device)
        _obs_cache["device"] = device
        _obs_cache["batch"] = None
    idx_t = _obs_cache["hand_idx_t"]
    n = idx_t.numel()


    if _obs_cache["batch"] != batch or _obs_cache["hand_idx_batch"] is None:
        _obs_cache["hand_idx_batch"] = idx_t.unsqueeze(0).expand(batch, n)
        _obs_cache["pos_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["vel_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["torque_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["batch"] = batch

    idx_batch = _obs_cache["hand_idx_batch"]
    pos_buf = _obs_cache["pos_buf"]
    vel_buf = _obs_cache["vel_buf"]
    torque_buf = _obs_cache["torque_buf"]


    try:
        torch.gather(joint_pos, 1, idx_batch, out=pos_buf)
        torch.gather(joint_vel, 1, idx_batch, out=vel_buf)
        torch.gather(joint_torque, 1, idx_batch, out=torque_buf)
    except TypeError:
        pos_buf.copy_(torch.gather(joint_pos, 1, idx_batch))
        vel_buf.copy_(torch.gather(joint_vel, 1, idx_batch))
        torque_buf.copy_(torch.gather(joint_torque, 1, idx_batch))
    
    # publish to DDS (only publish the data of the first environment)
    if enable_dds and len(pos_buf) > 0:
        try:
            import time
            now_ms = int(time.time() * 1000)
            if now_ms - _obs_cache["dds_last_ms"] >= _obs_cache["dds_min_interval_ms"]:
                dex3_dds = _get_dex3_dds_instance()
                if dex3_dds:
                    pos = pos_buf[0].contiguous().cpu().numpy()
                    vel = vel_buf[0].contiguous().cpu().numpy()
                    torque = torque_buf[0].contiguous().cpu().numpy()
                    left_pos = pos[:7]
                    right_pos = pos[7:]
                    left_vel = vel[:7]
                    right_vel = vel[7:]
                    left_torque = torque[:7]
                    right_torque = torque[7:]
                    dex3_dds.write_hand_states(left_pos, left_vel, left_torque, right_pos, right_vel, right_torque)
                    _obs_cache["dds_last_ms"] = now_ms
        except Exception as e:
            print(f"dex3_state [dex3_state] Failed to write to DDS: {e}")
    
    return pos_buf



===== tasks/common_observations/g1_29dof_state.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
g1_29dof state
"""     
from __future__ import annotations

import torch
from typing import TYPE_CHECKING
import os

import sys
from multiprocessing import shared_memory

if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedRLEnv


import torch

def get_robot_boy_joint_names() -> list[str]:
    return [
        # leg joints (12)
        # left leg (6)
        "left_hip_pitch_joint",
        "left_hip_roll_joint",
        "left_hip_yaw_joint",
        "left_knee_joint",
        "left_ankle_pitch_joint",
        "left_ankle_roll_joint",
        # right leg (6)
        "right_hip_pitch_joint",
        "right_hip_roll_joint",
        "right_hip_yaw_joint",
        "right_knee_joint",
        "right_ankle_pitch_joint",
        "right_ankle_roll_joint",
        # waist joints (3)
        "waist_yaw_joint",
        "waist_roll_joint",
        "waist_pitch_joint",

        # arm joints (14)
        # left arm (7)
        "left_shoulder_pitch_joint",
        "left_shoulder_roll_joint",
        "left_shoulder_yaw_joint",
        "left_elbow_joint",
        "left_wrist_roll_joint",
        "left_wrist_pitch_joint",
        "left_wrist_yaw_joint",
        # right arm (7)
        "right_shoulder_pitch_joint",
        "right_shoulder_roll_joint",
        "right_shoulder_yaw_joint",
        "right_elbow_joint",
        "right_wrist_roll_joint",
        "right_wrist_pitch_joint",
        "right_wrist_yaw_joint",
    ]

def get_robot_arm_joint_names() -> list[str]:
    return [
        # arm joints (14)
        # left arm (7)
        "left_shoulder_pitch_joint",
        "left_shoulder_roll_joint",
        "left_shoulder_yaw_joint",
        "left_elbow_joint",
        "left_wrist_roll_joint",
        "left_wrist_pitch_joint",
        "left_wrist_yaw_joint",
        # right arm (7)
        "right_shoulder_pitch_joint",
        "right_shoulder_roll_joint",
        "right_shoulder_yaw_joint",
        "right_elbow_joint",
        "right_wrist_roll_joint",
        "right_wrist_pitch_joint",
        "right_wrist_yaw_joint",
    ]

# global variable to cache the DDS instance
from dds.dds_master import dds_manager
_g1_robot_dds = None
_dds_initialized = False

# è§‚æµ‹ç¼“å­˜ï¼šç´¢å¼•å¼ é‡ä¸DDSé™é€Ÿï¼ˆ50FPSï¼‰+ é¢„åˆ†é…ç¼“å†²
_obs_cache = {
    "device": None,
    "batch": None,
    "boy_idx_t": None,
    "boy_idx_batch": None,
    "pos_buf": None,
    "vel_buf": None,
    "torque_buf": None,
    "combined_buf": None,
    "dds_last_ms": 0,
    "dds_min_interval_ms": 20,
}

def _get_g1_robot_dds_instance():
    """get the DDS instance, delay initialization"""
    global _g1_robot_dds, _dds_initialized
    
    if not _dds_initialized or _g1_robot_dds is None:
        try:
            # dynamically import the DDS module
            sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(__file__)), 'dds'))
            from dds.dds_master import dds_manager
            print(f"dds_manager: {dds_manager}")
            _g1_robot_dds = dds_manager.get_object("g129")
            print("[g1_state] G1 robot DDS communication instance obtained")
            
            # register the cleanup function
            import atexit
            def cleanup_dds():
                try:
                    if _g1_robot_dds:
                        dds_manager.unregister_object("g129")
                        print("[g1_state] DDS communication closed correctly")
                except Exception as e:
                    print(f"[g1_state] Error closing DDS: {e}")
            atexit.register(cleanup_dds)
            
        except Exception as e:
            print(f"[g1_state] Failed to get G1 robot DDS instance: {e}")
            _g1_robot_dds = None
        
        _dds_initialized = True
    
    return _g1_robot_dds

def get_robot_boy_joint_states(
    env: ManagerBasedRLEnv,
    enable_dds: bool = True,
) -> torch.Tensor:
    """get the robot body joint states, positions and velocities
    
    Args:
        env: ManagerBasedRLEnv - reinforcement learning environment instance
        enable_dds: bool - whether to enable the DDS publish function
    
    Returns:
        torch.Tensor
        - the first 29 elements are joint positions
        - the middle 29 elements are joint velocities
        - the last 29 elements are joint torques
    """
    # get all joint states
    joint_pos = env.scene["robot"].data.joint_pos
    joint_vel = env.scene["robot"].data.joint_vel
    joint_torque = env.scene["robot"].data.applied_torque  # use applied_torque to get joint torques
    device = joint_pos.device
    batch = joint_pos.shape[0]

    # é¢„è®¡ç®—å¹¶ç¼“å­˜ç´¢å¼•å¼ é‡ï¼ˆåˆ—ç´¢å¼•ï¼‰
    global _obs_cache
    if _obs_cache["device"] != device or _obs_cache["boy_idx_t"] is None:
        boy_joint_indices = [0, 3, 6, 9, 13, 17, 1, 4, 7, 10, 14, 18, 2, 5, 8, 11, 15, 19, 21, 23, 25, 27, 12, 16, 20, 22, 24, 26, 28]
        _obs_cache["boy_idx_t"] = torch.tensor(boy_joint_indices, dtype=torch.long, device=device)
        _obs_cache["device"] = device
        _obs_cache["batch"] = None  # force re-init batch-shaped buffers

    idx_t = _obs_cache["boy_idx_t"]
    n = idx_t.numel()

    # é¢„åˆ†é…/å¤ç”¨ batch å½¢çŠ¶ç´¢å¼•ä¸è¾“å‡ºç¼“å†²
    if _obs_cache["batch"] != batch or _obs_cache["boy_idx_batch"] is None:
        _obs_cache["boy_idx_batch"] = idx_t.unsqueeze(0).expand(batch, n)
        _obs_cache["pos_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["vel_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["torque_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["combined_buf"] = torch.empty(batch, n * 3, device=device, dtype=joint_pos.dtype)
        _obs_cache["batch"] = batch

    idx_batch = _obs_cache["boy_idx_batch"]
    pos_buf = _obs_cache["pos_buf"]
    vel_buf = _obs_cache["vel_buf"]
    torque_buf = _obs_cache["torque_buf"]
    combined_buf = _obs_cache["combined_buf"]

    # ä½¿ç”¨ gather(out=...) å¡«å……ï¼Œé¿å…æ–°å¼ é‡åˆ†é…
    try:
        torch.gather(joint_pos, 1, idx_batch, out=pos_buf)
        torch.gather(joint_vel, 1, idx_batch, out=vel_buf)
        torch.gather(joint_torque, 1, idx_batch, out=torque_buf)
    except TypeError:
        pos_buf.copy_(torch.gather(joint_pos, 1, idx_batch))
        vel_buf.copy_(torch.gather(joint_vel, 1, idx_batch))
        torque_buf.copy_(torch.gather(joint_torque, 1, idx_batch))

    # ç»„åˆä¸ºä¸€ä¸ªç¼“å†²ï¼Œé¿å… cat åˆ†é…
    combined_buf[:, 0:n].copy_(pos_buf)
    combined_buf[:, n:2*n].copy_(vel_buf)
    combined_buf[:, 2*n:3*n].copy_(torque_buf)

    # write to DDSï¼ˆé™é€Ÿå‘å¸ƒï¼Œé¿å…é«˜é¢‘CPUæ‹·è´ï¼‰
    if enable_dds and combined_buf.shape[0] > 0:
        try:
            import time
            now_ms = int(time.time() * 1000)
            if now_ms - _obs_cache["dds_last_ms"] >= _obs_cache["dds_min_interval_ms"]:
                g1_robot_dds = _get_g1_robot_dds_instance()
                if g1_robot_dds:
                    imu_data = get_robot_imu_data(env)
                    if imu_data.shape[0] > 0:
                        g1_robot_dds.write_robot_state(
                            pos_buf[0].contiguous().cpu().numpy(),
                            vel_buf[0].contiguous().cpu().numpy(),
                            torque_buf[0].contiguous().cpu().numpy(),
                            imu_data[0].contiguous().cpu().numpy(),
                        )
                        _obs_cache["dds_last_ms"] = now_ms
        except Exception as e:
            print(f"[g1_state] Error writing robot state to DDS: {e}")
    
    return combined_buf


def get_gravity_quaternion_from_root_state(env: ManagerBasedRLEnv):
    body_names = env.scene["robot"].data.body_names
    imu_pelvis_idx = body_names.index("imu_in_pelvis")
    imu_torso_idx = body_names.index("imu_in_torso")
    print(f"imu_pelvis_idx: {imu_pelvis_idx}")
    print(f"imu_torso_idx: {imu_torso_idx}")
    pose = env.scene["robot"].data.body_link_pose_w  # [num_links, 7] (pos + quat)
    vel = env.scene["robot"].data.body_link_vel_w    # [num_links, 6] (lin_vel + ang_vel)

    # å–å‡ºIMUä½ç½®+æ—‹è½¬
    pelvis_pose = pose[:, imu_pelvis_idx, :]  # [B, 7]
    torso_pose = pose[:, imu_torso_idx, :]

    # å–å‡ºIMUçº¿é€Ÿåº¦+è§’é€Ÿåº¦
    pelvis_vel = vel[:, imu_pelvis_idx, :]    # [B, 6]
    torso_vel = vel[:, imu_torso_idx, :]
    return pelvis_pose, pelvis_vel, torso_pose, torso_vel

def get_robot_imu_data(
    env: ManagerBasedRLEnv,
) -> torch.Tensor:
    """get the robot IMU data
    
    Args:
        env: ManagerBasedRLEnv - reinforcement learning environment instance
    
    Returns:
        torch.Tensor
        - the first 3 elements are position
        - the next 4 elements are rotation quaternion
        - the next 3 elements are linear velocity
        - the last 3 elements are angular velocity
    """
    # get the robot root state
    root_state = env.scene["robot"].data.root_state_w
    # print(env.scene["robot"].data.__dict__.keys())
    # pelvis_pose, pelvis_vel, torso_pose, torso_vel = get_gravity_quaternion_from_root_state(env)
    # print(f"pelvis_pose: {pelvis_pose}")
    # print(f"pelvis_vel: {pelvis_vel}")
    # print(f"torso_pose: {torso_pose}")
    # print(f"torso_vel: {torso_vel}")
    # extract the position, rotation, velocity and angular velocity
    pos = root_state[:, :3]  # position
    quat = root_state[:, 3:7]  # rotation quaternion
    vel = root_state[:, 7:10]  # linear velocity
    ang_vel = root_state[:, 10:13]  # angular velocity
    # pos = torso_pose[:, :3]
    # quat = torso_pose[:, 3:7]
    # vel = torso_vel[:, :3]
    # ang_vel = torso_vel[:, 3:6]
    # qu = get_gravity_quaternion(env)
    # print(f"qu: {qu}")
    # print(f"quat: {quat}")
    # concatenate all data
    imu_data = torch.cat([pos, quat, vel, ang_vel], dim=1)
    
    return imu_data



# def get_robot_imu_data(env):
#     data = env.scene["robot"].data

#     # quaternion from root_state_w
#     root_state = data._root_state_w  # [B, 13]: [pos(3), quat(4), vel(3), ang_vel(3)]
#     quaternion = root_state[:, 3:7]

#     # gyroscope from root_state_w angular velocity
#     gyroscope = root_state[:, 10:13]

#     # accelerometer: root COM acceleration
#     accelerometer = data._root_com_acc_w[:, :3]  # [B, 3]

#     # convert quaternion to RPY (Roll, Pitch, Yaw)
#     rpy = quaternion_to_rpy(quaternion)

#     return {
#         "quaternion": quaternion,
#         "gyroscope": gyroscope,
#         "accelerometer": accelerometer,
#         "rpy": rpy
#     }

def quaternion_to_rpy(quat: torch.Tensor) -> torch.Tensor:
    """
    Convert quaternion (w, x, y, z) to roll, pitch, yaw (radians).
    """
    w, x, y, z = quat[:, 0], quat[:, 1], quat[:, 2], quat[:, 3]

    t0 = +2.0 * (w * x + y * z)
    t1 = +1.0 - 2.0 * (x * x + y * y)
    roll = torch.atan2(t0, t1)

    t2 = +2.0 * (w * y - z * x)
    t2 = torch.clamp(t2, -1.0, 1.0)
    pitch = torch.asin(t2)

    t3 = +2.0 * (w * z + x * y)
    t4 = +1.0 - 2.0 * (y * y + z * z)
    yaw = torch.atan2(t3, t4)

    return torch.stack([roll, pitch, yaw], dim=1)

===== tasks/common_observations/gripper_state.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
gripper state
"""      

from __future__ import annotations

import torch
from typing import TYPE_CHECKING
import sys
import os
if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedRLEnv


import torch


_obs_cache = {
    "device": None,
    "batch": None,
    "gripper_idx_t": None,
    "gripper_idx_batch": None,
    "pos_buf": None,
    "vel_buf": None,
    "torque_buf": None,
    "dds_last_ms": 0,
    "dds_min_interval_ms": 20,
}

def get_robot_girl_joint_names() -> list[str]:
    return [
        "right_hand_Joint1_1",
        "left_hand_Joint1_1",
    ]

# global variable to cache the DDS instance
_gripper_dds = None
_dds_initialized = False

def _get_gripper_dds_instance():
    """get the DDS instance, delay initialization"""
    global _gripper_dds, _dds_initialized
    
    if not _dds_initialized or _gripper_dds is None:
        try:
            # dynamically import the DDS module
            sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(__file__)), 'dds'))
            from dds.dds_master import dds_manager
            
            _gripper_dds = dds_manager.get_object("dex1")
            print("[Observations] DDS communication instance obtained")
            
            # register the cleanup function
            import atexit
            def cleanup_dds():
                try:
                    if _gripper_dds:
                        dds_manager.unregister_object("dex1")
                        print("[gripper_state] DDS communication closed correctly")
                except Exception as e:
                    print(f"[gripper_state] Error closing DDS: {e}")
            atexit.register(cleanup_dds)
            
        except Exception as e:
            print(f"[Observations] Failed to get DDS instances: {e}")
            _gripper_dds = None
        
        _dds_initialized = True
    
    return _gripper_dds

def initialize_gripper_dds():
    """explicitly initialize the DDS communication
    
    this function can be called manually to initialize the DDS communication,
    instead of relying on delayed initialization
    """
    return _get_gripper_dds_instance()


def get_robot_gipper_joint_states(
    env: ManagerBasedRLEnv,
    enable_dds: bool = True,
) -> torch.Tensor:
    """get the robot gripper joint states and publish them to DDS
    
    Args:
        env: ManagerBasedRLEnv - reinforcement learning environment instance
        enable_dds: bool - whether to enable the DDS publish function
    
    è¿”å›:
        torch.Tensor
    """
    # get the gripper joint states
    joint_pos = env.scene["robot"].data.joint_pos
    joint_vel = env.scene["robot"].data.joint_vel  
    joint_torque = env.scene["robot"].data.applied_torque
    device = joint_pos.device
    batch = joint_pos.shape[0]
    

    global _obs_cache
    if _obs_cache["device"] != device or _obs_cache["gripper_idx_t"] is None:
        gripper_joint_indices = [31, 29]
        _obs_cache["gripper_idx_t"] = torch.tensor(gripper_joint_indices, dtype=torch.long, device=device)
        _obs_cache["device"] = device
        _obs_cache["batch"] = None
    idx_t = _obs_cache["gripper_idx_t"]
    n = idx_t.numel()


    if _obs_cache["batch"] != batch or _obs_cache["gripper_idx_batch"] is None:
        _obs_cache["gripper_idx_batch"] = idx_t.unsqueeze(0).expand(batch, n)
        _obs_cache["pos_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["vel_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["torque_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["batch"] = batch

    idx_batch = _obs_cache["gripper_idx_batch"]
    pos_buf = _obs_cache["pos_buf"]
    vel_buf = _obs_cache["vel_buf"]
    torque_buf = _obs_cache["torque_buf"]


    try:
        torch.gather(joint_pos, 1, idx_batch, out=pos_buf)
        torch.gather(joint_vel, 1, idx_batch, out=vel_buf)
        torch.gather(joint_torque, 1, idx_batch, out=torque_buf)
    except TypeError:
        pos_buf.copy_(torch.gather(joint_pos, 1, idx_batch))
        vel_buf.copy_(torch.gather(joint_vel, 1, idx_batch))
        torque_buf.copy_(torch.gather(joint_torque, 1, idx_batch))
    
    # publish to DDS (only publish the data of the first environment)
    if enable_dds and len(pos_buf) > 0:
        try:
            import time
            now_ms = int(time.time() * 1000)
            if now_ms - _obs_cache["dds_last_ms"] >= _obs_cache["dds_min_interval_ms"]:
                gripper_dds = _get_gripper_dds_instance()
                if gripper_dds:
                    pos = pos_buf[0].contiguous().cpu().numpy()
                    vel = vel_buf[0].contiguous().cpu().numpy()
                    torque = torque_buf[0].contiguous().cpu().numpy()
                    right_pos = pos[:1]
                    left_pos = pos[1:]
                    right_vel = vel[:1]
                    left_vel = vel[1:]
                    right_torque = torque[:1]
                    left_torque = torque[1:]
                    # write the gripper state to shared memory
                    gripper_dds.write_gripper_state(left_pos, left_vel, left_torque, right_pos, right_vel, right_torque)
                    _obs_cache["dds_last_ms"] = now_ms
        except Exception as e:
            print(f"[gripper_state] Failed to write to shared memory: {e}")
    
    return pos_buf



===== tasks/common_observations/h12_27dof_state.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
g1_29dof state
"""     
from __future__ import annotations

import torch
from typing import TYPE_CHECKING
import os

import sys
from multiprocessing import shared_memory

if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedRLEnv


import torch

def get_robot_boy_joint_names() -> list[str]:
    return [
        # leg joints (12)
        # left leg (6)
        "left_hip_pitch_joint",
        "left_hip_roll_joint",
        "left_hip_yaw_joint",
        "left_knee_joint",
        "left_ankle_pitch_joint",
        "left_ankle_roll_joint",
        # right leg (6)
        "right_hip_pitch_joint",
        "right_hip_roll_joint",
        "right_hip_yaw_joint",
        "right_knee_joint",
        "right_ankle_pitch_joint",
        "right_ankle_roll_joint",
        # arm joints (14)
        # left arm (7)
        "left_shoulder_pitch_joint",
        "left_shoulder_roll_joint",
        "left_shoulder_yaw_joint",
        "left_elbow_joint",
        "left_wrist_roll_joint",
        "left_wrist_pitch_joint",
        "left_wrist_yaw_joint",
        # right arm (7)
        "right_shoulder_pitch_joint",
        "right_shoulder_roll_joint",
        "right_shoulder_yaw_joint",
        "right_elbow_joint",
        "right_wrist_roll_joint",
        "right_wrist_pitch_joint",
        "right_wrist_yaw_joint",
    ]

def get_robot_arm_joint_names() -> list[str]:
    return [
        # arm joints (14)
        # left arm (7)
        "left_shoulder_pitch_joint",
        "left_shoulder_roll_joint",
        "left_shoulder_yaw_joint",
        "left_elbow_joint",
        "left_wrist_roll_joint",
        "left_wrist_pitch_joint",
        "left_wrist_yaw_joint",
        # right arm (7)
        "right_shoulder_pitch_joint",
        "right_shoulder_roll_joint",
        "right_shoulder_yaw_joint",
        "right_elbow_joint",
        "right_wrist_roll_joint",
        "right_wrist_pitch_joint",
        "right_wrist_yaw_joint",
    ]

# global variable to cache the DDS instance
from dds.dds_master import dds_manager
_g1_robot_dds = None
_dds_initialized = False

# è§‚æµ‹ç¼“å­˜ï¼šç´¢å¼•å¼ é‡ä¸DDSé™é€Ÿï¼ˆ50FPSï¼‰+ é¢„åˆ†é…ç¼“å†²
_obs_cache = {
    "device": None,
    "batch": None,
    "boy_idx_t": None,
    "boy_idx_batch": None,
    "pos_buf": None,
    "vel_buf": None,
    "torque_buf": None,
    "combined_buf": None,
    "dds_last_ms": 0,
    "dds_min_interval_ms": 20,
}

def _get_g1_robot_dds_instance():
    """get the DDS instance, delay initialization"""
    global _g1_robot_dds, _dds_initialized
    
    if not _dds_initialized or _g1_robot_dds is None:
        try:
            # dynamically import the DDS module
            sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(__file__)), 'dds'))
            from dds.dds_master import dds_manager
            print(f"dds_manager: {dds_manager}")
            _g1_robot_dds = dds_manager.get_object("g129")
            print("[g1_state] G1 robot DDS communication instance obtained")
            
            # register the cleanup function
            import atexit
            def cleanup_dds():
                try:
                    if _g1_robot_dds:
                        dds_manager.unregister_object("g129")
                        print("[g1_state] DDS communication closed correctly")
                except Exception as e:
                    print(f"[g1_state] Error closing DDS: {e}")
            atexit.register(cleanup_dds)
            
        except Exception as e:
            print(f"[g1_state] Failed to get G1 robot DDS instance: {e}")
            _g1_robot_dds = None
        
        _dds_initialized = True
    
    return _g1_robot_dds

def get_robot_boy_joint_states(
    env: ManagerBasedRLEnv,
    enable_dds: bool = True,
) -> torch.Tensor:
    """get the robot body joint states, positions and velocities
    
    Args:
        env: ManagerBasedRLEnv - reinforcement learning environment instance
        enable_dds: bool - whether to enable the DDS publish function
    
    Returns:
        torch.Tensor
        - the first 29 elements are joint positions
        - the middle 29 elements are joint velocities
        - the last 29 elements are joint torques
    """
    # get all joint states
    joint_pos = env.scene["robot"].data.joint_pos
    joint_vel = env.scene["robot"].data.joint_vel
    joint_torque = env.scene["robot"].data.applied_torque  # use applied_torque to get joint torques
    device = joint_pos.device
    batch = joint_pos.shape[0]

    # get the body joint indices
    # boy_joint_names = get_robot_boy_joint_names()
    # all_joint_names = env.scene["robot"].data.joint_names
    # boy_joint_indices = [all_joint_names.index(name) for name in boy_joint_names]
    # print(f"boy_joint_indices: {boy_joint_indices}")

    # é¢„è®¡ç®—å¹¶ç¼“å­˜ç´¢å¼•å¼ é‡ï¼ˆåˆ—ç´¢å¼•ï¼‰
    global _obs_cache
    if _obs_cache["device"] != device or _obs_cache["boy_idx_t"] is None:
        boy_joint_indices = [3, 7, 0, 11, 15, 19, 4, 8, 1, 12, 16, 20, 5, 9, 13, 17, 21, 23, 25, 6, 10, 14, 18, 22, 24, 26]
#[0, 3, 6, 9, 13, 17, 1, 4, 7, 10, 14, 18, 2, 5, 8, 11, 15, 19, 21, 23, 25, 27, 12, 16, 20, 22, 24, 26, 28]
        _obs_cache["boy_idx_t"] = torch.tensor(boy_joint_indices, dtype=torch.long, device=device)
        _obs_cache["device"] = device
        _obs_cache["batch"] = None  # force re-init batch-shaped buffers

    idx_t = _obs_cache["boy_idx_t"]
    n = idx_t.numel()

    # é¢„åˆ†é…/å¤ç”¨ batch å½¢çŠ¶ç´¢å¼•ä¸è¾“å‡ºç¼“å†²
    if _obs_cache["batch"] != batch or _obs_cache["boy_idx_batch"] is None:
        _obs_cache["boy_idx_batch"] = idx_t.unsqueeze(0).expand(batch, n)
        _obs_cache["pos_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["vel_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["torque_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["combined_buf"] = torch.empty(batch, n * 3, device=device, dtype=joint_pos.dtype)
        _obs_cache["batch"] = batch

    idx_batch = _obs_cache["boy_idx_batch"]
    pos_buf = _obs_cache["pos_buf"]
    vel_buf = _obs_cache["vel_buf"]
    torque_buf = _obs_cache["torque_buf"]
    combined_buf = _obs_cache["combined_buf"]

    # ä½¿ç”¨ gather(out=...) å¡«å……ï¼Œé¿å…æ–°å¼ é‡åˆ†é…
    try:
        torch.gather(joint_pos, 1, idx_batch, out=pos_buf)
        torch.gather(joint_vel, 1, idx_batch, out=vel_buf)
        torch.gather(joint_torque, 1, idx_batch, out=torque_buf)
    except TypeError:
        pos_buf.copy_(torch.gather(joint_pos, 1, idx_batch))
        vel_buf.copy_(torch.gather(joint_vel, 1, idx_batch))
        torque_buf.copy_(torch.gather(joint_torque, 1, idx_batch))

    # ç»„åˆä¸ºä¸€ä¸ªç¼“å†²ï¼Œé¿å… cat åˆ†é…
    combined_buf[:, 0:n].copy_(pos_buf)
    combined_buf[:, n:2*n].copy_(vel_buf)
    combined_buf[:, 2*n:3*n].copy_(torque_buf)

    # write to DDSï¼ˆé™é€Ÿå‘å¸ƒï¼Œé¿å…é«˜é¢‘CPUæ‹·è´ï¼‰
    if enable_dds and combined_buf.shape[0] > 0:
        try:
            import time
            now_ms = int(time.time() * 1000)
            if now_ms - _obs_cache["dds_last_ms"] >= _obs_cache["dds_min_interval_ms"]:
                g1_robot_dds = _get_g1_robot_dds_instance()
                if g1_robot_dds:
                    imu_data = get_robot_imu_data(env)
                    if imu_data.shape[0] > 0:
                        g1_robot_dds.write_robot_state(
                            pos_buf[0].contiguous().cpu().numpy(),
                            vel_buf[0].contiguous().cpu().numpy(),
                            torque_buf[0].contiguous().cpu().numpy(),
                            imu_data[0].contiguous().cpu().numpy(),
                        )
                        _obs_cache["dds_last_ms"] = now_ms
        except Exception as e:
            print(f"[g1_state] Error writing robot state to DDS: {e}")
    
    return combined_buf


def get_gravity_quaternion_from_root_state(env: ManagerBasedRLEnv):
    body_names = env.scene["robot"].data.body_names
    imu_pelvis_idx = body_names.index("imu_in_pelvis")
    imu_torso_idx = body_names.index("imu_in_torso")
    print(f"imu_pelvis_idx: {imu_pelvis_idx}")
    print(f"imu_torso_idx: {imu_torso_idx}")
    pose = env.scene["robot"].data.body_link_pose_w  # [num_links, 7] (pos + quat)
    vel = env.scene["robot"].data.body_link_vel_w    # [num_links, 6] (lin_vel + ang_vel)

    # å–å‡ºIMUä½ç½®+æ—‹è½¬
    pelvis_pose = pose[:, imu_pelvis_idx, :]  # [B, 7]
    torso_pose = pose[:, imu_torso_idx, :]

    # å–å‡ºIMUçº¿é€Ÿåº¦+è§’é€Ÿåº¦
    pelvis_vel = vel[:, imu_pelvis_idx, :]    # [B, 6]
    torso_vel = vel[:, imu_torso_idx, :]
    return pelvis_pose, pelvis_vel, torso_pose, torso_vel

def get_robot_imu_data(
    env: ManagerBasedRLEnv,
) -> torch.Tensor:
    """get the robot IMU data
    
    Args:
        env: ManagerBasedRLEnv - reinforcement learning environment instance
    
    Returns:
        torch.Tensor
        - the first 3 elements are position
        - the next 4 elements are rotation quaternion
        - the next 3 elements are linear velocity
        - the last 3 elements are angular velocity
    """
    # get the robot root state
    root_state = env.scene["robot"].data.root_state_w
    # print(env.scene["robot"].data.__dict__.keys())
    # pelvis_pose, pelvis_vel, torso_pose, torso_vel = get_gravity_quaternion_from_root_state(env)
    # print(f"pelvis_pose: {pelvis_pose}")
    # print(f"pelvis_vel: {pelvis_vel}")
    # print(f"torso_pose: {torso_pose}")
    # print(f"torso_vel: {torso_vel}")
    # extract the position, rotation, velocity and angular velocity
    pos = root_state[:, :3]  # position
    quat = root_state[:, 3:7]  # rotation quaternion
    vel = root_state[:, 7:10]  # linear velocity
    ang_vel = root_state[:, 10:13]  # angular velocity
    # pos = torso_pose[:, :3]
    # quat = torso_pose[:, 3:7]
    # vel = torso_vel[:, :3]
    # ang_vel = torso_vel[:, 3:6]
    # qu = get_gravity_quaternion(env)
    # print(f"qu: {qu}")
    # print(f"quat: {quat}")
    # concatenate all data
    imu_data = torch.cat([pos, quat, vel, ang_vel], dim=1)
    
    return imu_data



# def get_robot_imu_data(env):
#     data = env.scene["robot"].data

#     # quaternion from root_state_w
#     root_state = data._root_state_w  # [B, 13]: [pos(3), quat(4), vel(3), ang_vel(3)]
#     quaternion = root_state[:, 3:7]

#     # gyroscope from root_state_w angular velocity
#     gyroscope = root_state[:, 10:13]

#     # accelerometer: root COM acceleration
#     accelerometer = data._root_com_acc_w[:, :3]  # [B, 3]

#     # convert quaternion to RPY (Roll, Pitch, Yaw)
#     rpy = quaternion_to_rpy(quaternion)

#     return {
#         "quaternion": quaternion,
#         "gyroscope": gyroscope,
#         "accelerometer": accelerometer,
#         "rpy": rpy
#     }

def quaternion_to_rpy(quat: torch.Tensor) -> torch.Tensor:
    """
    Convert quaternion (w, x, y, z) to roll, pitch, yaw (radians).
    """
    w, x, y, z = quat[:, 0], quat[:, 1], quat[:, 2], quat[:, 3]

    t0 = +2.0 * (w * x + y * z)
    t1 = +1.0 - 2.0 * (x * x + y * y)
    roll = torch.atan2(t0, t1)

    t2 = +2.0 * (w * y - z * x)
    t2 = torch.clamp(t2, -1.0, 1.0)
    pitch = torch.asin(t2)

    t3 = +2.0 * (w * z + x * y)
    t4 = +1.0 - 2.0 * (y * y + z * z)
    yaw = torch.atan2(t3, t4)

    return torch.stack([roll, pitch, yaw], dim=1)

===== tasks/common_observations/inspire_state.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""
gripper state
"""      

from __future__ import annotations

import torch
from typing import TYPE_CHECKING
import sys
import os
if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedRLEnv


import torch


_obs_cache = {
    "device": None,
    "batch": None,
    "inspire_idx_t": None,
    "inspire_idx_batch": None,
    "pos_buf": None,
    "vel_buf": None,
    "torque_buf": None,
    "dds_last_ms": 0,
    "dds_min_interval_ms": 20,
}

def get_robot_girl_joint_names() -> list[str]:
    return [
        "R_pinky_proximal_joint",
        "R_ring_proximal_joint",
        "R_middle_proximal_joint",
        "R_index_proximal_joint",
        "R_thumb_proximal_pitch_joint",
        "R_thumb_proximal_yaw_joint",
        "L_pinky_proximal_joint",
        "L_ring_proximal_joint",
        "L_middle_proximal_joint",
        "L_index_proximal_joint",
        "L_thumb_proximal_pitch_joint",
        "L_thumb_proximal_yaw_joint",
    ]

# global variable to cache the DDS instance
_inspire_dds = None
_dds_initialized = False

def _get_inspire_dds_instance():
    """get the DDS instance, delay initialization"""
    global _inspire_dds, _dds_initialized
    
    if not _dds_initialized or _inspire_dds is None:
        try:
            # dynamically import the DDS module
            sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(__file__)), 'dds'))
            from dds.dds_master import dds_manager
            _inspire_dds = dds_manager.get_object("inspire")
            print("[Observations] DDS communication instance obtained")
            
            # register the cleanup function
            import atexit
            def cleanup_dds():
                try:
                    if _inspire_dds:
                        dds_manager.unregister_object("inspire")
                        print("[gripper_state] DDS communication closed correctly")
                except Exception as e:
                    print(f"[gripper_state] Error closing DDS: {e}")
            atexit.register(cleanup_dds)
            
        except Exception as e:
            print(f"[Observations] Failed to get DDS instances: {e}")
            _inspire_dds = None
        
        _dds_initialized = True
    
    return _inspire_dds



def get_robot_inspire_joint_states(
    env: ManagerBasedRLEnv,
    enable_dds: bool = True,
) -> torch.Tensor:
    """get the robot gripper joint states and publish them to DDS
    
    Args:
        env: ManagerBasedRLEnv - reinforcement learning environment instance
        enable_dds: bool - whether to enable the DDS publish function
    
    è¿”å›:
        torch.Tensor
    """
    # get the gripper joint states
    joint_pos = env.scene["robot"].data.joint_pos
    joint_vel = env.scene["robot"].data.joint_vel  
    joint_torque = env.scene["robot"].data.applied_torque
    device = joint_pos.device
    batch = joint_pos.shape[0]
    

    global _obs_cache
    if _obs_cache["device"] != device or _obs_cache["inspire_idx_t"] is None:
        inspire_joint_indices = [36, 37, 35, 34, 48, 38, 31, 32, 30, 29, 43, 33]
        _obs_cache["inspire_idx_t"] = torch.tensor(inspire_joint_indices, dtype=torch.long, device=device)
        _obs_cache["device"] = device
        _obs_cache["batch"] = None
    idx_t = _obs_cache["inspire_idx_t"]
    n = idx_t.numel()


    if _obs_cache["batch"] != batch or _obs_cache["inspire_idx_batch"] is None:
        _obs_cache["inspire_idx_batch"] = idx_t.unsqueeze(0).expand(batch, n)
        _obs_cache["pos_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["vel_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["torque_buf"] = torch.empty(batch, n, device=device, dtype=joint_pos.dtype)
        _obs_cache["batch"] = batch

    idx_batch = _obs_cache["inspire_idx_batch"]
    pos_buf = _obs_cache["pos_buf"]
    vel_buf = _obs_cache["vel_buf"]
    torque_buf = _obs_cache["torque_buf"]


    try:
        torch.gather(joint_pos, 1, idx_batch, out=pos_buf)
        torch.gather(joint_vel, 1, idx_batch, out=vel_buf)
        torch.gather(joint_torque, 1, idx_batch, out=torque_buf)
    except TypeError:
        pos_buf.copy_(torch.gather(joint_pos, 1, idx_batch))
        vel_buf.copy_(torch.gather(joint_vel, 1, idx_batch))
        torque_buf.copy_(torch.gather(joint_torque, 1, idx_batch))
    
    # publish to DDS (only publish the data of the first environment)
    if enable_dds and len(pos_buf) > 0:
        try:
            import time
            now_ms = int(time.time() * 1000)
            if now_ms - _obs_cache["dds_last_ms"] >= _obs_cache["dds_min_interval_ms"]:
                inspire_dds = _get_inspire_dds_instance()
                if inspire_dds:
                    pos = pos_buf[0].contiguous().cpu().numpy()
                    vel = vel_buf[0].contiguous().cpu().numpy()
                    torque = torque_buf[0].contiguous().cpu().numpy()
                    # write the gripper state to shared memory
                    inspire_dds.write_inspire_state(pos, vel, torque)
                    _obs_cache["dds_last_ms"] = now_ms
        except Exception as e:
            print(f"[gripper_state] Failed to write to shared memory: {e}")
    
    return pos_buf




===== tasks/common_rewards/base_reward_pickplace_cylindercfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from __future__ import annotations

import torch
from typing import TYPE_CHECKING

from isaaclab.assets import RigidObject
from isaaclab.managers import SceneEntityCfg
if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedRLEnv
# global variable to cache the DDS instance
_rewards_dds = None
_dds_initialized = False
import sys
import os
def _get_rewards_dds_instance():
    """get the DDS instance, delay initialization"""
    global _rewards_dds, _dds_initialized
    
    if not _dds_initialized or _rewards_dds is None:
        try:
            # dynamically import the DDS module
            sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(__file__)), 'dds'))
            from dds.dds_master import dds_manager
            
            _rewards_dds = dds_manager.get_object("rewards")
            print("[Observations Rewards] DDS communication instance obtained")
            
            # register the cleanup function
            import atexit
            def cleanup_dds():
                try:
                    if _rewards_dds:
                        dds_manager.unregister_object("rewards")
                        print("[rewards_dds] DDS communication closed correctly")
                except Exception as e:
                    print(f"[rewards_dds] Error closing DDS: {e}")
            atexit.register(cleanup_dds)
            
        except Exception as e:
            print(f"[Observations Rewards] Failed to get DDS instances: {e}")
            _rewards_dds = None
        
        _dds_initialized = True
    
    return _rewards_dds
def compute_reward(
    env: ManagerBasedRLEnv,
    object_cfg: SceneEntityCfg = SceneEntityCfg("object"),
    min_x: float = -0.42,                # minimum x position threshold
    max_x: float = 1.0,                # maximum x position threshold
    min_y: float = 0.2,                # minimum y position threshold
    max_y: float = 0.7,                # maximum y position threshold
    min_height: float = 0.5,
    post_min_x: float = 0.28,
    post_max_x: float = 0.96,
    post_min_y: float = 0.24,
    post_max_y: float = 0.57,
    post_min_height: float = 0.81,
    post_max_height: float = 0.9,
) -> torch.Tensor:
   # when the object is not in the set return, reset

    interval = getattr(env, "_reward_interval", 1) or 1
    counter = getattr(env, "_reward_counter", 0)
    last = getattr(env, "_reward_last", None)
    if interval > 1 and last is not None and counter % interval != 0:
        env._reward_counter = counter + 1
        return last

    # 1. get object entity from the scene
    object: RigidObject = env.scene[object_cfg.name]
    
    # 2. get object position
    wheel_x = object.data.root_pos_w[:, 0]         # x position
    wheel_y = object.data.root_pos_w[:, 1]        # y position
    wheel_height = object.data.root_pos_w[:, 2]   # z position (height)

    # element-wise operations
    done_x = (wheel_x < max_x) & (wheel_x > min_x)
    done_y = (wheel_y < max_y) & (wheel_y > min_y)
    done_height = (wheel_height > min_height)
    done = done_x & done_y & done_height

    # 3. get post position conditions
    done_post_x = (wheel_x < post_max_x) & (wheel_x > post_min_x)
    done_post_y = (wheel_y < post_max_y) & (wheel_y > post_min_y)
    done_post_height = (wheel_height > post_min_height) & (wheel_height < post_max_height)
    done_post = done_post_x & done_post_y & done_post_height

    # Create reward tensor for all environments
    reward = torch.zeros(env.num_envs, device=env.device, dtype=torch.float)
    
    # Set rewards based on conditions
    reward[~done] = -1.0  # Not in valid area
    reward[done_post] = 1.0  # In target post area
    reward[done & ~done_post] = 0.0  # In valid area but not target

    rewards_dds = _get_rewards_dds_instance()
    if rewards_dds:
        rewards_dds.write_rewards_data(reward)  
    env._reward_last = reward
    env._reward_counter = counter + 1
    return reward


===== tasks/common_rewards/base_reward_pickplace_redblock.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from __future__ import annotations

import torch
from typing import TYPE_CHECKING
import sys
import os
from isaaclab.assets import RigidObject
from isaaclab.managers import SceneEntityCfg
if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedRLEnv
# global variable to cache the DDS instance
_rewards_dds = None
_dds_initialized = False
import sys
import os
def _get_rewards_dds_instance():
    """get the DDS instance, delay initialization"""
    global _rewards_dds, _dds_initialized
    
    if not _dds_initialized or _rewards_dds is None:
        try:
            # dynamically import the DDS module
            sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(__file__)), 'dds'))
            from dds.dds_master import dds_manager
            
            _rewards_dds = dds_manager.get_object("rewards")
            print("[Observations Rewards] DDS communication instance obtained")
            
            # register the cleanup function
            import atexit
            def cleanup_dds():
                try:
                    if _rewards_dds:
                        dds_manager.unregister_object("rewards")
                        print("[rewards_dds] DDS communication closed correctly")
                except Exception as e:
                    print(f"[rewards_dds] Error closing DDS: {e}")
            atexit.register(cleanup_dds)
            
        except Exception as e:
            print(f"[Observations Rewards] Failed to get DDS instances: {e}")
            _rewards_dds = None
        
        _dds_initialized = True
    
    return _rewards_dds
def compute_reward(
    env: ManagerBasedRLEnv,
    object_cfg: SceneEntityCfg = SceneEntityCfg("object"),
    min_x: float = -5.4,                # minimum x position threshold
    max_x: float = -2.9,                # maximum x position threshold
    min_y: float = -5.05,                # minimum y position threshold
    max_y: float = -2.8,                # maximum y position threshold
    post_min_x: float = -4.2125,
    post_max_x: float = -4.1755,
    post_min_y: float = -3.9606,
    post_max_y: float = -3.9121,
    min_height: float = 0.5,
    post_min_height: float = 0.82,
    post_max_height: float = 0.825,
) -> torch.Tensor:
   # when the object is not in the set return, reset
    interval = getattr(env, "_reward_interval", 1) or 1
    counter = getattr(env, "_reward_counter", 0)
    last = getattr(env, "_reward_last", None)
    if interval > 1 and last is not None and counter % interval != 0:
        env._reward_counter = counter + 1
        return last

    # 1. get object entity from the scene
    object: RigidObject = env.scene[object_cfg.name]
    
    # 2. get object position
    wheel_x = object.data.root_pos_w[:, 0]         # x position
    wheel_y = object.data.root_pos_w[:, 1]        # y position
    wheel_height = object.data.root_pos_w[:, 2]   # z position (height)

    # element-wise operations
    done_x = (wheel_x < max_x) & (wheel_x > min_x)
    done_y = (wheel_y < max_y) & (wheel_y > min_y)
    done_height = (wheel_height > min_height)
    done = done_x & done_y & done_height

    # 3. get post position conditions
    done_post_x = (wheel_x < post_max_x) & (wheel_x > post_min_x)
    done_post_y = (wheel_y < post_max_y) & (wheel_y > post_min_y)
    done_post_height = (wheel_height > post_min_height) & (wheel_height < post_max_height)
    done_post = done_post_x & done_post_y & done_post_height

    # Create reward tensor for all environments
    reward = torch.zeros(env.num_envs, device=env.device, dtype=torch.float)
    
    # Set rewards based on conditions
    reward[~done] = -1.0  # Not in valid area
    reward[done_post] = 1.0  # In target post area
    reward[done & ~done_post] = 0.0  # In valid area but not target

    env._reward_last = reward
    env._reward_counter = counter + 1
    rewards_dds = _get_rewards_dds_instance()
    if rewards_dds:
        rewards_dds.write_rewards_data(reward)
    return reward


===== tasks/common_rewards/base_reward_stack_rgyblock.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from __future__ import annotations

import torch
from typing import TYPE_CHECKING

from isaaclab.assets import RigidObject
from isaaclab.managers import SceneEntityCfg

if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedRLEnv

# global variable to cache the DDS instance
_rewards_dds = None
_dds_initialized = False
import sys
import os
def _get_rewards_dds_instance():
    """get the DDS instance, delay initialization"""
    global _rewards_dds, _dds_initialized
    
    if not _dds_initialized or _rewards_dds is None:
        try:
            # dynamically import the DDS module
            sys.path.insert(0, os.path.join(os.path.dirname(os.path.dirname(__file__)), 'dds'))
            from dds.dds_master import dds_manager
            
            _rewards_dds = dds_manager.get_object("rewards")
            print("[Observations Rewards] DDS communication instance obtained")
            
            # register the cleanup function
            import atexit
            def cleanup_dds():
                try:
                    if _rewards_dds:
                        dds_manager.unregister_object("rewards")
                        print("[rewards_dds] DDS communication closed correctly")
                except Exception as e:
                    print(f"[rewards_dds] Error closing DDS: {e}")
            atexit.register(cleanup_dds)
            
        except Exception as e:
            print(f"[Observations Rewards] Failed to get DDS instances: {e}")
            _rewards_dds = None
        
        _dds_initialized = True
    
    return _rewards_dds
def compute_reward(
    env: ManagerBasedRLEnv,
    red_block_cfg: SceneEntityCfg = SceneEntityCfg("red_block"),
    yellow_block_cfg: SceneEntityCfg = SceneEntityCfg("yellow_block"),
    green_block_cfg: SceneEntityCfg = SceneEntityCfg("green_block"),
    min_x: float = -5.4,                # minimum x position threshold
    max_x: float = -2.9,                #  maximum x position threshold
    min_y: float = -5.05,               # minimum y position threshold
    max_y: float = -2.8,                # maximum y  position threshold
    min_height: float = 0.5,            # minimum height threshold
    post_min_x: float = -4.22,        # minimum x position threshold
    post_max_x: float = -4.16,        # maximum x position threshold
    post_min_y: float = -3.98,        # minimum y position threshold
    post_max_y: float = -3.91,        # maximum y position threshold
    post_min_height: float = 0.815,      # minimum height threshold
    post_max_height: float = 0.83,      # maximum height threshold
    stack_type: str = "red_yellow_green", # stack order type
    block_height: float = 0.05,         # height of a single block
) -> torch.Tensor:

   # when the object is not in the set return, reset
    interval = getattr(env, "_reward_interval", 1) or 1
    counter = getattr(env, "_reward_counter", 0)
    last = getattr(env, "_reward_last", None)
    if interval > 1 and last is not None and counter % interval != 0:
        env._reward_counter = counter + 1
        return last

    # 1. get object entity from the scene
    red_block: RigidObject = env.scene[red_block_cfg.name]
    yellow_block: RigidObject = env.scene[yellow_block_cfg.name]
    green_block: RigidObject = env.scene[green_block_cfg.name]
    
    # 2. get object position
    red_block_x = red_block.data.root_pos_w[:, 0]         # x position
    red_block_y = red_block.data.root_pos_w[:, 1]        # y position
    red_block_height = red_block.data.root_pos_w[:, 2]   # z position (height)

    yellow_block_x = yellow_block.data.root_pos_w[:, 0]         # x position
    yellow_block_y = yellow_block.data.root_pos_w[:, 1]        # y position
    yellow_block_height = yellow_block.data.root_pos_w[:, 2]   # z position (height)

    green_block_x = green_block.data.root_pos_w[:, 0]         # x position
    green_block_y = green_block.data.root_pos_w[:, 1]        # y position
    green_block_height = green_block.data.root_pos_w[:, 2]   # z position (height)
    
    # check if all blocks are in the working area
    red_done_x = (red_block_x < max_x) & (red_block_x > min_x)
    red_done_y = (red_block_y < max_y) & (red_block_y > min_y)
    red_done_height = (red_block_height > min_height)
    red_in_area = red_done_x & red_done_y & red_done_height

    yellow_done_x = (yellow_block_x < max_x) & (yellow_block_x > min_x)
    yellow_done_y = (yellow_block_y < max_y) & (yellow_block_y > min_y)
    yellow_done_height = (yellow_block_height > min_height)
    yellow_in_area = yellow_done_x & yellow_done_y & yellow_done_height

    green_done_x = (green_block_x < max_x) & (green_block_x > min_x)
    green_done_y = (green_block_y < max_y) & (green_block_y > min_y)
    green_done_height = (green_block_height > min_height)
    green_in_area = green_done_x & green_done_y & green_done_height

    # all blocks are in the working area
    all_in_area = red_in_area & yellow_in_area & green_in_area

    # create reward tensor
    reward = torch.zeros(env.num_envs, device=env.device, dtype=torch.float)
    
    # basic penalty: if any block is not in the working area
    reward[~all_in_area] = -1.0
    
    # parse stack order
    stack_order = stack_type.split("_")
    first_block = stack_order[0]
    second_block = stack_order[1] 
    third_block = stack_order[2]
    
    # create a dictionary of block positions and heights for dynamic access
    block_positions = {
        "red": (red_block_x, red_block_y, red_block_height),
        "yellow": (yellow_block_x, yellow_block_y, yellow_block_height),
        "green": (green_block_x, green_block_y, green_block_height)
    }
    
    # get the position information of each block
    first_x, first_y, first_height = block_positions[first_block]
    second_x, second_y, second_height = block_positions[second_block]
    third_x, third_y, third_height = block_positions[third_block]
    
    # check if each block is in the correct stack position and height
    # first block (bottom)
    first_block_in_area = (first_x < post_max_x) & (first_x > post_min_x) & \
                         (first_y < post_max_y) & (first_y > post_min_y) & \
                         (first_height >= post_min_height) & (first_height < post_max_height)
    
    # second block (middle)
    second_block_in_area = (second_x < post_max_x) & (second_x > post_min_x) & \
                          (second_y < post_max_y) & (second_y > post_min_y) & \
                          (second_height >= post_min_height + block_height) & (second_height < post_max_height +  block_height)
    
    # third block (top)
    third_block_in_area = (third_x < post_max_x) & (third_x > post_min_x) & \
                         (third_y < post_max_y) & (third_y > post_min_y) & \
                         (third_height >= post_min_height + 2 * block_height) & (third_height < post_max_height + 2 * block_height)
    
    # hierarchical reward system
    reward[all_in_area & first_block_in_area] = 0.3  # bottom block correct
    reward[all_in_area & first_block_in_area & second_block_in_area] = 0.6  # bottom and middle block correct
    reward[all_in_area & first_block_in_area & second_block_in_area & third_block_in_area] = 1.0  # perfect stack

    rewards_dds = _get_rewards_dds_instance()
    if rewards_dds:
        rewards_dds.write_rewards_data(reward)  
    env._reward_last = reward
    env._reward_counter = counter + 1
    return reward


===== tasks/common_scene/base_scene_pick_redblock_into_drawer.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0     
"""
public base scene configuration module
provides reusable scene element configurations, such as tables, objects, ground, lights, etc.
"""
import isaaclab.sim as sim_utils
from isaaclab.assets import  AssetBaseCfg, RigidObjectCfg, ArticulationCfg
from isaaclab.scene import InteractiveSceneCfg
from isaaclab.sim.spawners.from_files.from_files_cfg import GroundPlaneCfg, UsdFileCfg
from isaaclab.utils import configclass
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR
from isaaclab.actuators.actuator_cfg import ImplicitActuatorCfg
from isaaclab.sensors import FrameTransformerCfg
from isaaclab.markers.config import FRAME_MARKER_CFG  # isort: skip
from isaaclab.sensors.frame_transformer import OffsetCfg
from isaaclab.utils.assets import ISAACLAB_NUCLEUS_DIR
FRAME_MARKER_SMALL_CFG = FRAME_MARKER_CFG.copy()
FRAME_MARKER_SMALL_CFG.markers["frame"].scale = (0.10, 0.10, 0.10)
from tasks.common_config import   CameraBaseCfg  
import os
project_root = os.environ.get("PROJECT_ROOT")


@configclass
class TablePickRedblockIntoDrawerSceneCfg(InteractiveSceneCfg): # inherit from the interactive scene configuration class
    """object table scene configuration class
    defines a complete scene containing robot, object, table, etc.
    """
      # 1. room wall configuration - simplified configuration to avoid rigid body property conflicts
    room_walls = AssetBaseCfg(
        prim_path="/World/envs/env_.*/Room",
        init_state=AssetBaseCfg.InitialStateCfg(
            pos=[0.0, 0.0, 0],  # room center point
            rot=[1.0, 0.0, 0.0, 0.0]
        ),
        spawn=UsdFileCfg(
            usd_path=f"{project_root}/assets/objects/small_warehouse/small_warehouse_digital_twin.usd",  # use simple room model
        ),
    )


    # 1. table configuration
    # packing_table = AssetBaseCfg(
    #     prim_path="/World/envs/env_.*/PackingTable",    # table in the scene
    #     init_state=AssetBaseCfg.InitialStateCfg(pos=[-4.3,-4.2,-0.2],   # initial position [x, y, z]
    #                                             rot=[1.0, 0.0, 0.0, 0.0]), # initial rotation [x, y, z, w]
    #     spawn=UsdFileCfg(
    #         usd_path=f"{ASSET_DIR}/factory_peg_8mm.usd",    # table model file
    #         # rigid_props=sim_utils.RigidBodyPropertiesCfg(kinematic_enabled=True),    # set to kinematic object
    #     ),
    # )
    # Object
    object = RigidObjectCfg(
        prim_path="/World/envs/env_.*/Red_block",
        init_state=RigidObjectCfg.InitialStateCfg(
            pos=[-2.5, -4.15, 0.84],
            rot=[1, 0, 0, 0]
        ),
        spawn=sim_utils.CuboidCfg(
            size=(0.05, 0.05, 0.05),
            rigid_props=sim_utils.RigidBodyPropertiesCfg(
                disable_gravity=False,
                retain_accelerations=False
            ),
            mass_props=sim_utils.MassPropertiesCfg(mass=3.0),
            collision_props=sim_utils.CollisionPropertiesCfg(
                collision_enabled=True,
                contact_offset=0.01,
                rest_offset=0.0
            ),
            visual_material=sim_utils.PreviewSurfaceCfg(
                diffuse_color=(1.0, 0.0, 0.0), metallic=0
            ),
            physics_material=sim_utils.RigidBodyMaterialCfg(
                friction_combine_mode="max",
                restitution_combine_mode="min",
                static_friction=10,
                dynamic_friction=0.5,
                restitution=0.0,
            ),
        ),
    )



    cabinet = ArticulationCfg(
        prim_path="/World/envs/env_.*/Cabinet",
        spawn=sim_utils.UsdFileCfg(
            ## update sektion_cabinet_instanceable.usd with the bottom_drawer's collider approximation as convex_decomposition.
            usd_path=f"{project_root}/assets/objects/drawers/cabinet_collider.usd",
            # usd_path=f"{ISAAC_NUCLEUS_DIR}/Isaac/Props/Furniture/Sektion_Cabinet/sektion_cabinet_instanceable.usd",
            activate_contact_sensors=False,
            # è®¾ç½®åˆšä½“å±æ€§ï¼Œä¸ºæŠ½å±‰æŠŠæ‰‹ä¼˜åŒ–æ‘©æ“¦åŠ›
            rigid_props=sim_utils.RigidBodyPropertiesCfg(
                disable_gravity=False,
                retain_accelerations=False,
            ),
        ),
        init_state=ArticulationCfg.InitialStateCfg(
            pos=(-2.5,-4.35,0.45),
            rot=(0.7071, 0, 0, 0.7071),
            joint_pos={
                "door_left_joint": 0.0,
                "door_right_joint": 0.0,
                "drawer_bottom_joint": 0.0,
                "drawer_top_joint": 0.15,
            },
        ),
        actuators={
            "drawers": ImplicitActuatorCfg(
                joint_names_expr=["drawer_top_joint", "drawer_bottom_joint"],
                effort_limit_sim=100.0,
                velocity_limit_sim=100.0,
                stiffness=100.0,
                damping=1.0,
            ),
            "doors": ImplicitActuatorCfg(
                joint_names_expr=["door_left_joint", "door_right_joint"],
                effort_limit_sim=100.0,
                velocity_limit_sim=100.0,
                stiffness=100.0,
                damping=1.0,
            ),
        },
    )
    
    
    cabinet_frame = FrameTransformerCfg(
        prim_path="/World/envs/env_.*/Cabinet/cabinet/sektion",
        debug_vis=True,
        visualizer_cfg=FRAME_MARKER_SMALL_CFG.replace(prim_path="/Visuals/CabinetFrameTransformer"),
        target_frames=[
            FrameTransformerCfg.FrameCfg(
                prim_path="/World/envs/env_.*/Cabinet/cabinet/drawer_handle_bottom",
                name="drawer_handle_bottom",
                offset=OffsetCfg(
                    pos=(0.305, 0.0, 0.01),
                    rot=(0.5, 0.5, -0.5, -0.5),  # align with end-effector frame
                ),
            ),
        ],
    )
    # Ground plane
    # 3. ground configuration
    # ground = AssetBaseCfg(
    #     prim_path="/World/GroundPlane",    # ground in the scene
    #     spawn=GroundPlaneCfg( ),    # ground configuration
    # )

    # Lights
    # 4. light configuration
    light = AssetBaseCfg(
        prim_path="/World/light",   # light in the scene
        spawn=sim_utils.DomeLightCfg(color=(0.75, 0.75, 0.75), # light color (white)
                                     intensity=3000.0),    # light intensity
    )



    world_camera = CameraBaseCfg.get_camera_config(prim_path="/World/PerspectiveCamera",
                                                    pos_offset=(-2.5, -4.8, 1.8),
                                                    rot_offset=( -0.3173,0.94833, 0.0, 0.0))




===== tasks/common_scene/base_scene_pickplace_cylindercfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
"""
public base scene configuration module
provides reusable scene element configurations, such as tables, objects, ground, lights, etc.
"""
import isaaclab.sim as sim_utils
from isaaclab.assets import  AssetBaseCfg, RigidObjectCfg
from isaaclab.scene import InteractiveSceneCfg
from isaaclab.sim.spawners.from_files.from_files_cfg import GroundPlaneCfg, UsdFileCfg
from isaaclab.utils import configclass
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR
from tasks.common_config import   CameraBaseCfg  # isort: skip
import os
project_root = os.environ.get("PROJECT_ROOT")
@configclass
class TableCylinderSceneCfg(InteractiveSceneCfg): # inherit from the interactive scene configuration class
    """object table scene configuration class
    defines a complete scene containing robot, object, table, etc.
    """
      # 1. room wall configuration - simplified configuration to avoid rigid body property conflicts
    room_walls = AssetBaseCfg(
        prim_path="/World/envs/env_.*/Room",
        init_state=AssetBaseCfg.InitialStateCfg(
            pos=[0.0, 0.0, 0],  # æˆ¿é—´ä¸­å¿ƒç‚¹
            rot=[1.0, 0.0, 0.0, 0.0]
        ),
        spawn=UsdFileCfg(
            usd_path=f"{ISAAC_NUCLEUS_DIR}/Environments/Simple_Warehouse/warehouse.usd",  # use simple room model
        ),
    )
    # print(f"ISAAC_NUCLEUS_DIR: {ISAAC_NUCLEUS_DIR}")
    #ISAAC_NUCLEUS_DIR: http://omniverse-content-production.s3-us-west-2.amazonaws.com/Assets/Isaac/4.5/Isaac
        # 1. table configuration
    packing_table = AssetBaseCfg(
        prim_path="/World/envs/env_.*/PackingTable",    # table in the scene
        init_state=AssetBaseCfg.InitialStateCfg(pos=[0.0, 0.55, -0.2],   # initial position [x, y, z]
                                                rot=[1.0, 0.0, 0.0, 0.0]), # initial rotation [x, y, z, w]
        spawn=UsdFileCfg(
            # usd_path=f"{ISAAC_NUCLEUS_DIR}/Props/PackingTable/packing_table.usd",    # table model file
            usd_path=f"{project_root}/assets/objects/PackingTable/PackingTable.usd",    # table model file
            rigid_props=sim_utils.RigidBodyPropertiesCfg(kinematic_enabled=True),    # set to kinematic object
        ),
    )

    packing_table_2 = AssetBaseCfg(
        prim_path="/World/envs/env_.*/PackingTable_2",   
        init_state=AssetBaseCfg.InitialStateCfg(pos=[-3.5, 0.55, -0.2],  
                                                rot=[1.0, 0.0, 0.0, 0.0]), 
        spawn=UsdFileCfg(
            usd_path=f"{project_root}/assets/objects/PackingTable/PackingTable.usd",    # table model file
            rigid_props=sim_utils.RigidBodyPropertiesCfg(kinematic_enabled=True),   
        ),
    )
    packing_table_3 = AssetBaseCfg(
        prim_path="/World/envs/env_.*/PackingTable_3",   
        init_state=AssetBaseCfg.InitialStateCfg(pos=[3.5, 0.55, -0.2],  
                                                rot=[1.0, 0.0, 0.0, 0.0]), 
        spawn=UsdFileCfg(
            usd_path=f"{project_root}/assets/objects/PackingTable/PackingTable.usd",    # table model file
            rigid_props=sim_utils.RigidBodyPropertiesCfg(kinematic_enabled=True),   
        ),
    )
    packing_table_4 = AssetBaseCfg(
        prim_path="/World/envs/env_.*/PackingTable_4",   
        init_state=AssetBaseCfg.InitialStateCfg(pos=[3.5, -5, -0.2],  
                                                rot=[1.0, 0.0, 0.0, 0.0]), 
        spawn=UsdFileCfg(
            usd_path=f"{project_root}/assets/objects/PackingTable/PackingTable.usd",    # table model file
            rigid_props=sim_utils.RigidBodyPropertiesCfg(kinematic_enabled=True),   
        ),
    )
    packing_table_5 = AssetBaseCfg(
        prim_path="/World/envs/env_.*/PackingTable_5",   
        init_state=AssetBaseCfg.InitialStateCfg(pos=[-3.5, -5, -0.2],  
                                                rot=[1.0, 0.0, 0.0, 0.0]), 
        spawn=UsdFileCfg(
            usd_path=f"{project_root}/assets/objects/PackingTable/PackingTable.usd",    # table model file
            rigid_props=sim_utils.RigidBodyPropertiesCfg(kinematic_enabled=True),   
        ),
    )
    packing_table_6 = AssetBaseCfg(
        prim_path="/World/envs/env_.*/PackingTable_6",   
        init_state=AssetBaseCfg.InitialStateCfg(pos=[0.0, -5, -0.2],  
                                                rot=[1.0, 0.0, 0.0, 0.0]), 
        spawn=UsdFileCfg(
            usd_path=f"{project_root}/assets/objects/PackingTable/PackingTable.usd",    # table model file
            rigid_props=sim_utils.RigidBodyPropertiesCfg(kinematic_enabled=True),   
        ),
    )
    # Object
    # 2. object configuration (cylinder)     
    object = RigidObjectCfg(
        prim_path="/World/envs/env_.*/Object",    # object in the scene
        init_state=RigidObjectCfg.InitialStateCfg(pos=[-0.35, 0.40, 0.84], # initial position (pos) 
                                                  rot=[1, 0, 0, 0]), # initial rotation (rot)
        spawn=sim_utils.CylinderCfg(
            radius=0.018,    # cylinder radius (radius)
            height=0.35,     # cylinder height (height)
 
            rigid_props=sim_utils.RigidBodyPropertiesCfg(
            ),    # rigid body properties configuration (rigid_props)
            mass_props=sim_utils.MassPropertiesCfg(mass=0.4),    # mass properties configuration (mass)
            collision_props=sim_utils.CollisionPropertiesCfg(),    # collision properties configuration (collision_props)
            visual_material=sim_utils.PreviewSurfaceCfg(diffuse_color=(0.15, 0.15, 0.15), metallic=1.0),    # visual material configuration (visual_material)
            physics_material=sim_utils.RigidBodyMaterialCfg(
                friction_combine_mode="max",    # friction combine mode
                restitution_combine_mode="min",    # restitution combine mode
                static_friction=1.5,    # static friction coefficient
                dynamic_friction=1.5,    # dynamic friction coefficient
                restitution=0.0,    # restitution coefficient (no restitution)
            ),
        ),
    )
    # Ground plane
    # 3. ground configuration
    # ground = AssetBaseCfg(
    #     prim_path="/World/GroundPlane",    # ground in the scene
    #     spawn=GroundPlaneCfg( ),    # ground configuration
    # )

    # Lights
    # 4. light configuration
    light = AssetBaseCfg(
        prim_path="/World/light",   # light in the scene
        spawn=sim_utils.DomeLightCfg(color=(0.75, 0.75, 0.75), # light color (white)
                                     intensity=3000.0),    # light intensity
    )

    world_camera = CameraBaseCfg.get_camera_config(prim_path="/World/PerspectiveCamera",
                                                    pos_offset=(-0.1, 3.6, 1.6),
                                                    rot_offset=( -0.00617,0.00617, 0.70708, -0.70708),
                                                    focal_length = 16.5)

===== tasks/common_scene/base_scene_pickplace_cylindercfg_wholebody.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
"""
public base scene configuration module
provides reusable scene element configurations, such as tables, objects, ground, lights, etc.
"""
import isaaclab.sim as sim_utils
from isaaclab.assets import  AssetBaseCfg, RigidObjectCfg
from isaaclab.scene import InteractiveSceneCfg
from isaaclab.sim.spawners.from_files.from_files_cfg import GroundPlaneCfg, UsdFileCfg
from isaaclab.utils import configclass
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR
from tasks.common_config import   CameraBaseCfg  # isort: skip
import os
project_root = os.environ.get("PROJECT_ROOT")
@configclass
class TableCylinderSceneCfgWH(InteractiveSceneCfg): # inherit from the interactive scene configuration class
    """object table scene configuration class
    defines a complete scene containing robot, object, table, etc.
    """
      # 1. room wall configuration - simplified configuration to avoid rigid body property conflicts
    room_walls = AssetBaseCfg(
        prim_path="/World/envs/env_.*/Room",
        init_state=AssetBaseCfg.InitialStateCfg(
            pos=[0.0, 0.0, 0],  # room center point
            rot=[1.0, 0.0, 0.0, 0.0]
        ),
        spawn=UsdFileCfg(
            usd_path=f"{project_root}/assets/objects/small_warehouse/small_warehouse_digital_twin.usd",
        ),
    )


        # 1. table configuration
    packing_table1 = AssetBaseCfg(
        prim_path="/World/envs/env_.*/PackingTable_1",    # table in the scene
        init_state=AssetBaseCfg.InitialStateCfg(pos=[-2.35644,-3.45572,-0.2],   # initial position [x, y, z]
                                                rot=[0.70091, 0.0, 0.0, 0.71325]), # initial rotation [x, y, z, w]
        spawn=UsdFileCfg(
            usd_path=f"{project_root}/assets/objects/PackingTable_2/PackingTable.usd",    # table model file
            rigid_props=sim_utils.RigidBodyPropertiesCfg(kinematic_enabled=True),    # set to kinematic object
        ),
    )

    packing_table2 = AssetBaseCfg(
        prim_path="/World/envs/env_.*/PackingTable_2",    # table in the scene
        init_state=AssetBaseCfg.InitialStateCfg(pos=[-3.97225,-4.3424,-0.2],   # initial position [x, y, z]
                                                rot=[1.0, 0.0, 0.0, 0.0]), # initial rotation [x, y, z, w]
        spawn=UsdFileCfg(
            usd_path=f"{project_root}/assets/objects/PackingTable/PackingTable.usd",    # table model file
            rigid_props=sim_utils.RigidBodyPropertiesCfg(kinematic_enabled=True),    # set to kinematic object
        ),
    )
    # # Object
    # 2. object configuration (cylinder)     
    object = RigidObjectCfg(
        prim_path="/World/envs/env_.*/Object",    # object in the scene
        init_state=RigidObjectCfg.InitialStateCfg(pos=[-2.58514,-2.78975,0.84], # initial position (pos) 
                                                  rot=[1, 0, 0, 0]), # initial rotation (rot)
        spawn=sim_utils.CylinderCfg(
            radius=0.018,    # cylinder radius (radius)
            height=0.35,     # cylinder height (height)
 
            rigid_props=sim_utils.RigidBodyPropertiesCfg(
            ),    # rigid body properties configuration (rigid_props)
            mass_props=sim_utils.MassPropertiesCfg(mass=0.4),    # mass properties configuration (mass)
            collision_props=sim_utils.CollisionPropertiesCfg(),    # collision properties configuration (collision_props)
            visual_material=sim_utils.PreviewSurfaceCfg(diffuse_color=(0.15, 0.15, 0.15), metallic=1.0),    # visual material configuration (visual_material)
            physics_material=sim_utils.RigidBodyMaterialCfg(
                friction_combine_mode="max",    # friction combine mode
                restitution_combine_mode="min",    # restitution combine mode
                static_friction=1.5,    # static friction coefficient
                dynamic_friction=1.5,    # dynamic friction coefficient
                restitution=0.0,    # restitution coefficient (no restitution)
            ),
        ),
    )
    # Ground plane


    # Lights
    # 4. light configuration
    light = AssetBaseCfg(
        prim_path="/World/light",   # light in the scene
        spawn=sim_utils.DomeLightCfg(color=(0.75, 0.75, 0.75), # light color (white)
                                     intensity=3000.0),    # light intensity
    )
    world_camera = CameraBaseCfg.get_camera_config(prim_path="/World/PerspectiveCamera",
                                                    pos_offset=(-1.9, -5.0, 1.8),
                                                    rot_offset=( -0.40614,0.78544, 0.4277, -0.16986))

===== tasks/common_scene/base_scene_pickplace_redblock.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0     
"""
public base scene configuration module
provides reusable scene element configurations, such as tables, objects, ground, lights, etc.
"""
import isaaclab.sim as sim_utils
from isaaclab.assets import  AssetBaseCfg, RigidObjectCfg
from isaaclab.scene import InteractiveSceneCfg
from isaaclab.sim.spawners.from_files.from_files_cfg import GroundPlaneCfg, UsdFileCfg
from isaaclab.utils import configclass
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR
from tasks.common_config import   CameraBaseCfg  # isort: skip
import os
project_root = os.environ.get("PROJECT_ROOT")
@configclass
class TableRedBlockSceneCfg(InteractiveSceneCfg): # inherit from the interactive scene configuration class
    """object table scene configuration class
    defines a complete scene containing robot, object, table, etc.
    """
      # 1. room wall configuration - simplified configuration to avoid rigid body property conflicts
    room_walls = AssetBaseCfg(
        prim_path="/World/envs/env_.*/Room",
        init_state=AssetBaseCfg.InitialStateCfg(
            pos=[0.0, 0.0, 0],  # room center point
            rot=[1.0, 0.0, 0.0, 0.0]
        ),
        spawn=UsdFileCfg(
            usd_path=f"{project_root}/assets/objects/small_warehouse_digital_twin/small_warehouse_digital_twin.usd",
        ),
    )


    # 1. table configuration
    packing_table = AssetBaseCfg(
        prim_path="/World/envs/env_.*/PackingTable",    # table in the scene
        init_state=AssetBaseCfg.InitialStateCfg(pos=[-4.3,-4.2,-0.2],   # initial position [x, y, z]
                                                rot=[1.0, 0.0, 0.0, 0.0]), # initial rotation [x, y, z, w]
        spawn=UsdFileCfg(
            usd_path=f"{project_root}/assets/objects/table_with_yellowbox.usd",    # table model file
            # rigid_props=sim_utils.RigidBodyPropertiesCfg(kinematic_enabled=True),    # set to kinematic object
        ),
    )
    # Object
    # 2. object configuration
    object = RigidObjectCfg(
        prim_path="/World/envs/env_.*/Object",
        init_state=RigidObjectCfg.InitialStateCfg(
            pos=[-4.25, -4.03, 0.84],
            rot=[1, 0, 0, 0]
        ),
        spawn=sim_utils.CuboidCfg(
            size=(0.06, 0.06, 0.06),
            rigid_props=sim_utils.RigidBodyPropertiesCfg(
                disable_gravity=False,
                retain_accelerations=False
            ),
            mass_props=sim_utils.MassPropertiesCfg(mass=1.0),
            collision_props=sim_utils.CollisionPropertiesCfg(
                collision_enabled=True,
                contact_offset=0.01,
                rest_offset=0.0
            ),
            visual_material=sim_utils.PreviewSurfaceCfg(
                diffuse_color=(1.0, 0.0, 0.0), metallic=0
            ),
            physics_material=sim_utils.RigidBodyMaterialCfg(
                friction_combine_mode="max",
                restitution_combine_mode="min",
                static_friction=10,
                dynamic_friction=1.5,
                restitution=0.01,
            ),
        ),
    )


    # Ground plane
    # 3. ground configuration
    # ground = AssetBaseCfg(
    #     prim_path="/World/GroundPlane",    # ground in the scene
    #     spawn=GroundPlaneCfg( ),    # ground configuration
    # )

    # Lights
    # 4. light configuration
    # light = AssetBaseCfg(
    #     prim_path="/World/light",   # light in the scene
    #     spawn=sim_utils.DomeLightCfg(color=(0.75, 0.75, 0.75), # light color (white)
    #                                  intensity=3000.0),    # light intensity
    # )



    world_camera = CameraBaseCfg.get_camera_config(prim_path="/World/PerspectiveCamera",
                                                    pos_offset=(-4.1, -4.9, 1.8),
                                                    rot_offset=( -0.3173,0.94833, 0.0, 0.0))




===== tasks/common_scene/base_scene_stack_rgyblock.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0     
"""
public base scene configuration module
provides reusable scene element configurations, such as tables, objects, ground, lights, etc.
"""
import isaaclab.sim as sim_utils
from isaaclab.assets import  AssetBaseCfg, RigidObjectCfg
from isaaclab.scene import InteractiveSceneCfg
from isaaclab.sim.spawners.from_files.from_files_cfg import GroundPlaneCfg, UsdFileCfg
from isaaclab.utils import configclass
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR
from tasks.common_config import   CameraBaseCfg  
import os
project_root = os.environ.get("PROJECT_ROOT")
@configclass
class TableRedGreenYellowBlockSceneCfg(InteractiveSceneCfg): # inherit from the interactive scene configuration class
    """object table scene configuration class
    defines a complete scene containing robot, object, table, etc.
    """
      # 1. room wall configuration - simplified configuration to avoid rigid body property conflicts
    room_walls = AssetBaseCfg(
        prim_path="/World/envs/env_.*/Room",
        init_state=AssetBaseCfg.InitialStateCfg(
            pos=[0.0, 0.0, 0],  # room center point
            rot=[1.0, 0.0, 0.0, 0.0]
        ),
        spawn=UsdFileCfg(
            usd_path=f"{project_root}/assets/objects/small_warehouse_digital_twin/small_warehouse_digital_twin.usd",  # use simple room model
        ),
    )


    # 1. table configuration
    packing_table = AssetBaseCfg(
        prim_path="/World/envs/env_.*/PackingTable",    # table in the scene
        init_state=AssetBaseCfg.InitialStateCfg(pos=[-4.3,-4.2,-0.2],   # initial position [x, y, z]
                                                rot=[1.0, 0.0, 0.0, 0.0]), # initial rotation [x, y, z, w]
        spawn=UsdFileCfg(
            usd_path=f"{project_root}/assets/objects/table_with_yellowbox.usd",    # table model file
            # rigid_props=sim_utils.RigidBodyPropertiesCfg(kinematic_enabled=True),    # set to kinematic object
        ),
    )
    # Object
    red_block = RigidObjectCfg(
        prim_path="/World/envs/env_.*/Red_block",
        init_state=RigidObjectCfg.InitialStateCfg(
            pos= [-4.1, -4.08, 0.84],
            rot=[1, 0, 0, 0]
        ),
        spawn=sim_utils.CuboidCfg(
            size=(0.05, 0.05, 0.05),
            rigid_props=sim_utils.RigidBodyPropertiesCfg(
                disable_gravity=False,
                retain_accelerations=False
            ),
            mass_props=sim_utils.MassPropertiesCfg(mass=1.0),
            collision_props=sim_utils.CollisionPropertiesCfg(
                collision_enabled=True,
                contact_offset=0.01,
                rest_offset=0.0
            ),
            visual_material=sim_utils.PreviewSurfaceCfg(
                diffuse_color=(1.0, 0.0, 0.0), metallic=0
            ),
            physics_material=sim_utils.RigidBodyMaterialCfg(
                friction_combine_mode="max",
                restitution_combine_mode="min",
                static_friction=10,
                dynamic_friction=0.5,
                restitution=0.0,
            ),
        ),
    )

    yellow_block = RigidObjectCfg(
        prim_path="/World/envs/env_.*/Yellow_block",
        init_state=RigidObjectCfg.InitialStateCfg(
            pos= [-4.25, -4.05, 0.84],
            rot=[1, 0, 0, 0]
        ),
        spawn=sim_utils.CuboidCfg(
            size=(0.05, 0.05, 0.05),
            rigid_props=sim_utils.RigidBodyPropertiesCfg(
                disable_gravity=False,
                retain_accelerations=False
            ),
            mass_props=sim_utils.MassPropertiesCfg(mass=1.0),
            collision_props=sim_utils.CollisionPropertiesCfg(
                collision_enabled=True,
                contact_offset=0.01,
                rest_offset=0.0
            ),
            visual_material=sim_utils.PreviewSurfaceCfg(
                diffuse_color=(1.0, 1.0, 0.0), metallic=0
            ),
            physics_material=sim_utils.RigidBodyMaterialCfg(
                friction_combine_mode="max",
                restitution_combine_mode="min",
                static_friction=10,
                dynamic_friction=0.5,
                restitution=0.0,
            ),
        ),
    )
    green_block = RigidObjectCfg(
        prim_path="/World/envs/env_.*/Green_block",
        init_state=RigidObjectCfg.InitialStateCfg(
            pos=  [-4.18, -4.12, 0.84] ,
            rot=[1, 0, 0, 0]
        ),
        spawn=sim_utils.CuboidCfg(
            size=(0.05, 0.05, 0.05),
            rigid_props=sim_utils.RigidBodyPropertiesCfg(
                disable_gravity=False,
                retain_accelerations=False
            ),
            mass_props=sim_utils.MassPropertiesCfg(mass=1.0),
            collision_props=sim_utils.CollisionPropertiesCfg(
                collision_enabled=True,
                contact_offset=0.01,
                rest_offset=0.0
            ),
            visual_material=sim_utils.PreviewSurfaceCfg(
                diffuse_color=(0.0, 1.0, 0.0), metallic=0
            ),
            physics_material=sim_utils.RigidBodyMaterialCfg(
                friction_combine_mode="max",
                restitution_combine_mode="min",
                static_friction=10,
                dynamic_friction=0.5,
                restitution=0.0,
            ),
        ),
    )
    # Ground plane
    # 3. ground configuration
    # ground = AssetBaseCfg(
    #     prim_path="/World/GroundPlane",    # ground in the scene
    #     spawn=GroundPlaneCfg( ),    # ground configuration
    # )

    # Lights
    # 4. light configuration
    light = AssetBaseCfg(
        prim_path="/World/light",   # light in the scene
        spawn=sim_utils.DomeLightCfg(color=(0.75, 0.75, 0.75), # light color (white)
                                     intensity=500.0),    # light intensity
    )






    world_camera = CameraBaseCfg.get_camera_config(prim_path="/World/PerspectiveCamera",
                                                    pos_offset=(-4.1, -4.9, 1.8),
                                                    rot_offset=( -0.3173,0.94833, 0.0, 0.0))




===== tasks/common_termination/base_termination_pick_place_cylinder.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from __future__ import annotations

import torch
from typing import TYPE_CHECKING

from isaaclab.assets import RigidObject
from isaaclab.managers import SceneEntityCfg

if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedRLEnv


def reset_object_estimate(
    env: ManagerBasedRLEnv,
    object_cfg: SceneEntityCfg = SceneEntityCfg("object"),
    min_x: float = -0.42,                # minimum x position threshold
    max_x: float = 1.0,                # maximum x position threshold
    min_y: float = 0.2,                # minimum y position threshold
    max_y: float = 0.7,                # maximum y position threshold
    min_height: float = 0.5,
) -> torch.Tensor:
   # when the object is not in the set return, reset
    # Get object entity from the scene
    # 1. get object entity from the scene
    object: RigidObject = env.scene[object_cfg.name]
    
    # Extract wheel position relative to environment origin
    # 2. get object position
    wheel_x = object.data.root_pos_w[:, 0]         # x position
    wheel_y = object.data.root_pos_w[:, 1]        # y position
    wheel_height = object.data.root_pos_w[:, 2]   # z position (height)
    done_x = (wheel_x < max_x) and  (wheel_x > min_x)
    done_y = (wheel_y < max_y) and (wheel_y > min_y)
    done_height = (wheel_height > min_height)
    done = done_x and done_y and done_height

    
    return not done


===== tasks/common_termination/base_termination_pick_place_redblock.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from __future__ import annotations

import torch
from typing import TYPE_CHECKING

from isaaclab.assets import RigidObject
from isaaclab.managers import SceneEntityCfg

if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedRLEnv


def reset_object_estimate(
    env: ManagerBasedRLEnv,
    object_cfg: SceneEntityCfg = SceneEntityCfg("object"),
    min_x: float = -5.4,                # minimum x position threshold
    max_x: float = -2.9,                # maximum x position threshold
    min_y: float = -5.05,                # minimum y position threshold
    max_y: float = -2.8,                # maximum y position threshold
    min_height: float = 0.5,
) -> torch.Tensor:
   # when the object is not in the set return, reset
    # Get object entity from the scene
    # 1. get object entity from the scene
    object: RigidObject = env.scene[object_cfg.name]
    
    # Extract wheel position relative to environment origin
    # 2. get object position
    wheel_x = object.data.root_pos_w[:, 0]         # x position
    wheel_y = object.data.root_pos_w[:, 1]        # y position
    wheel_height = object.data.root_pos_w[:, 2]   # z position (height)
    done_x = (wheel_x < max_x) and  (wheel_x > min_x)
    done_y = (wheel_y < max_y) and (wheel_y > min_y)
    done_height = (wheel_height > min_height)
    done = done_x and done_y and done_height
    return not done


===== tasks/common_termination/base_termination_pick_redblock_into_drawer.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from __future__ import annotations

import torch
from typing import TYPE_CHECKING

from isaaclab.assets import RigidObject
from isaaclab.managers import SceneEntityCfg

if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedRLEnv


def reset_object_estimate(
    env: ManagerBasedRLEnv,
    object_cfg: SceneEntityCfg = SceneEntityCfg("object"),
    min_x: float = -2.7,                # minimum x position threshold
    max_x: float = -2.2,                # maximum x position threshold
    min_y: float = -4.15,                # minimum y position threshold
    max_y: float = -3.55,                # maximum y position threshold
    min_height: float = 0.2,
) -> torch.Tensor:
    # when the object is not in the set return, reset
    # Get object entity from the scene
    # 1. get object entity from the scene
    object: RigidObject = env.scene[object_cfg.name]
    
    # Extract wheel position relative to environment origin
    # 2. get object position
    wheel_x = object.data.root_pos_w[:, 0]         # x position
    wheel_y = object.data.root_pos_w[:, 1]        # y position
    wheel_height = object.data.root_pos_w[:, 2]   # z position (height)
    done_x = (wheel_x < max_x) and  (wheel_x > min_x)
    done_y = (wheel_y < max_y) and (wheel_y > min_y)
    done_height = (wheel_height > min_height)
    done = done_x and done_y and done_height
    # print(f"done_x: {done_x}, done_y: {done_y}, done_height: {done_height}, done: {done}")
    # print(f"wheel_x: {wheel_x}, wheel_y: {wheel_y}, wheel_height: {wheel_height}")
    return  not done


===== tasks/common_termination/base_termination_stack_rgyblock.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from __future__ import annotations

import torch
from typing import TYPE_CHECKING

from isaaclab.assets import RigidObject
from isaaclab.managers import SceneEntityCfg

if TYPE_CHECKING:
    from isaaclab.envs import ManagerBasedRLEnv


def reset_object_estimate(
    env: ManagerBasedRLEnv,
    red_block_cfg: SceneEntityCfg = SceneEntityCfg("red_block"),
    yellow_block_cfg: SceneEntityCfg = SceneEntityCfg("yellow_block"),
    green_block_cfg: SceneEntityCfg = SceneEntityCfg("green_block"),
    min_x: float = -5.4,                # minimum x position threshold
    max_x: float = -2.9,                # maximum x position threshold
    min_y: float = -5.05,                # minimum y position threshold
    max_y: float = -2.8,                # maximum y position threshold
    min_height: float = 0.5,
) -> torch.Tensor:
   # when the object is not in the set return, reset
    # Get object entity from the scene
    # 1. get object entity from the scene
    red_block: RigidObject = env.scene[red_block_cfg.name]
    yellow_block: RigidObject = env.scene[yellow_block_cfg.name]
    green_block: RigidObject = env.scene[green_block_cfg.name]
    
    # Extract wheel position relative to environment origin
    # 2. get object position
    red_block_x = red_block.data.root_pos_w[:, 0]         # x position
    red_block_y = red_block.data.root_pos_w[:, 1]        # y position
    red_block_height = red_block.data.root_pos_w[:, 2]   # z position (height)

    yellow_block_x = yellow_block.data.root_pos_w[:, 0]         # x position
    yellow_block_y = yellow_block.data.root_pos_w[:, 1]        # y position
    yellow_block_height = yellow_block.data.root_pos_w[:, 2]   # z position (height)

    green_block_x = green_block.data.root_pos_w[:, 0]         # x position
    green_block_y = green_block.data.root_pos_w[:, 1]        # y position
    green_block_height = green_block.data.root_pos_w[:, 2]   # z position (height)
    
    red_done_x = (red_block_x < max_x) and  (red_block_x > min_x)
    red_done_y = (red_block_y < max_y) and (red_block_y > min_y)
    red_done_height = (red_block_height > min_height)
    red_done = red_done_x and red_done_y and red_done_height

    yellow_done_x = (yellow_block_x < max_x) and  (yellow_block_x > min_x)
    yellow_done_y = (yellow_block_y < max_y) and (yellow_block_y > min_y)
    yellow_done_height = (yellow_block_height > min_height)
    yellow_done = yellow_done_x and yellow_done_y and yellow_done_height

    green_done_x = (green_block_x < max_x) and  (green_block_x > min_x)
    green_done_y = (green_block_y < max_y) and (green_block_y > min_y)
    green_done_height = (green_block_height > min_height)
    green_done = green_done_x and green_done_y and green_done_height

    done = not (red_done and yellow_done and green_done)

    return done


===== tasks/config/extension.toml =====

[package]

# Note: Semantic Versioning is used: https://semver.org/
version = "0.10.31"

# Description
title = "Isaac Lab Environments"
description="Extension containing suite of environments for robot learning."
readme  = "docs/README.md"
repository = "https://github.com/isaac-sim/IsaacLab"
category = "robotics"
keywords = ["robotics", "rl", "il", "learning"]

[dependencies]
"isaaclab" = {}
"isaaclab_assets" = {}

[core]
reloadable = false

[[python.module]]
name = "isaaclab_tasks"


===== tasks/g1_tasks/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""Unitree G1 robot task module
contains various task implementations for the G1 robot, such as pick and place, motion control, etc.
"""

# use relative import
from . import pick_place_cylinder_g1_29dof_dex3
from . import pick_place_cylinder_g1_29dof_dex1
from . import pick_place_cylinder_g1_29dof_inspire

from . import pick_place_redblock_g1_29dof_dex1
from . import pick_place_redblock_g1_29dof_dex3
from . import stack_rgyblock_g1_29dof_dex1
from . import stack_rgyblock_g1_29dof_dex3
from . import stack_rgyblock_g1_29dof_inspire
from . import pick_redblock_into_drawer_g1_29dof_dex1
from . import pick_redblock_into_drawer_g1_29dof_dex3
from . import pick_place_redblock_g1_29dof_inspire
from . import move_cylinder_g1_29dof_dex1_wholebody
from . import move_cylinder_g1_29dof_dex3_wholebody
from . import move_cylinder_g1_29dof_inspire_wholebody

# export all modules
__all__ = [
        "pick_place_cylinder_g1_29dof_dex3", "pick_place_cylinder_g1_29dof_dex1", 
        "pick_place_redblock_g1_29dof_dex1", "pick_place_redblock_g1_29dof_dex3", 
        "stack_rgyblock_g1_29dof_dex1", "stack_rgyblock_g1_29dof_dex3", 
        "stack_rgyblock_g1_29dof_inspire",
        "pick_redblock_into_drawer_g1_29dof_dex1","pick_redblock_into_drawer_g1_29dof_dex3",
        "pick_place_redblock_g1_29dof_inspire",
        "pick_place_cylinder_g1_29dof_inspire",
        "move_cylinder_g1_29dof_dex1_wholebody",
        "move_cylinder_g1_29dof_dex3_wholebody",
        "move_cylinder_g1_29dof_inspire_wholebody"
]

===== tasks/g1_tasks/move_cylinder_g1_29dof_dex1_wholebody/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import gymnasium as gym

from . import move_cylinder_g1_29dof_dex1_hw_env_cfg


gym.register(
    id="Isaac-Move-Cylinder-G129-Dex1-Wholebody",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": move_cylinder_g1_29dof_dex1_hw_env_cfg.MoveCylinderG129Dex1WholebodyEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/g1_tasks/move_cylinder_g1_29dof_dex1_wholebody/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  



===== tasks/g1_tasks/move_cylinder_g1_29dof_dex1_wholebody/mdp/observations.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.gripper_state import get_robot_gipper_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_gipper_joint_states", 
    "get_camera_image"
]



===== tasks/g1_tasks/move_cylinder_g1_29dof_dex1_wholebody/mdp/rewards.py =====

from tasks.common_rewards.base_reward_pickplace_cylindercfg import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/g1_tasks/move_cylinder_g1_29dof_dex1_wholebody/mdp/terminations.py =====

from tasks.common_termination.base_termination_pick_place_cylinder import reset_object_estimate
__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/move_cylinder_g1_29dof_dex1_wholebody/move_cylinder_g1_29dof_dex1_hw_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING

from pink.tasks import FrameTask

import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from isaaclab.sensors import ContactSensorCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager

# import public scene configuration
from tasks.common_scene.base_scene_pickplace_cylindercfg_wholebody import TableCylinderSceneCfgWH

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableCylinderSceneCfgWH):
    """object table scene configuration class
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_dex1_wholebody(init_pos=(-3.9, -2.81811, 0.8),
        init_rot=(1, 0, 0, 0))

    contact_forces = ContactSensorCfg(prim_path="/World/envs/env_.*/Robot/.*", history_length=10, track_air_time=True, debug_vis=False)
    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_gripper_wrist_camera()
    right_wrist_camera = CameraPresets.right_gripper_wrist_camera()
    robot_camera = CameraPresets.g1_world_camera()
##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """
    defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """

        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        robot_gipper_state = ObsTerm(func=mdp.get_robot_gipper_joint_states)
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    pass
    # check if the object is out of the working range
    # success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    pass
    # reset_object = EventTermCfg(
    #     func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
    #     mode="reset",   # set event mode to reset
    #     params={
    #         # position range parameter
    #         "pose_range": {
    #             "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
    #             "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
    #         },
    #         # speed range parameter (empty dictionary means using default value)
    #         "velocity_range": {},
    #         # specify the object to reset
    #         "asset_cfg": SceneEntityCfg("object"),
    #     },
    # )


@configclass
class MoveCylinderG129Dex1WholebodyEnvCfg(ManagerBasedRLEnvCfg):
    """
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
        
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        # general settings
        self.decimation = 4
        self.episode_length_s = 20.0
        # simulation settings
        self.sim.dt = 0.005
        self.scene.contact_forces.update_period = self.sim.dt
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 16 * 1024
        self.sim.physx.friction_correlation_distance = 0.00625

                # ç‰©ç†ææ–™å±æ€§è®¾ç½® / Physics material properties
        self.sim.physics_material.static_friction = 1.0  # é™æ‘©æ“¦ç³»æ•° / Static friction
        self.sim.physics_material.dynamic_friction = 1.0  # åŠ¨æ‘©æ“¦ç³»æ•° / Dynamic friction
        self.sim.physics_material.friction_combine_mode = "max"  # æ‘©æ“¦åŠ›åˆå¹¶æ¨¡å¼ / Friction combine mode
        self.sim.physics_material.restitution_combine_mode = "max"  # æ¢å¤ç³»æ•°åˆå¹¶æ¨¡å¼ / Restitution combine mode
        # create event manager
        self.event_manager = SimpleEventManager()

        # register "reset object" event
        self.event_manager.register("reset_object_self", SimpleEvent(
            func=lambda env: base_mdp.reset_root_state_uniform(
                env,
                torch.arange(env.num_envs, device=env.device),
                pose_range={"x": [-0.05, 0.05], "y": [0.0, 0.05]},
                velocity_range={},
                asset_cfg=SceneEntityCfg("object"),
            )
        ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))


===== tasks/g1_tasks/move_cylinder_g1_29dof_dex3_wholebody/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import gymnasium as gym

from . import move_cylinder_g1_29dof_dex3_hw_env_cfg


gym.register(
    id="Isaac-Move-Cylinder-G129-Dex3-Wholebody",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": move_cylinder_g1_29dof_dex3_hw_env_cfg.MoveCylinderG129Dex3WholebodyEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/g1_tasks/move_cylinder_g1_29dof_dex3_wholebody/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  



===== tasks/g1_tasks/move_cylinder_g1_29dof_dex3_wholebody/mdp/observations.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.dex3_state import get_robot_dex3_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_dex3_joint_states", 
    "get_camera_image"
]



===== tasks/g1_tasks/move_cylinder_g1_29dof_dex3_wholebody/mdp/rewards.py =====

from tasks.common_rewards.base_reward_pickplace_cylindercfg import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/g1_tasks/move_cylinder_g1_29dof_dex3_wholebody/mdp/terminations.py =====

from tasks.common_termination.base_termination_pick_place_cylinder import reset_object_estimate
__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/move_cylinder_g1_29dof_dex3_wholebody/move_cylinder_g1_29dof_dex3_hw_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING

from pink.tasks import FrameTask

import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from isaaclab.sensors import ContactSensorCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager

# import public scene configuration
from tasks.common_scene.base_scene_pickplace_cylindercfg_wholebody import TableCylinderSceneCfgWH

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableCylinderSceneCfgWH):
    """object table scene configuration class
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_dex3_wholebody(init_pos=(-3.9, -2.81811, 0.8),
        init_rot=(1, 0, 0, 0))

    contact_forces = ContactSensorCfg(prim_path="/World/envs/env_.*/Robot/.*", history_length=10, track_air_time=True, debug_vis=False)
    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_dex3_wrist_camera()
    right_wrist_camera = CameraPresets.right_dex3_wrist_camera()
    robot_camera = CameraPresets.g1_world_camera()
##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """
    defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """

        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        robot_gipper_state = ObsTerm(func=mdp.get_robot_dex3_joint_states)
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    pass
    # check if the object is out of the working range
    # success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    pass
    # reset_object = EventTermCfg(
    #     func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
    #     mode="reset",   # set event mode to reset
    #     params={
    #         # position range parameter
    #         "pose_range": {
    #             "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
    #             "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
    #         },
    #         # speed range parameter (empty dictionary means using default value)
    #         "velocity_range": {},
    #         # specify the object to reset
    #         "asset_cfg": SceneEntityCfg("object"),
    #     },
    # )


@configclass
class MoveCylinderG129Dex3WholebodyEnvCfg(ManagerBasedRLEnvCfg):
    """
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
        
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        # general settings
        self.decimation = 4
        self.episode_length_s = 20.0
        # simulation settings
        self.sim.dt = 0.005
        self.scene.contact_forces.update_period = self.sim.dt
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 16 * 1024
        self.sim.physx.friction_correlation_distance = 0.00625

                # ç‰©ç†ææ–™å±æ€§è®¾ç½® / Physics material properties
        self.sim.physics_material.static_friction = 1.0  # é™æ‘©æ“¦ç³»æ•° / Static friction
        self.sim.physics_material.dynamic_friction = 1.0  # åŠ¨æ‘©æ“¦ç³»æ•° / Dynamic friction
        self.sim.physics_material.friction_combine_mode = "max"  # æ‘©æ“¦åŠ›åˆå¹¶æ¨¡å¼ / Friction combine mode
        self.sim.physics_material.restitution_combine_mode = "max"  # æ¢å¤ç³»æ•°åˆå¹¶æ¨¡å¼ / Restitution combine mode
        # create event manager
        self.event_manager = SimpleEventManager()

        # register "reset object" event
        self.event_manager.register("reset_object_self", SimpleEvent(
            func=lambda env: base_mdp.reset_root_state_uniform(
                env,
                torch.arange(env.num_envs, device=env.device),
                pose_range={"x": [-0.05, 0.05], "y": [0.0, 0.05]},
                velocity_range={},
                asset_cfg=SceneEntityCfg("object"),
            )
        ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))


===== tasks/g1_tasks/move_cylinder_g1_29dof_inspire_wholebody/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import gymnasium as gym

from . import move_cylinder_g1_29dof_inspire_hw_env_cfg


gym.register(
    id="Isaac-Move-Cylinder-G129-Inspire-Wholebody",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": move_cylinder_g1_29dof_inspire_hw_env_cfg.MoveCylinderG129InspireWholebodyEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/g1_tasks/move_cylinder_g1_29dof_inspire_wholebody/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  


===== tasks/g1_tasks/move_cylinder_g1_29dof_inspire_wholebody/mdp/observations.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.inspire_state import get_robot_inspire_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_inspire_joint_states", 
    "get_camera_image"
]



===== tasks/g1_tasks/move_cylinder_g1_29dof_inspire_wholebody/mdp/rewards.py =====

from tasks.common_rewards.base_reward_pickplace_cylindercfg import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/g1_tasks/move_cylinder_g1_29dof_inspire_wholebody/mdp/terminations.py =====

from tasks.common_termination.base_termination_pick_place_cylinder import reset_object_estimate
__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/move_cylinder_g1_29dof_inspire_wholebody/move_cylinder_g1_29dof_inspire_hw_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING

from pink.tasks import FrameTask

import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from isaaclab.sensors import ContactSensorCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager

# import public scene configuration
from tasks.common_scene.base_scene_pickplace_cylindercfg_wholebody import TableCylinderSceneCfgWH

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableCylinderSceneCfgWH):
    """object table scene configuration class
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_inspire_wholebody(init_pos=(-3.9, -2.81811, 0.8),
        init_rot=(1, 0, 0, 0))

    contact_forces = ContactSensorCfg(prim_path="/World/envs/env_.*/Robot/.*", history_length=10, track_air_time=True, debug_vis=False)
    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_inspire_wrist_camera()
    right_wrist_camera = CameraPresets.right_inspire_wrist_camera()
    robot_camera = CameraPresets.g1_world_camera()
##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """
    defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """

        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        robot_inspire_state = ObsTerm(func=mdp.get_robot_inspire_joint_states)
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    pass
    # check if the object is out of the working range
    # success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    pass
    # reset_object = EventTermCfg(
    #     func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
    #     mode="reset",   # set event mode to reset
    #     params={
    #         # position range parameter
    #         "pose_range": {
    #             "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
    #             "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
    #         },
    #         # speed range parameter (empty dictionary means using default value)
    #         "velocity_range": {},
    #         # specify the object to reset
    #         "asset_cfg": SceneEntityCfg("object"),
    #     },
    # )


@configclass
class MoveCylinderG129InspireWholebodyEnvCfg(ManagerBasedRLEnvCfg):
    """
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
        
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        # general settings
        self.decimation = 4
        self.episode_length_s = 20.0
        # simulation settings
        self.sim.dt = 0.005
        self.scene.contact_forces.update_period = self.sim.dt
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 16 * 1024
        self.sim.physx.friction_correlation_distance = 0.00625

                # ç‰©ç†ææ–™å±æ€§è®¾ç½® / Physics material properties
        self.sim.physics_material.static_friction = 1.0  # é™æ‘©æ“¦ç³»æ•° / Static friction
        self.sim.physics_material.dynamic_friction = 1.0  # åŠ¨æ‘©æ“¦ç³»æ•° / Dynamic friction
        self.sim.physics_material.friction_combine_mode = "max"  # æ‘©æ“¦åŠ›åˆå¹¶æ¨¡å¼ / Friction combine mode
        self.sim.physics_material.restitution_combine_mode = "max"  # æ¢å¤ç³»æ•°åˆå¹¶æ¨¡å¼ / Restitution combine mode
        # create event manager
        self.event_manager = SimpleEventManager()

        # register "reset object" event
        self.event_manager.register("reset_object_self", SimpleEvent(
            func=lambda env: base_mdp.reset_root_state_uniform(
                env,
                torch.arange(env.num_envs, device=env.device),
                pose_range={"x": [-0.05, 0.05], "y": [0.0, 0.05]},
                velocity_range={},
                asset_cfg=SceneEntityCfg("object"),
            )
        ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))


===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex1/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import gymnasium as gym

from . import pickplace_cylinder_g1_29dof_dex1_joint_env_cfg


gym.register(
    id="Isaac-PickPlace-Cylinder-G129-Dex1-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": pickplace_cylinder_g1_29dof_dex1_joint_env_cfg.PickPlaceG129DEX1BaseFixEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex1/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  



===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex1/mdp/observations.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.gripper_state import get_robot_gipper_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_gipper_joint_states", 
    "get_camera_image"
]



===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex1/mdp/rewards.py =====

from tasks.common_rewards.base_reward_pickplace_cylindercfg import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex1/mdp/terminations.py =====

from tasks.common_termination.base_termination_pick_place_cylinder import reset_object_estimate
__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex1/pickplace_cylinder_g1_29dof_dex1_joint_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING

from pink.tasks import FrameTask

import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager

# import public scene configuration
from tasks.common_scene.base_scene_pickplace_cylindercfg import TableCylinderSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableCylinderSceneCfg):
    """object table scene configuration class
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_dex1_base_fix()


    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_gripper_wrist_camera()
    right_wrist_camera = CameraPresets.right_gripper_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """
    defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """

        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        robot_gipper_state = ObsTerm(func=mdp.get_robot_gipper_joint_states)

        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    reset_object = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify the object to reset
            "asset_cfg": SceneEntityCfg("object"),
        },
    )


@configclass
class PickPlaceG129DEX1BaseFixEnvCfg(ManagerBasedRLEnvCfg):
    """
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
        
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        # general settings
        self.decimation = 2
        self.episode_length_s = 20.0
        # simulation settings
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 16 * 1024
        self.sim.physx.friction_correlation_distance = 0.00625
        # create event manager
        self.event_manager = SimpleEventManager()

        # register "reset object" event
        self.event_manager.register("reset_object_self", SimpleEvent(
            func=lambda env: base_mdp.reset_root_state_uniform(
                env,
                torch.arange(env.num_envs, device=env.device),
                pose_range={"x": [-0.05, 0.05], "y": [0.0, 0.05]},
                velocity_range={},
                asset_cfg=SceneEntityCfg("object"),
            )
        ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))


===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex3/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import gymnasium as gym
import os

from . import pickplace_cylinder_g1_29dof_dex3_joint_env_cfg, pickplace_cylinder_g1_29dof_dex3_joint_mimic_env_cfg, pickplace_cylinder_g1_29dof_dex3_joint_mimic_env


gym.register(
    id="Isaac-PickPlace-Cylinder-G129-Dex3-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": pickplace_cylinder_g1_29dof_dex3_joint_env_cfg.PickPlaceG129DEX3JointEnvCfg,
    },
    disable_env_checker=True,
)

gym.register(
    id="Isaac-PickPlace-Cylinder-G129-Dex3-Joint-Mimic",
    entry_point="tasks.g1_tasks.pick_place_cylinder_g1_29dof_dex3.pickplace_cylinder_g1_29dof_dex3_joint_mimic_env:PickPlaceG129DEX3JointMimicEnv",
    kwargs={"env_cfg_entry_point": pickplace_cylinder_g1_29dof_dex3_joint_mimic_env_cfg.PickPlaceG129DEX3JointMimicEnvCfg},
    disable_env_checker=True,
)

===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex3/mdp/__init__.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  


===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex3/mdp/observations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.dex3_state    import get_robot_dex3_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_dex3_joint_states", 
    "get_camera_image"
]


===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex3/mdp/rewards.py =====

from tasks.common_rewards.base_reward_pickplace_cylindercfg import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex3/mdp/terminations.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_termination.base_termination_pick_place_cylinder import reset_object_estimate
__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex3/pickplace_cylinder_g1_29dof_dex3_joint_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import tempfile
import torch
from dataclasses import MISSING



import isaaclab.envs.mdp as base_mdp
from isaaclab.assets import ArticulationCfg
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass

from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager

# import public scene configuration
from tasks.common_scene.base_scene_pickplace_cylindercfg import TableCylinderSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableCylinderSceneCfg):
    """object table scene configuration class
    
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_dex3_base_fix()
    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_dex3_wrist_camera()
    right_wrist_camera = CameraPresets.right_dex3_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """

        # 1. robot joint state observation
        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        # 2. gripper joint state observation 
        robot_gipper_state = ObsTerm(func=mdp.get_robot_dex3_joint_states)

        # 3. camera image observation
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection
    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()

@configclass
class TerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    reset_object = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify
            "asset_cfg": SceneEntityCfg("object"),
        },
    )


@configclass
class PickPlaceG129DEX3JointEnvCfg(ManagerBasedRLEnvCfg):
    """uNITREE G1 robot pick place environment configuration class
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
    # 3. MDP settings
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        # general settings
        self.decimation = 2
        self.episode_length_s = 20.0
        # simulation settings
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 16 * 1024
        self.sim.physx.friction_correlation_distance = 0.00625




        # create event manager
        self.event_manager = SimpleEventManager()

        # register "reset object" event
        self.event_manager.register("reset_object_self", SimpleEvent(
            func=lambda env: base_mdp.reset_root_state_uniform(
                env,
                torch.arange(env.num_envs, device=env.device),
                pose_range={"x": [-0.05, 0.05], "y": [0.0, 0.05]},
                velocity_range={},
                asset_cfg=SceneEntityCfg("object"),
            )
        ))
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))

===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex3/pickplace_cylinder_g1_29dof_dex3_joint_mimic_env.py =====

# Copyright (c) 2025
# License: Apache-2.0

from __future__ import annotations

from collections.abc import Sequence
import torch
import numpy as np

import isaaclab.utils.math as PoseUtils
from isaaclab.envs import ManagerBasedRLMimicEnv
from isaacsim.robot_motion.motion_generation import ArticulationKinematicsSolver, LulaKinematicsSolver
from isaacsim.core.prims import SingleArticulation

# This is a bit tougher than the example because they include eef pose in their observation, but our actions are just absolute joint angles
# https://github.com/isaac-sim/IsaacLab/blob/3aafdf075d630907065d654450c51914e0ffe0a0/source/isaaclab_mimic/isaaclab_mimic/envs/pinocchio_envs/pickplace_gr1t2_mimic_env.py

# note: we only support one env for this for now. This may make isaac mimic challenging.

LEFT_HAND_DEX3_ORDER = [
    "left_hand_thumb_0_joint","left_hand_thumb_1_joint","left_hand_thumb_2_joint",
    "left_hand_middle_0_joint","left_hand_middle_1_joint",
    "left_hand_index_0_joint","left_hand_index_1_joint",
]
RIGHT_HAND_DEX3_ORDER = [
    "right_hand_thumb_0_joint","right_hand_thumb_1_joint","right_hand_thumb_2_joint",
    "right_hand_middle_0_joint","right_hand_middle_1_joint",
    "right_hand_index_0_joint","right_hand_index_1_joint",
]
JOINT_TO_IDX = {'left_hip_pitch_joint': 0, 'right_hip_pitch_joint': 1, 'waist_yaw_joint': 2, 'left_hip_roll_joint': 3, 'right_hip_roll_joint': 4, 'waist_roll_joint': 5, 'left_hip_yaw_joint': 6, 'right_hip_yaw_joint': 7, 'waist_pitch_joint': 8, 'left_knee_joint': 9, 'right_knee_joint': 10, 'left_shoulder_pitch_joint': 11, 'right_shoulder_pitch_joint': 12, 'left_ankle_pitch_joint': 13, 'right_ankle_pitch_joint': 14, 'left_shoulder_roll_joint': 15, 'right_shoulder_roll_joint': 16, 'left_ankle_roll_joint': 17, 'right_ankle_roll_joint': 18, 'left_shoulder_yaw_joint': 19, 'right_shoulder_yaw_joint': 20, 'left_elbow_joint': 21, 'right_elbow_joint': 22, 'left_wrist_roll_joint': 23, 'right_wrist_roll_joint': 24, 'left_wrist_pitch_joint': 25, 'right_wrist_pitch_joint': 26, 'left_wrist_yaw_joint': 27, 'right_wrist_yaw_joint': 28, 'left_hand_index_0_joint': 29, 'left_hand_middle_0_joint': 30, 'left_hand_thumb_0_joint': 31, 'right_hand_index_0_joint': 32, 'right_hand_middle_0_joint': 33, 'right_hand_thumb_0_joint': 34, 'left_hand_index_1_joint': 35, 'left_hand_middle_1_joint': 36, 'left_hand_thumb_1_joint': 37, 'right_hand_index_1_joint': 38, 'right_hand_middle_1_joint': 39, 'right_hand_thumb_1_joint': 40, 'left_hand_thumb_2_joint': 41, 'right_hand_thumb_2_joint': 42}

class PickPlaceG129DEX3JointMimicEnv(ManagerBasedRLMimicEnv):
    """
    Mimic wrapper for the G1 29-DoF (Dex3) joint-control pick-place cylinder task.

    Notes:
    - The underlying controller takes *joint positions* for all joints.
    - We therefore do *not* compute IK inside this wrapper.
    - get_robot_eef_pose() reads EEF link pose directly from the sim.
    - target_eef_pose_to_action() preserves current joint positions and only applies gripper commands.
    - action_to_target_eef_pose() is not supported for joint-space actions (explicit error).
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        
        self.lula_solver = LulaKinematicsSolver(
            robot_description_path="/home/code/unitree_sim_isaaclab/lula_config.yaml",
            urdf_path="/home/code/unitree_sim_isaaclab/g1_29dof_with_hand_rev_1_0.urdf"
        )

        # print("DEBUGGING MIMIC")
        # print(f"robot type: {type(self.scene['robot'])}")
        found_prims = str([x for x in self.scene['robot'].stage.Traverse()])
        with open("/workspace/found_prims.txt", "w") as f:
            f.write(found_prims)
        
        self.robot = None

    def lazy_load_solvers(self):

        if self.robot is not None:
            return

        self.robot = SingleArticulation("/World/envs/env_0/Robot", name="roboto")
        self.robot.initialize()
        assert self.robot.is_valid()

        self.left_eef_solver = ArticulationKinematicsSolver(self.robot, self.lula_solver, "left_hand_palm_link")
        self.right_eef_solver = ArticulationKinematicsSolver(self.robot, self.lula_solver, "right_hand_palm_link")

        right_solver_joint_names = getattr(self.right_eef_solver._joints_view, "joint_names", None)
        left_solver_joint_names = getattr(self.left_eef_solver._joints_view, "joint_names", None)
        assert right_solver_joint_names == left_solver_joint_names
        self.solver_to_action_mapping = [JOINT_TO_IDX[name] for name in right_solver_joint_names] # indices into the 43 dim action vector for each joint computed by the kinematic solver
        self.left_mask = [right_solver_joint_names.index(name) for name in right_solver_joint_names if "left" in name]
        self.right_mask = [right_solver_joint_names.index(name) for name in right_solver_joint_names if "right" in name]
        self.left_hand_indices = [JOINT_TO_IDX[name] for name in LEFT_HAND_DEX3_ORDER]
        self.right_hand_indices = [JOINT_TO_IDX[name] for name in RIGHT_HAND_DEX3_ORDER]

    def get_robot_eef_pose(self, eef_name: str, env_ids: Sequence[int] | None = None) -> torch.Tensor:
        """
        Get current robot end effector pose. Should be the same frame as used by the robot end-effector controller.

        Args:
            eef_name: Name of the end effector.
            env_ids: Environment indices to get the pose for. If None, all envs are considered.

        Returns:
            A torch.Tensor eef pose matrix. Shape is (len(env_ids), 4, 4)
        """

        try:

            self.lazy_load_solvers()

            if eef_name == "left":
                eef_pos, rot_mat = self.left_eef_solver.compute_end_effector_pose()
            else:
                eef_pos, rot_mat = self.right_eef_solver.compute_end_effector_pose()

            eef_pos_torch = torch.from_numpy(eef_pos)
            rot_mat_torch = torch.from_numpy(rot_mat)

            return torch.unsqueeze(PoseUtils.make_pose(eef_pos_torch, rot_mat_torch), 0) # unsqueeze to get the env dimension

        except Exception as e:
            self.robot = None
            return self.get_robot_eef_pose(eef_name, env_ids)

    def target_eef_pose_to_action(
        self,
        target_eef_pose_dict: dict,
        gripper_action_dict: dict,
        action_noise_dict: dict | None = None,
        env_id: int = 0,  # Unused, but required to conform to interface
    ) -> torch.Tensor:
        """
        Takes a target pose and gripper action for the end effector controller and returns an action
        (usually a normalized delta pose action) to try and achieve that target pose.
        Noise is added to the target pose action if specified.

        Args:
            target_eef_pose_dict: Dictionary of 4x4 target eef pose for each end-effector.
            gripper_action_dict: Dictionary of gripper actions for each end-effector.
            action_noise_dict: Noise to add to the action. If None, no noise is added.
            env_id: Environment index to get the action for.

        Returns:
            An action torch.Tensor that's compatible with env.step().
        """

        try:

            self.lazy_load_solvers()

            # set the root pose of the lula solver, to ensure correct inverse kinematics
            robot_base_translation, robot_base_orientation = self.robot.get_world_pose()
            robot_base_translation = robot_base_translation.cpu().detach().numpy()
            robot_base_orientation = robot_base_orientation.cpu().detach().numpy()
            self.lula_solver.set_robot_base_pose(robot_base_translation, robot_base_orientation)

            # split the target pose into translation and orientation, and add action noise if specified by mimic
            target_left_eef_pos, left_target_rot = PoseUtils.unmake_pose(target_eef_pose_dict["left"])
            target_right_eef_pos, right_target_rot = PoseUtils.unmake_pose(target_eef_pose_dict["right"])
            target_left_eef_rot_quat = PoseUtils.quat_from_matrix(left_target_rot)
            target_right_eef_rot_quat = PoseUtils.quat_from_matrix(right_target_rot)

            if action_noise_dict is not None:
                pos_noise_left = action_noise_dict["left"] * torch.randn_like(target_left_eef_pos)
                pos_noise_right = action_noise_dict["right"] * torch.randn_like(target_right_eef_pos)
                quat_noise_left = action_noise_dict["left"] * torch.randn_like(target_left_eef_rot_quat)
                quat_noise_right = action_noise_dict["right"] * torch.randn_like(target_right_eef_rot_quat)

                target_left_eef_pos += pos_noise_left
                target_right_eef_pos += pos_noise_right
                target_left_eef_rot_quat += quat_noise_left
                target_right_eef_rot_quat += quat_noise_right

            # use inverse kinematics to compute the joint angles required to achieve the target pose for each end effector
            left_action, left_success = self.left_eef_solver.compute_inverse_kinematics(target_left_eef_pos, target_left_eef_rot_quat)
            right_action, right_success = self.right_eef_solver.compute_inverse_kinematics(target_right_eef_pos, target_right_eef_rot_quat)

            if not left_success or not right_success:
                raise ValueError("Failed to compute inverse kinematics for one or both end effectors")

            # the left solver returns zeros for all right arm joints and vice versa, 
            # so we add the two vectors to get the joint angles for all arm joints
            left_action_array = left_action.joint_positions
            right_action_array = right_action.joint_positions
            combined_arm_action = left_action_array + right_action_array

            # now we use the mapping between indices in the list of joint actions returned by the solver
            # and the full action vector required by the environment
            full = np.zeros(len(JOINT_TO_IDX), dtype=np.float32)
            full[self.solver_to_action_mapping] = combined_arm_action

            # the next step is to add the gripper actions
            # FOR THIS TO WORK THE GRIPPER ACTIONS MUST BE JOINT ACTUATIONS. I'M STILL NOT SURE IF THIS IS THE CASE.
            full[self.left_hand_indices] = gripper_action_dict["left"]
            full[self.right_hand_indices] = gripper_action_dict["right"]

            return torch.from_numpy(np.expand_dims(full, axis=0)) # unsqueeze to get the env dimension

        except Exception as e:
            self.robot = None
            return self.target_eef_pose_to_action(target_eef_pose_dict, gripper_action_dict, action_noise_dict, env_id)

    def action_to_target_eef_pose(self, action: torch.Tensor) -> dict[str, torch.Tensor]:
        """
        Converts action (compatible with env.step) to a target pose for the end effector controller.
        Inverse of @target_eef_pose_to_action. Usually used to infer a sequence of target controller poses
        from a demonstration trajectory using the recorded actions.

        Args:
            action: Environment action. Shape is (num_envs, action_dim).

        Returns:
            A dictionary of eef pose torch.Tensor that @action corresponds to.
        """

        try:

            self.lazy_load_solvers()

            # set the root pose of the lula solver, to ensure correct inverse kinematics
            robot_base_translation, robot_base_orientation = self.robot.get_world_pose()
            robot_base_translation = robot_base_translation.cpu().detach().numpy()
            robot_base_orientation = robot_base_orientation.cpu().detach().numpy()
            self.lula_solver.set_robot_base_pose(robot_base_translation, robot_base_orientation)

            combined_arm_action = action[0][self.solver_to_action_mapping] # index into the env dimension

            left_pos, left_rot_mat = self.lula_solver.compute_forward_kinematics("left_hand_palm_link", combined_arm_action)
            right_pos, right_rot_mat = self.lula_solver.compute_forward_kinematics("right_hand_palm_link", combined_arm_action)

            left_pos = torch.from_numpy(left_pos)
            right_pos = torch.from_numpy(right_pos)
            left_rot_mat = torch.from_numpy(left_rot_mat)
            right_rot_mat = torch.from_numpy(right_rot_mat)

            left_target_eef_pose = PoseUtils.make_pose(left_pos, left_rot_mat)
            right_target_eef_pose = PoseUtils.make_pose(right_pos, right_rot_mat)

            return {"left": left_target_eef_pose, "right": right_target_eef_pose}
        
        except Exception as e:
            self.robot = None
            return self.action_to_target_eef_pose(action)

    def actions_to_gripper_actions(self, actions: torch.Tensor) -> dict[str, torch.Tensor]:
        """
        Extracts the gripper actuation part from a sequence of env actions (compatible with env.step).

        Args:
            actions: environment actions. The shape is (num_envs, num steps in a demo, action_dim).

        Returns:
            A dictionary of torch.Tensor gripper actions. Key to each dict is an eef_name.
        """

        try:

            self.lazy_load_solvers()

            return {
                "left": actions[:,:,self.left_hand_indices],
                "right": actions[:,:,self.right_hand_indices]
            }

        except Exception as e:
            self.robot = None
            return self.actions_to_gripper_actions(actions)

===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_dex3/pickplace_cylinder_g1_29dof_dex3_joint_mimic_env_cfg.py =====

# Copyright (c) 2025
# License: Apache-2.0

from isaaclab.envs.mimic_env_cfg import MimicEnvCfg, SubTaskConfig
from isaaclab.utils import configclass
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.assets import RigidObject
from isaaclab.managers import SceneEntityCfg
from isaaclab.envs import ManagerBasedRLEnv

import torch

# Import your IsaacLab task config
from tasks.g1_tasks.pick_place_cylinder_g1_29dof_dex3.pickplace_cylinder_g1_29dof_dex3_joint_env_cfg import (
    PickPlaceG129DEX3JointEnvCfg,
)

def reset_object_estimate(
    env: ManagerBasedRLEnv,
    object_cfg: SceneEntityCfg = SceneEntityCfg("object"),
    min_x: float = -0.42,                # minimum x position threshold
    max_x: float = 1.0,                # maximum x position threshold
    min_y: float = 0.2,                # minimum y position threshold
    max_y: float = 0.7,                # maximum y position threshold
    min_height: float = 0.5,
) -> torch.Tensor:
   # when the object is not in the set return, reset
    # Get object entity from the scene
    # 1. get object entity from the scene
    object: RigidObject = env.scene[object_cfg.name]
    pos = object.data.root_pos_w

    x = pos[:, 0]
    y = pos[:, 1]
    z = pos[:, 2]

    in_x = (x > min_x) & (x < max_x)
    in_y = (y > min_y) & (y < max_y)
    in_h = z > min_height
    
    success = in_x & in_y & in_h 

    return success.to(dtype=torch.bool, device=env.device)


@configclass
class MimicTerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=reset_object_estimate)# use task completion check function


@configclass
class PickPlaceG129DEX3JointMimicEnvCfg(PickPlaceG129DEX3JointEnvCfg, MimicEnvCfg):
    """
    Mimic wrapper config for the G1 pick-place cylinder task (29DoF + Dex3, joint control).

    Inherits your task config, then augments it with Mimic data-gen settings and subtask layout.
    """

    terminations: MimicTerminationsCfg = MimicTerminationsCfg()

    def __post_init__(self):
        # Call parents first
        super().__post_init__()

        # ---- Datagen knobs (tuned for joint-space control) ----
        self.datagen_config.name = "g1_pick_place_cylinder_dex3_joint_D0"
        self.datagen_config.generation_guarantee = True
        self.datagen_config.generation_keep_failed = False
        self.datagen_config.generation_num_trials = 1000

        # Joint-space controller: do not require per-arm source selection
        self.datagen_config.generation_select_src_per_subtask = False
        self.datagen_config.generation_select_src_per_arm = False

        # We are *not* producing targets in a relative eef space
        self.datagen_config.generation_relative = False
        # Joint-space: don't attempt to synthesize joint targets from "joint_pos" values here
        self.datagen_config.generation_joint_pos = False

        # For joint-space, "interpolate_from_last_target_pose" isnâ€™t critical,
        # but leaving it True helps smooth subtask stitching when available.
        self.datagen_config.generation_transform_first_robot_pose = False
        self.datagen_config.generation_interpolate_from_last_target_pose = True

        self.datagen_config.max_num_failures = 25
        self.datagen_config.num_demo_to_render = 10
        self.datagen_config.num_fail_demo_to_render = 25
        self.datagen_config.seed = 1

        subtask_configs = []
        subtask_configs.append(
            SubTaskConfig(
                # Each subtask involves manipulation with respect to a single object frame.
                object_ref="object",
                # This key corresponds to the binary indicator in "datagen_info" that signals
                # when this subtask is finished (e.g., on a 0 to 1 edge).
                subtask_term_signal="idle_right",
                first_subtask_start_offset_range=(0, 0),
                # Randomization range for starting index of the first subtask
                subtask_term_offset_range=(0, 0),
                # Selection strategy for the source subtask segment during data generation
                # selection_strategy="nearest_neighbor_object",
                selection_strategy="nearest_neighbor_object",
                # Optional parameters for the selection strategy function
                selection_strategy_kwargs={"nn_k": 3},
                # Amount of action noise to apply during this subtask
                action_noise=0.003,
                # Number of interpolation steps to bridge to this subtask segment
                num_interpolation_steps=0,
                # Additional fixed steps for the robot to reach the necessary pose
                num_fixed_steps=0,
                # If True, apply action noise during the interpolation phase and execution
                apply_noise_during_interpolation=False,
            )
        )
        subtask_configs.append(
            SubTaskConfig(
                # Each subtask involves manipulation with respect to a single object frame.
                object_ref="object",
                # Corresponding key for the binary indicator in "datagen_info" for completion
                subtask_term_signal=None,
                # Time offsets for data generation when splitting a trajectory
                subtask_term_offset_range=(0, 0),
                # Selection strategy for source subtask segment
                selection_strategy="nearest_neighbor_object",
                # Optional parameters for the selection strategy function
                selection_strategy_kwargs={"nn_k": 3},
                # Amount of action noise to apply during this subtask
                action_noise=0.003,
                # Number of interpolation steps to bridge to this subtask segment
                num_interpolation_steps=3,
                # Additional fixed steps for the robot to reach the necessary pose
                num_fixed_steps=0,
                # If True, apply action noise during the interpolation phase and execution
                apply_noise_during_interpolation=False,
            )
        )
        self.subtask_configs["right"] = subtask_configs

        subtask_configs = []
        subtask_configs.append(
            SubTaskConfig(
                # Each subtask involves manipulation with respect to a single object frame.
                object_ref="object",
                # Corresponding key for the binary indicator in "datagen_info" for completion
                subtask_term_signal=None,
                # Time offsets for data generation when splitting a trajectory
                subtask_term_offset_range=(0, 0),
                # Selection strategy for source subtask segment
                selection_strategy="nearest_neighbor_object",
                # Optional parameters for the selection strategy function
                selection_strategy_kwargs={"nn_k": 3},
                # Amount of action noise to apply during this subtask
                action_noise=0.003,
                # Number of interpolation steps to bridge to this subtask segment
                num_interpolation_steps=0,
                # Additional fixed steps for the robot to reach the necessary pose
                num_fixed_steps=0,
                # If True, apply action noise during the interpolation phase and execution
                apply_noise_during_interpolation=False,
            )
        )
        self.subtask_configs["left"] = subtask_configs

    


===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_inspire/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import gymnasium as gym

from . import pickplace_cylinder_g1_29dof_inspire_env_cfg


gym.register(
    id="Isaac-PickPlace-Cylinder-G129-Inspire-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": pickplace_cylinder_g1_29dof_inspire_env_cfg.PickPlaceG129InspireBaseFixEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_inspire/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  


===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_inspire/mdp/observations.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.inspire_state import get_robot_inspire_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_inspire_joint_states", 
    "get_camera_image"
]



===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_inspire/mdp/rewards.py =====

from tasks.common_rewards.base_reward_pickplace_cylindercfg import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_inspire/mdp/terminations.py =====

from tasks.common_termination.base_termination_pick_place_cylinder import reset_object_estimate
__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/pick_place_cylinder_g1_29dof_inspire/pickplace_cylinder_g1_29dof_inspire_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING

from pink.tasks import FrameTask

import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager

# import public scene configuration
from tasks.common_scene.base_scene_pickplace_cylindercfg import TableCylinderSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableCylinderSceneCfg):
    """object table scene configuration class
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_inspire_base_fix()


    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_inspire_wrist_camera()
    right_wrist_camera = CameraPresets.right_inspire_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """
    defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """

        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        robot_inspire_state = ObsTerm(func=mdp.get_robot_inspire_joint_states)

        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    reset_object = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify the object to reset
            "asset_cfg": SceneEntityCfg("object"),
        },
    )


@configclass
class PickPlaceG129InspireBaseFixEnvCfg(ManagerBasedRLEnvCfg):
    """
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
        
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        # general settings
        self.decimation = 2
        self.episode_length_s = 20.0
        # simulation settings
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 16 * 1024
        self.sim.physx.friction_correlation_distance = 0.00625
        # create event manager
        self.event_manager = SimpleEventManager()

        # register "reset object" event
        self.event_manager.register("reset_object_self", SimpleEvent(
            func=lambda env: base_mdp.reset_root_state_uniform(
                env,
                torch.arange(env.num_envs, device=env.device),
                pose_range={"x": [-0.05, 0.05], "y": [0.0, 0.05]},
                velocity_range={},
                asset_cfg=SceneEntityCfg("object"),
            )
        ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))


===== tasks/g1_tasks/pick_place_redblock_g1_29dof_dex1/__init__.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import gymnasium as gym
import os

from . import pickplace_redblock_g1_29dof_dex1_joint_env_cfg


gym.register(
    id="Isaac-PickPlace-RedBlock-G129-Dex1-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": pickplace_redblock_g1_29dof_dex1_joint_env_cfg.PickPlaceG129DEX1BaseFixEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/g1_tasks/pick_place_redblock_g1_29dof_dex1/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *

===== tasks/g1_tasks/pick_place_redblock_g1_29dof_dex1/mdp/observations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.gripper_state import get_robot_gipper_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_gipper_joint_states", 
    "get_camera_image"
]



===== tasks/g1_tasks/pick_place_redblock_g1_29dof_dex1/mdp/rewards.py =====

from tasks.common_rewards.base_reward_pickplace_redblock import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/g1_tasks/pick_place_redblock_g1_29dof_dex1/mdp/terminations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from tasks.common_termination.base_termination_pick_place_redblock import reset_object_estimate


__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/pick_place_redblock_g1_29dof_dex1/pickplace_redblock_g1_29dof_dex1_joint_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING



import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager

# import public scene configuration
from tasks.common_scene.base_scene_pickplace_redblock import TableRedBlockSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableRedBlockSceneCfg):
    """object table scene configuration class
    
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_dex1_base_fix(init_pos=(-4.2, -3.7, 0.76),
        init_rot=(0.7071, 0, 0, -0.7071))


    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_gripper_wrist_camera()
    right_wrist_camera = CameraPresets.right_gripper_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """Observation specifications for the MDP."""
    """defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """
        # 1. robot joint state observation
        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        # 2. gripper joint state observation 
        robot_gipper_state = ObsTerm(func=mdp.get_robot_gipper_joint_states)

        # # 3. camera image observation
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    reset_object = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.1, 0.1],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify the object to reset
            "asset_cfg": SceneEntityCfg("object"),
        },
    )


@configclass
class PickPlaceG129DEX1BaseFixEnvCfg(ManagerBasedRLEnvCfg):
    """Unitree G1 robot pick place environment configuration class
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
    # 3. MDP settings
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        self.decimation = 2
        self.episode_length_s = 20.0
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 32 * 1024
        self.sim.physx.friction_correlation_distance = 0.003
        self.sim.physx.enable_ccd = True
        self.sim.physx.gpu_constraint_solver_heavy_spring_enabled = True
        self.sim.physx.num_substeps = 2
        self.sim.physx.contact_offset = 0.015
        self.sim.physx.rest_offset = 0.001
        self.sim.physx.num_position_iterations = 12
        self.sim.physx.num_velocity_iterations = 4

        # create event manager
        self.event_manager = SimpleEventManager() 

        # register "reset object" event
        self.event_manager.register("reset_object_self", SimpleEvent(
            func=lambda env: base_mdp.reset_root_state_uniform(
                env,
                torch.arange(env.num_envs, device=env.device),
                pose_range={"x": [-0.1, 0.1], "y": [-0.05, 0.05]},
                velocity_range={},
                asset_cfg=SceneEntityCfg("object"),
            )
        ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))


#

===== tasks/g1_tasks/pick_place_redblock_g1_29dof_dex3/__init__.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import gymnasium as gym
import os

from . import pickplace_redblock_g1_29dof_dex3_joint_env_cfg


gym.register(
    id="Isaac-PickPlace-RedBlock-G129-Dex3-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": pickplace_redblock_g1_29dof_dex3_joint_env_cfg.PickPlaceG129DEX3BaseFixEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/g1_tasks/pick_place_redblock_g1_29dof_dex3/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  


===== tasks/g1_tasks/pick_place_redblock_g1_29dof_dex3/mdp/observations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.dex3_state import get_robot_dex3_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_dex3_joint_states", 
    "get_camera_image"
]



===== tasks/g1_tasks/pick_place_redblock_g1_29dof_dex3/mdp/rewards.py =====

from tasks.common_rewards.base_reward_pickplace_redblock import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/g1_tasks/pick_place_redblock_g1_29dof_dex3/mdp/terminations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_termination.base_termination_pick_place_redblock import reset_object_estimate


__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/pick_place_redblock_g1_29dof_dex3/pickplace_redblock_g1_29dof_dex3_joint_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import tempfile
import torch
from dataclasses import MISSING

from pink.tasks import FrameTask

import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager

# import public scene configuration
from tasks.common_scene.base_scene_pickplace_redblock import TableRedBlockSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableRedBlockSceneCfg):
    """object table scene configuration class
    
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_dex3_base_fix(init_pos=(-4.2, -3.7, 0.76),
        init_rot=(0.7071, 0, 0, -0.7071))


    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_dex3_wrist_camera()
    right_wrist_camera = CameraPresets.right_dex3_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """Action specifications for the MDP."""
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """Observation specifications for the MDP."""
    """defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """Observations for policy group with state values."""
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """
        # 1. robot joint state observation
        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        # 2. gripper joint state observation 
        robot_gipper_state = ObsTerm(func=mdp.get_robot_dex3_joint_states)

        # 3. camera image observation
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    reset_object = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify the object to reset
            "asset_cfg": SceneEntityCfg("object"),
        },
    )


@configclass
class PickPlaceG129DEX3BaseFixEnvCfg(ManagerBasedRLEnvCfg):
    """Unitree G1 robot pick place environment configuration class
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
    # 3. MDP settings
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        # general settings
        self.decimation = 2
        self.episode_length_s = 20.0
        # simulation settings
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 32 * 1024
        self.sim.physx.friction_correlation_distance = 0.003
        self.sim.physx.enable_ccd = True
        self.sim.physx.gpu_constraint_solver_heavy_spring_enabled = True
        self.sim.physx.num_substeps = 4
        self.sim.physx.contact_offset = 0.01
        self.sim.physx.rest_offset = 0.001
        self.sim.physx.num_position_iterations = 16
        self.sim.physx.num_velocity_iterations = 4

        self.event_manager = SimpleEventManager()

        # register
        self.event_manager.register("reset_object_self", SimpleEvent(
            func=lambda env: base_mdp.reset_root_state_uniform(
                env,
                torch.arange(env.num_envs, device=env.device),
                pose_range={"x": [-0.05, 0.05], "y": [-0.05, 0.05]},
                velocity_range={},
                asset_cfg=SceneEntityCfg("object"),
            )
        ))
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))


===== tasks/g1_tasks/pick_place_redblock_g1_29dof_inspire/__init__.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import gymnasium as gym
import os

from . import pickplace_redblock_g1_29dof_inspire_joint_env_cfg


gym.register(
    id="Isaac-PickPlace-RedBlock-G129-Inspire-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": pickplace_redblock_g1_29dof_inspire_joint_env_cfg.PickPlaceG129InspireHandBaseFixEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/g1_tasks/pick_place_redblock_g1_29dof_inspire/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  


===== tasks/g1_tasks/pick_place_redblock_g1_29dof_inspire/mdp/observations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.inspire_state import get_robot_inspire_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_inspire_joint_states", 
    "get_camera_image"
]



===== tasks/g1_tasks/pick_place_redblock_g1_29dof_inspire/mdp/rewards.py =====

from tasks.common_rewards.base_reward_pickplace_redblock import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/g1_tasks/pick_place_redblock_g1_29dof_inspire/mdp/terminations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from tasks.common_termination.base_termination_pick_place_redblock import reset_object_estimate


__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/pick_place_redblock_g1_29dof_inspire/pickplace_redblock_g1_29dof_inspire_joint_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING



import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager

# import public scene configuration
from tasks.common_scene.base_scene_pickplace_redblock import TableRedBlockSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableRedBlockSceneCfg):
    """object table scene configuration class
    
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_inspire_base_fix(init_pos=(-4.2, -3.7, 0.76),
        init_rot=(0.7071, 0, 0, -0.7071))


    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_inspire_wrist_camera()
    right_wrist_camera = CameraPresets.right_inspire_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """Observation specifications for the MDP."""
    """defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """
        # 1. robot joint state observation
        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        # 2. gripper joint state observation 
        robot_inspire_state = ObsTerm(func=mdp.get_robot_inspire_joint_states)

        # 3. camera image observation
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    reset_object = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify the object to reset
            "asset_cfg": SceneEntityCfg("object"),
        },
    )


@configclass
class PickPlaceG129InspireHandBaseFixEnvCfg(ManagerBasedRLEnvCfg):
    """Unitree G1 robot pick place environment configuration class
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
    # 3. MDP settings
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        self.decimation = 2
        self.episode_length_s = 20.0
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 32 * 1024
        self.sim.physx.friction_correlation_distance = 0.003
        self.sim.physx.enable_ccd = True
        self.sim.physx.gpu_constraint_solver_heavy_spring_enabled = True
        self.sim.physx.num_substeps = 2
        self.sim.physx.contact_offset = 0.015
        self.sim.physx.rest_offset = 0.001
        self.sim.physx.num_position_iterations = 12
        self.sim.physx.num_velocity_iterations = 4

        # create event manager
        self.event_manager = SimpleEventManager() 

        # register "reset object" event
        self.event_manager.register("reset_object_self", SimpleEvent(
            func=lambda env: base_mdp.reset_root_state_uniform(
                env,
                torch.arange(env.num_envs, device=env.device),
                pose_range={"x": [-0.05, 0.05], "y": [-0.05, 0.05]},
                velocity_range={},
                asset_cfg=SceneEntityCfg("object"),
            )
        ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))

===== tasks/g1_tasks/pick_redblock_into_drawer_g1_29dof_dex1/__init__.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import gymnasium as gym
import os

from . import pick_redblock_into_drawer_g1_29dof_dex1_joint_env_cfg


gym.register(
    id="Isaac-Pick-Redblock-Into-Drawer-G129-Dex1-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": pick_redblock_into_drawer_g1_29dof_dex1_joint_env_cfg.PickRedblockIntoDrawerG129DEX1BaseFixEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/g1_tasks/pick_redblock_into_drawer_g1_29dof_dex1/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  


===== tasks/g1_tasks/pick_redblock_into_drawer_g1_29dof_dex1/mdp/observations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.gripper_state import get_robot_gipper_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_gipper_joint_states", 
    "get_camera_image"
]



===== tasks/g1_tasks/pick_redblock_into_drawer_g1_29dof_dex1/mdp/terminations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_termination.base_termination_pick_redblock_into_drawer import reset_object_estimate
__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/pick_redblock_into_drawer_g1_29dof_dex1/pick_redblock_into_drawer_g1_29dof_dex1_joint_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING



import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager

# import public scene configuration
from tasks.common_scene.base_scene_pick_redblock_into_drawer import TablePickRedblockIntoDrawerSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TablePickRedblockIntoDrawerSceneCfg):
    """object table scene configuration class
    
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_dex1_base_fix(init_pos=(-2.5, -3.7, 0.76),
        init_rot=(0.7071, 0, 0, -0.7071))


    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_gripper_wrist_camera()
    right_wrist_camera = CameraPresets.right_gripper_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """Observation specifications for the MDP."""
    """defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """
        # 1. robot joint state observation
        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        # 2. gripper joint state observation 
        robot_gipper_state = ObsTerm(func=mdp.get_robot_gipper_joint_states)

        # 3. camera image observation
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class EventCfg:
    # pass
    reset_object = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.3, 0.25],  # x axis position range: -0.05 to 0.0 meter
                "y": [0, 0.1],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify the object to reset
            "asset_cfg": SceneEntityCfg("object"),
        },
    )

    reset_cabinet = EventTermCfg(
        func=mdp.reset_scene_to_default,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
    )



@configclass
class PickRedblockIntoDrawerG129DEX1BaseFixEnvCfg(ManagerBasedRLEnvCfg):
    """Unitree G1 robot pick place environment configuration class
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
    # 3. MDP settings
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards = None # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        self.decimation = 2
        self.episode_length_s = 20.0
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 32 * 1024
        self.sim.physx.friction_correlation_distance = 0.003
        self.sim.physx.enable_ccd = True
        self.sim.physx.gpu_constraint_solver_heavy_spring_enabled = True
        self.sim.physx.num_substeps = 2
        self.sim.physx.contact_offset = 0.015
        self.sim.physx.rest_offset = 0.001
        self.sim.physx.num_position_iterations = 12
        self.sim.physx.num_velocity_iterations = 4

        # create event manager
        self.event_manager = SimpleEventManager() 

        # register "reset object" event
        self.event_manager.register("reset_object_self", SimpleEvent(
            func=lambda env: base_mdp.reset_root_state_uniform(
                env,
                torch.arange(env.num_envs, device=env.device),
                pose_range={"x": [-0.3, 0.25], "y": [0, 0.1]},
                velocity_range={},
                asset_cfg=SceneEntityCfg("object"),
            )
        ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))

===== tasks/g1_tasks/pick_redblock_into_drawer_g1_29dof_dex3/__init__.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import gymnasium as gym
import os

from . import pick_redblock_into_drawer_g1_29dof_dex3_joint_env_cfg


gym.register(
    id="Isaac-Pick-Redblock-Into-Drawer-G129-Dex3-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": pick_redblock_into_drawer_g1_29dof_dex3_joint_env_cfg.PickRedblockIntoDrawerG129DEX3JointEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/g1_tasks/pick_redblock_into_drawer_g1_29dof_dex3/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  


===== tasks/g1_tasks/pick_redblock_into_drawer_g1_29dof_dex3/mdp/observations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.dex3_state import get_robot_dex3_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_dex3_joint_states", 
    "get_camera_image"
]



===== tasks/g1_tasks/pick_redblock_into_drawer_g1_29dof_dex3/mdp/terminations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_termination.base_termination_pick_redblock_into_drawer import reset_object_estimate
__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/pick_redblock_into_drawer_g1_29dof_dex3/pick_redblock_into_drawer_g1_29dof_dex3_joint_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import tempfile
import torch
from dataclasses import MISSING

from pink.tasks import FrameTask

import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager

# import public scene configuration
# from tasks.common_scene.base_scene_pickplace_redblock import TableRedBlockSceneCfg
from tasks.common_scene.base_scene_pick_redblock_into_drawer import TablePickRedblockIntoDrawerSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TablePickRedblockIntoDrawerSceneCfg):
    """object table scene configuration class
    
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_dex3_base_fix(init_pos=(-2.5, -3.7, 0.8),
        init_rot=(0.7071, 0, 0, -0.7071))


    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_dex3_wrist_camera()
    right_wrist_camera = CameraPresets.right_dex3_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """Action specifications for the MDP."""
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """Observation specifications for the MDP."""
    """defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """Observations for policy group with state values."""
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """
        # 1. robot joint state observation
        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        # 2. gripper joint state observation 
        robot_gipper_state = ObsTerm(func=mdp.get_robot_dex3_joint_states)

        # 3. camera image observation
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class EventCfg:
    reset_cabinet = EventTermCfg(
        func=mdp.reset_scene_to_default,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
    )
    reset_object = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.3, 0.25], "y": [0, 0.1],  # x axis position range: -0.05 to 0.0 meter  # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify the object to reset
            "asset_cfg": SceneEntityCfg("object"),
        },
    )


@configclass
class PickRedblockIntoDrawerG129DEX3JointEnvCfg(ManagerBasedRLEnvCfg):
    """Unitree G1 robot pick place environment configuration class
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
    # 3. MDP settings
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards = None # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        # general settings
        self.decimation = 2
        self.episode_length_s = 20.0
        # simulation settings
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 32 * 1024
        self.sim.physx.friction_correlation_distance = 0.003
        self.sim.physx.enable_ccd = True
        self.sim.physx.gpu_constraint_solver_heavy_spring_enabled = True
        self.sim.physx.num_substeps = 4
        self.sim.physx.contact_offset = 0.01
        self.sim.physx.rest_offset = 0.001
        self.sim.physx.num_position_iterations = 16
        self.sim.physx.num_velocity_iterations = 4

        self.event_manager = SimpleEventManager()

        # register
        self.event_manager.register("reset_object_self", SimpleEvent(
            func=lambda env: base_mdp.reset_root_state_uniform(
                env,
                torch.arange(env.num_envs, device=env.device),
                pose_range={"x":  [-0.3, 0.25], "y": [0, 0.1]},
                velocity_range={},
                asset_cfg=SceneEntityCfg("object"),
            )
        ))
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))


===== tasks/g1_tasks/stack_rgyblock_g1_29dof_dex1/__init__.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import gymnasium as gym
import os

from . import stack_rgyblock_g1_29dof_dex1_joint_env_cfg


gym.register(
    id="Isaac-Stack-RgyBlock-G129-Dex1-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": stack_rgyblock_g1_29dof_dex1_joint_env_cfg.StackRgyBlockG129DEX1BaseFixEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/g1_tasks/stack_rgyblock_g1_29dof_dex1/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  


===== tasks/g1_tasks/stack_rgyblock_g1_29dof_dex1/mdp/observations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.gripper_state import get_robot_gipper_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_gipper_joint_states", 
    "get_camera_image"
]



===== tasks/g1_tasks/stack_rgyblock_g1_29dof_dex1/mdp/rewards.py =====

from tasks.common_rewards.base_reward_stack_rgyblock import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/g1_tasks/stack_rgyblock_g1_29dof_dex1/mdp/terminations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from tasks.common_termination.base_termination_stack_rgyblock import reset_object_estimate


__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/stack_rgyblock_g1_29dof_dex1/stack_rgyblock_g1_29dof_dex1_joint_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING



import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager, BatchObjectEvent, MultiObjectEvent

# import public scene configuration
from tasks.common_scene.base_scene_stack_rgyblock import TableRedGreenYellowBlockSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableRedGreenYellowBlockSceneCfg):
    """object table scene configuration class
    
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_dex1_base_fix(init_pos=(-4.2, -3.7, 0.76),
        init_rot=(0.7071, 0, 0, -0.7071))


    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_gripper_wrist_camera()
    right_wrist_camera = CameraPresets.right_gripper_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """Observation specifications for the MDP."""
    """defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """
        # 1. robot joint state observation
        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        # 2. gripper joint state observation 
        robot_gipper_state = ObsTerm(func=mdp.get_robot_gipper_joint_states)

        # 3. camera image observation
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    reset_red_block = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.15, 0.15],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify the object to reset
            "asset_cfg": SceneEntityCfg("red_block"),
        },
    )
    reset_yellow_block = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            "pose_range": {
                "x": [-0.15, 0.15],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            "asset_cfg": SceneEntityCfg("yellow_block"),
        },
    )   
    reset_green_block = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            "pose_range": {
                "x": [-0.15, 0.15],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            "asset_cfg": SceneEntityCfg("green_block"),
        },
    )   

@configclass
class StackRgyBlockG129DEX1BaseFixEnvCfg(ManagerBasedRLEnvCfg):
    """Unitree G1 robot stack red, yellow, green block environment configuration class
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
    # 3. MDP settings
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        # general settings
        self.decimation = 2
        self.episode_length_s = 20.0
        # simulation settings
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 32 * 1024
        self.sim.physx.friction_correlation_distance = 0.003
        self.sim.physx.enable_ccd = True
        self.sim.physx.gpu_constraint_solver_heavy_spring_enabled = True
        self.sim.physx.num_substeps = 2
        self.sim.physx.contact_offset = 0.015
        self.sim.physx.rest_offset = 0.001
        self.sim.physx.num_position_iterations = 12
        self.sim.physx.num_velocity_iterations = 4
        # create event manager
        self.event_manager = SimpleEventManager() 

        self.event_manager.register_multi_object_reset(
            name="reset_object_self",
            object_names=["red_block", "yellow_block", "green_block"],
            pose_ranges={"x": [-0.05, 0.05], "y": [-0.05, 0.05]},  # æ‰€æœ‰ç‰©ä½“ä½¿ç”¨ç›¸åŒèŒƒå›´
            velocity_ranges={}
        )
        
        # æ–¹æ³•2ï¼šå¦‚æœéœ€è¦ä¸ºä¸åŒç‰©ä½“è®¾ç½®ä¸åŒçš„é‡ç½®èŒƒå›´ï¼Œå¯ä»¥ä½¿ç”¨è¿™ç§æ–¹å¼
        # self.event_manager.register("reset_object_self", BatchObjectEvent(
        #     object_names=["red_block", "yellow_block", "green_block"],
        #     pose_ranges={
        #         "red_block": {"x": [-0.05, 0.05], "y": [-0.05, 0.05]},
        #         "yellow_block": {"x": [-0.03, 0.03], "y": [-0.03, 0.03]},
        #         "green_block": {"x": [-0.08, 0.08], "y": [-0.08, 0.08]}
        #     },
        #     velocity_ranges={}
        # ))
        
        # æ–¹æ³•3ï¼šä½¿ç”¨MultiObjectEventçš„è¯¦ç»†é…ç½®æ–¹å¼
        # self.event_manager.register("reset_object_self", MultiObjectEvent(
        #     reset_configs=[
        #         {
        #             "asset_cfg": SceneEntityCfg("red_block"),
        #             "pose_range": {"x": [-0.05, 0.05], "y": [-0.05, 0.05]},
        #             "velocity_range": {}
        #         },
        #         {
        #             "asset_cfg": SceneEntityCfg("yellow_block"),
        #             "pose_range": {"x": [-0.03, 0.03], "y": [-0.03, 0.03]},
        #             "velocity_range": {}
        #         },
        #         {
        #             "asset_cfg": SceneEntityCfg("green_block"),
        #             "pose_range": {"x": [-0.08, 0.08], "y": [-0.08, 0.08]},
        #             "velocity_range": {}
        #         }
        #     ]
        # ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))

===== tasks/g1_tasks/stack_rgyblock_g1_29dof_dex3/__init__.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import gymnasium as gym
import os

from . import stack_rgyblock_g1_29dof_dex3_joint_env_cfg


gym.register(
    id="Isaac-Stack-RgyBlock-G129-Dex3-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": stack_rgyblock_g1_29dof_dex3_joint_env_cfg.StackRgyBlockG129DEX3BaseFixEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/g1_tasks/stack_rgyblock_g1_29dof_dex3/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  


===== tasks/g1_tasks/stack_rgyblock_g1_29dof_dex3/mdp/observations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.dex3_state import get_robot_dex3_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_dex3_joint_states", 
    "get_camera_image"
]



===== tasks/g1_tasks/stack_rgyblock_g1_29dof_dex3/mdp/rewards.py =====

from tasks.common_rewards.base_reward_stack_rgyblock import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/g1_tasks/stack_rgyblock_g1_29dof_dex3/mdp/terminations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from tasks.common_termination.base_termination_stack_rgyblock import reset_object_estimate


__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/stack_rgyblock_g1_29dof_dex3/stack_rgyblock_g1_29dof_dex3_joint_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING



import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager, BatchObjectEvent, MultiObjectEvent

# import public scene configuration
from tasks.common_scene.base_scene_stack_rgyblock import TableRedGreenYellowBlockSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableRedGreenYellowBlockSceneCfg):
    """object table scene configuration class
    
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_dex3_base_fix(init_pos=(-4.2, -3.7, 0.76),
        init_rot=(0.7071, 0, 0, -0.7071))


    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_dex3_wrist_camera()
    right_wrist_camera = CameraPresets.right_dex3_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """Observation specifications for the MDP."""
    """defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """
        # 1. robot joint state observation
        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        # 2. gripper joint state observation 
        robot_dex3_state = ObsTerm(func=mdp.get_robot_dex3_joint_states)

        # 3. camera image observation
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    reset_red_block = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify the object to reset
            "asset_cfg": SceneEntityCfg("red_block"),
        },
    )
    reset_yellow_block = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            "asset_cfg": SceneEntityCfg("yellow_block"),
        },
    )   
    reset_green_block = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            "asset_cfg": SceneEntityCfg("green_block"),
        },
    )   

@configclass
class StackRgyBlockG129DEX3BaseFixEnvCfg(ManagerBasedRLEnvCfg):
    """Unitree G1 robot stack red, yellow, green block environment configuration class
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
    # 3. MDP settings
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        self.decimation = 2
        self.episode_length_s = 20.0
        # simulation settings
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 32 * 1024
        self.sim.physx.friction_correlation_distance = 0.003
        self.sim.physx.enable_ccd = True
        self.sim.physx.gpu_constraint_solver_heavy_spring_enabled = True
        self.sim.physx.num_substeps = 4
        self.sim.physx.contact_offset = 0.01
        self.sim.physx.rest_offset = 0.001
        self.sim.physx.num_position_iterations = 16
        self.sim.physx.num_velocity_iterations = 4
        # create event manager
        self.event_manager = SimpleEventManager() 

        self.event_manager.register_multi_object_reset(
            name="reset_object_self",
            object_names=["red_block", "yellow_block", "green_block"],
            pose_ranges={"x": [-0.05, 0.05], "y": [-0.05, 0.05]},  # æ‰€æœ‰ç‰©ä½“ä½¿ç”¨ç›¸åŒèŒƒå›´
            velocity_ranges={}
        )
        
        # æ–¹æ³•2ï¼šå¦‚æœéœ€è¦ä¸ºä¸åŒç‰©ä½“è®¾ç½®ä¸åŒçš„é‡ç½®èŒƒå›´ï¼Œå¯ä»¥ä½¿ç”¨è¿™ç§æ–¹å¼
        # self.event_manager.register("reset_object_self", BatchObjectEvent(
        #     object_names=["red_block", "yellow_block", "green_block"],
        #     pose_ranges={
        #         "red_block": {"x": [-0.05, 0.05], "y": [-0.05, 0.05]},
        #         "yellow_block": {"x": [-0.03, 0.03], "y": [-0.03, 0.03]},
        #         "green_block": {"x": [-0.08, 0.08], "y": [-0.08, 0.08]}
        #     },
        #     velocity_ranges={}
        # ))
        
        # æ–¹æ³•3ï¼šä½¿ç”¨MultiObjectEventçš„è¯¦ç»†é…ç½®æ–¹å¼
        # self.event_manager.register("reset_object_self", MultiObjectEvent(
        #     reset_configs=[
        #         {
        #             "asset_cfg": SceneEntityCfg("red_block"),
        #             "pose_range": {"x": [-0.05, 0.05], "y": [-0.05, 0.05]},
        #             "velocity_range": {}
        #         },
        #         {
        #             "asset_cfg": SceneEntityCfg("yellow_block"),
        #             "pose_range": {"x": [-0.03, 0.03], "y": [-0.03, 0.03]},
        #             "velocity_range": {}
        #         },
        #         {
        #             "asset_cfg": SceneEntityCfg("green_block"),
        #             "pose_range": {"x": [-0.08, 0.08], "y": [-0.08, 0.08]},
        #             "velocity_range": {}
        #         }
        #     ]
        # ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))

===== tasks/g1_tasks/stack_rgyblock_g1_29dof_inspire/__init__.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import gymnasium as gym
import os

from . import stack_rgyblock_g1_29dof_inspire_joint_env_cfg


gym.register(
    id="Isaac-Stack-RgyBlock-G129-Inspire-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": stack_rgyblock_g1_29dof_inspire_joint_env_cfg.StackRgyBlockG129InspireBaseFixEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/g1_tasks/stack_rgyblock_g1_29dof_inspire/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  


===== tasks/g1_tasks/stack_rgyblock_g1_29dof_inspire/mdp/observations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.g1_29dof_state import get_robot_boy_joint_states
from tasks.common_observations.inspire_state import get_robot_inspire_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_inspire_joint_states", 
    "get_camera_image"
]



===== tasks/g1_tasks/stack_rgyblock_g1_29dof_inspire/mdp/rewards.py =====

from tasks.common_rewards.base_reward_stack_rgyblock import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/g1_tasks/stack_rgyblock_g1_29dof_inspire/mdp/terminations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from tasks.common_termination.base_termination_stack_rgyblock import reset_object_estimate


__all__ = [
"reset_object_estimate"
]

===== tasks/g1_tasks/stack_rgyblock_g1_29dof_inspire/stack_rgyblock_g1_29dof_inspire_joint_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING



import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  G1RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager, BatchObjectEvent, MultiObjectEvent

# import public scene configuration
from tasks.common_scene.base_scene_stack_rgyblock import TableRedGreenYellowBlockSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableRedGreenYellowBlockSceneCfg):
    """object table scene configuration class
    
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = G1RobotPresets.g1_29dof_inspire_base_fix(init_pos=(-4.2, -3.7, 0.76),
        init_rot=(0.7071, 0, 0, -0.7071))


    # 6. add camera configuration 
    front_camera = CameraPresets.g1_front_camera()
    left_wrist_camera = CameraPresets.left_inspire_wrist_camera()
    right_wrist_camera = CameraPresets.right_inspire_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """Observation specifications for the MDP."""
    """defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """
        # 1. robot joint state observation
        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        # 2. gripper joint state observation 
        robot_inspire_state = ObsTerm(func=mdp.get_robot_inspire_joint_states)

        # 3. camera image observation
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    reset_red_block = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify the object to reset
            "asset_cfg": SceneEntityCfg("red_block"),
        },
    )
    reset_yellow_block = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            "asset_cfg": SceneEntityCfg("yellow_block"),
        },
    )   
    reset_green_block = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            "asset_cfg": SceneEntityCfg("green_block"),
        },
    )   

@configclass
class StackRgyBlockG129InspireBaseFixEnvCfg(ManagerBasedRLEnvCfg):
    """Unitree G1 robot stack red, yellow, green block environment configuration class
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
    # 3. MDP settings
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        self.decimation = 2
        self.episode_length_s = 20.0
        # simulation settings
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 32 * 1024
        self.sim.physx.friction_correlation_distance = 0.003
        self.sim.physx.enable_ccd = True
        self.sim.physx.gpu_constraint_solver_heavy_spring_enabled = True
        self.sim.physx.num_substeps = 4
        self.sim.physx.contact_offset = 0.01
        self.sim.physx.rest_offset = 0.001
        self.sim.physx.num_position_iterations = 16
        self.sim.physx.num_velocity_iterations = 4
        # create event manager
        self.event_manager = SimpleEventManager() 

        self.event_manager.register_multi_object_reset(
            name="reset_object_self",
            object_names=["red_block", "yellow_block", "green_block"],
            pose_ranges={"x": [-0.05, 0.05], "y": [-0.05, 0.05]},  # æ‰€æœ‰ç‰©ä½“ä½¿ç”¨ç›¸åŒèŒƒå›´
            velocity_ranges={}
        )
        
        # æ–¹æ³•2ï¼šå¦‚æœéœ€è¦ä¸ºä¸åŒç‰©ä½“è®¾ç½®ä¸åŒçš„é‡ç½®èŒƒå›´ï¼Œå¯ä»¥ä½¿ç”¨è¿™ç§æ–¹å¼
        # self.event_manager.register("reset_object_self", BatchObjectEvent(
        #     object_names=["red_block", "yellow_block", "green_block"],
        #     pose_ranges={
        #         "red_block": {"x": [-0.05, 0.05], "y": [-0.05, 0.05]},
        #         "yellow_block": {"x": [-0.03, 0.03], "y": [-0.03, 0.03]},
        #         "green_block": {"x": [-0.08, 0.08], "y": [-0.08, 0.08]}
        #     },
        #     velocity_ranges={}
        # ))
        
        # æ–¹æ³•3ï¼šä½¿ç”¨MultiObjectEventçš„è¯¦ç»†é…ç½®æ–¹å¼
        # self.event_manager.register("reset_object_self", MultiObjectEvent(
        #     reset_configs=[
        #         {
        #             "asset_cfg": SceneEntityCfg("red_block"),
        #             "pose_range": {"x": [-0.05, 0.05], "y": [-0.05, 0.05]},
        #             "velocity_range": {}
        #         },
        #         {
        #             "asset_cfg": SceneEntityCfg("yellow_block"),
        #             "pose_range": {"x": [-0.03, 0.03], "y": [-0.03, 0.03]},
        #             "velocity_range": {}
        #         },
        #         {
        #             "asset_cfg": SceneEntityCfg("green_block"),
        #             "pose_range": {"x": [-0.08, 0.08], "y": [-0.08, 0.08]},
        #             "velocity_range": {}
        #         }
        #     ]
        # ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))

===== tasks/h1-2_tasks/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
"""Unitree G1 robot task module
contains various task implementations for the G1 robot, such as pick and place, motion control, etc.
"""

# use relative import

from . import pick_place_cylinder_h12_27dof_inspire
from . import stack_rgyblock_h12_27dof_inspire
from . import pick_place_redblock_h12_27dof_inspire


# export all modules
__all__ = [
        "pick_place_cylinder_h12_27dof_inspire",
        "stack_rgyblock_h12_27dof_inspire",
        "pick_place_redblock_h12_27dof_inspire",

]

===== tasks/h1-2_tasks/pick_place_cylinder_h12_27dof_inspire/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

import gymnasium as gym

from . import pickplace_cylinder_h12_27dof_inspire_env_cfg


gym.register(
    id="Isaac-PickPlace-Cylinder-H12-27dof-Inspire-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": pickplace_cylinder_h12_27dof_inspire_env_cfg.PickPlaceH1227dofInspireBaseFixEnvCfg,
    },
    disable_env_checker=True,
)


===== tasks/h1-2_tasks/pick_place_cylinder_h12_27dof_inspire/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  


===== tasks/h1-2_tasks/pick_place_cylinder_h12_27dof_inspire/mdp/observations.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.h12_27dof_state import get_robot_boy_joint_states
from tasks.common_observations.inspire_state import get_robot_inspire_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_inspire_joint_states", 
    "get_camera_image"
]



===== tasks/h1-2_tasks/pick_place_cylinder_h12_27dof_inspire/mdp/rewards.py =====

from tasks.common_rewards.base_reward_pickplace_cylindercfg import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/h1-2_tasks/pick_place_cylinder_h12_27dof_inspire/mdp/terminations.py =====

from tasks.common_termination.base_termination_pick_place_cylinder import reset_object_estimate
__all__ = [
"reset_object_estimate"
]

===== tasks/h1-2_tasks/pick_place_cylinder_h12_27dof_inspire/pickplace_cylinder_h12_27dof_inspire_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING

from pink.tasks import FrameTask

import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  H12RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager

# import public scene configuration
from tasks.common_scene.base_scene_pickplace_cylindercfg import TableCylinderSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableCylinderSceneCfg):
    """object table scene configuration class
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = H12RobotPresets.h12_27dof_inspire_base_fix()


    # 6. add camera configuration 
    front_camera = CameraPresets.h12_front_camera()
    left_wrist_camera = CameraPresets.left_inspire_wrist_camera()
    right_wrist_camera = CameraPresets.right_inspire_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """
    defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """

        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        robot_inspire_state = ObsTerm(func=mdp.get_robot_inspire_joint_states)

        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    reset_object = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify the object to reset
            "asset_cfg": SceneEntityCfg("object"),
        },
    )


@configclass
class PickPlaceH1227dofInspireBaseFixEnvCfg(ManagerBasedRLEnvCfg):
    """
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
        
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        # general settings
        self.decimation = 2
        self.episode_length_s = 20.0
        # simulation settings
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 16 * 1024
        self.sim.physx.friction_correlation_distance = 0.00625
        # create event manager
        self.event_manager = SimpleEventManager()

        # register "reset object" event
        self.event_manager.register("reset_object_self", SimpleEvent(
            func=lambda env: base_mdp.reset_root_state_uniform(
                env,
                torch.arange(env.num_envs, device=env.device),
                pose_range={"x": [-0.05, 0.05], "y": [0.0, 0.05]},
                velocity_range={},
                asset_cfg=SceneEntityCfg("object"),
            )
        ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))


===== tasks/h1-2_tasks/pick_place_redblock_h12_27dof_inspire/__init__.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import gymnasium as gym
import os

from . import pickplace_redblock_h12_27dof_inspire_joint_env_cfg


gym.register(
    id="Isaac-PickPlace-RedBlock-H12-27dof-Inspire-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": pickplace_redblock_h12_27dof_inspire_joint_env_cfg.PickPlaceH1227dofInspireHandBaseFixEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/h1-2_tasks/pick_place_redblock_h12_27dof_inspire/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  


===== tasks/h1-2_tasks/pick_place_redblock_h12_27dof_inspire/mdp/observations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.h12_27dof_state import get_robot_boy_joint_states
from tasks.common_observations.inspire_state import get_robot_inspire_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_inspire_joint_states", 
    "get_camera_image"
]



===== tasks/h1-2_tasks/pick_place_redblock_h12_27dof_inspire/mdp/rewards.py =====

from tasks.common_rewards.base_reward_pickplace_redblock import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/h1-2_tasks/pick_place_redblock_h12_27dof_inspire/mdp/terminations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from tasks.common_termination.base_termination_pick_place_redblock import reset_object_estimate


__all__ = [
"reset_object_estimate"
]

===== tasks/h1-2_tasks/pick_place_redblock_h12_27dof_inspire/pickplace_redblock_h12_27dof_inspire_joint_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING



import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  H12RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager

# import public scene configuration
from tasks.common_scene.base_scene_pickplace_redblock import TableRedBlockSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableRedBlockSceneCfg):
    """object table scene configuration class
    
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = H12RobotPresets.h12_27dof_inspire_base_fix(init_pos=(-4.2, -3.7, 0.76),
        init_rot=(0.7071, 0, 0, -0.7071))


    # 6. add camera configuration 
    front_camera = CameraPresets.h12_front_camera()
    left_wrist_camera = CameraPresets.left_inspire_wrist_camera()
    right_wrist_camera = CameraPresets.right_inspire_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """Observation specifications for the MDP."""
    """defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """
        # 1. robot joint state observation
        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        # 2. gripper joint state observation 
        robot_inspire_state = ObsTerm(func=mdp.get_robot_inspire_joint_states)

        # 3. camera image observation
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    reset_object = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify the object to reset
            "asset_cfg": SceneEntityCfg("object"),
        },
    )


@configclass
class PickPlaceH1227dofInspireHandBaseFixEnvCfg(ManagerBasedRLEnvCfg):
    """Unitree G1 robot pick place environment configuration class
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
    # 3. MDP settings
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        self.decimation = 2
        self.episode_length_s = 20.0
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 32 * 1024
        self.sim.physx.friction_correlation_distance = 0.003
        self.sim.physx.enable_ccd = True
        self.sim.physx.gpu_constraint_solver_heavy_spring_enabled = True
        self.sim.physx.num_substeps = 2
        self.sim.physx.contact_offset = 0.015
        self.sim.physx.rest_offset = 0.001
        self.sim.physx.num_position_iterations = 12
        self.sim.physx.num_velocity_iterations = 4

        # create event manager
        self.event_manager = SimpleEventManager() 

        # register "reset object" event
        self.event_manager.register("reset_object_self", SimpleEvent(
            func=lambda env: base_mdp.reset_root_state_uniform(
                env,
                torch.arange(env.num_envs, device=env.device),
                pose_range={"x": [-0.05, 0.05], "y": [-0.05, 0.05]},
                velocity_range={},
                asset_cfg=SceneEntityCfg("object"),
            )
        ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))

===== tasks/h1-2_tasks/stack_rgyblock_h12_27dof_inspire/__init__.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import gymnasium as gym
import os

from . import stack_rgyblock_h12_27dof_inspire_joint_env_cfg


gym.register(
    id="Isaac-Stack-RgyBlock-H12-27dof-Inspire-Joint",
    entry_point="isaaclab.envs:ManagerBasedRLEnv",
    kwargs={
        "env_cfg_entry_point": stack_rgyblock_h12_27dof_inspire_joint_env_cfg.StackRgyBlockH1227dofInspireBaseFixEnvCfg,
    },
    disable_env_checker=True,
)



===== tasks/h1-2_tasks/stack_rgyblock_h12_27dof_inspire/mdp/__init__.py =====


# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  

"""This sub-module contains the functions that are specific to the pick place environments."""

from isaaclab.envs.mdp import *  

from .observations import *  
from .terminations import *  
from .rewards import *  


===== tasks/h1-2_tasks/stack_rgyblock_h12_27dof_inspire/mdp/observations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
from tasks.common_observations.h12_27dof_state import get_robot_boy_joint_states
from tasks.common_observations.inspire_state import get_robot_inspire_joint_states
from tasks.common_observations.camera_state import get_camera_image

# ensure functions can be accessed by external modules
__all__ = [
    "get_robot_boy_joint_states",
    "get_robot_inspire_joint_states", 
    "get_camera_image"
]



===== tasks/h1-2_tasks/stack_rgyblock_h12_27dof_inspire/mdp/rewards.py =====

from tasks.common_rewards.base_reward_stack_rgyblock import compute_reward

__all__ = [
"compute_reward"
]

===== tasks/h1-2_tasks/stack_rgyblock_h12_27dof_inspire/mdp/terminations.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0      
from tasks.common_termination.base_termination_stack_rgyblock import reset_object_estimate


__all__ = [
"reset_object_estimate"
]

===== tasks/h1-2_tasks/stack_rgyblock_h12_27dof_inspire/stack_rgyblock_h12_27dof_inspire_joint_env_cfg.py =====

# Copyright (c) 2025, Unitree Robotics Co., Ltd. All Rights Reserved.
# License: Apache License, Version 2.0  
import tempfile
import torch
from dataclasses import MISSING



import isaaclab.envs.mdp as base_mdp
from isaaclab.envs import ManagerBasedRLEnvCfg
from isaaclab.managers import EventTermCfg
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.managers import TerminationTermCfg as DoneTerm
from isaaclab.managers import RewardTermCfg as RewTerm
from isaaclab.utils import configclass
from isaaclab.assets import ArticulationCfg
from . import mdp
# use Isaac Lab native event system

from tasks.common_config import  H12RobotPresets, CameraPresets  # isort: skip
from tasks.common_event.event_manager import SimpleEvent, SimpleEventManager, BatchObjectEvent, MultiObjectEvent

# import public scene configuration
from tasks.common_scene.base_scene_stack_rgyblock import TableRedGreenYellowBlockSceneCfg

##
# Scene definition
##

@configclass
class ObjectTableSceneCfg(TableRedGreenYellowBlockSceneCfg):
    """object table scene configuration class
    
    inherits from G1SingleObjectSceneCfg, gets the complete G1 robot scene configuration
    can add task-specific scene elements or override default configurations here
    """
    
    # Humanoid robot w/ arms higher
    # 5. humanoid robot configuration 
    robot: ArticulationCfg = H12RobotPresets.h12_27dof_inspire_base_fix(init_pos=(-4.2, -3.7, 0.76),
        init_rot=(0.7071, 0, 0, -0.7071))


    # 6. add camera configuration 
    front_camera = CameraPresets.h12_front_camera()
    left_wrist_camera = CameraPresets.left_inspire_wrist_camera()
    right_wrist_camera = CameraPresets.right_inspire_wrist_camera()

##
# MDP settings
##
@configclass
class ActionsCfg:
    """defines the action configuration related to robot control, using direct joint angle control
    """
    joint_pos = mdp.JointPositionActionCfg(asset_name="robot", joint_names=[".*"], scale=1.0, use_default_offset=True)



@configclass
class ObservationsCfg:
    """Observation specifications for the MDP."""
    """defines all available observation information
    """
    @configclass
    class PolicyCfg(ObsGroup):
        """policy group observation configuration class
        defines all state observation values for policy decision
        inherit from ObsGroup base class 
        """
        # 1. robot joint state observation
        robot_joint_state = ObsTerm(func=mdp.get_robot_boy_joint_states)
        # 2. gripper joint state observation 
        robot_inspire_state = ObsTerm(func=mdp.get_robot_inspire_joint_states)

        # 3. camera image observation
        camera_image = ObsTerm(func=mdp.get_camera_image)

        def __post_init__(self):
            """post initialization function
            set the basic attributes of the observation group
            """
            self.enable_corruption = False  # disable observation value corruption
            self.concatenate_terms = False  # disable observation item connection

    # observation groups
    # create policy observation group instance
    policy: PolicyCfg = PolicyCfg()


@configclass
class TerminationsCfg:
    # check if the object is out of the working range
    success = DoneTerm(func=mdp.reset_object_estimate)# use task completion check function

@configclass
class RewardsCfg:
    reward = RewTerm(func=mdp.compute_reward,weight=1.0)

@configclass
class EventCfg:
    reset_red_block = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            # position range parameter
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            # specify the object to reset
            "asset_cfg": SceneEntityCfg("red_block"),
        },
    )
    reset_yellow_block = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            "asset_cfg": SceneEntityCfg("yellow_block"),
        },
    )   
    reset_green_block = EventTermCfg(
        func=mdp.reset_root_state_uniform,  # use uniform distribution reset function
        mode="reset",   # set event mode to reset
        params={
            "pose_range": {
                "x": [-0.05, 0.05],  # x axis position range: -0.05 to 0.0 meter
                "y": [-0.05, 0.05],   # y axis position range: 0.0 to 0.05 meter
            },
            # speed range parameter (empty dictionary means using default value)
            "velocity_range": {},
            "asset_cfg": SceneEntityCfg("green_block"),
        },
    )   

@configclass
class StackRgyBlockH1227dofInspireBaseFixEnvCfg(ManagerBasedRLEnvCfg):
    """Unitree G1 robot stack red, yellow, green block environment configuration class
    inherits from ManagerBasedRLEnvCfg, defines all configuration parameters for the entire environment
    """

    # 1. scene settings
    scene: ObjectTableSceneCfg = ObjectTableSceneCfg(num_envs=1, # environment number: 1
                                                     env_spacing=2.5, # environment spacing: 2.5 meter
                                                     replicate_physics=True # enable physics replication
                                                     )
    # basic settings
    observations: ObservationsCfg = ObservationsCfg()   # observation configuration
    actions: ActionsCfg = ActionsCfg()                  # action configuration
    # MDP settings
    # 3. MDP settings
    terminations: TerminationsCfg = TerminationsCfg()    # termination configuration
    events = EventCfg()                                  # event configuration
    commands = None # command manager
    rewards: RewardsCfg = RewardsCfg()  # reward manager
    curriculum = None # curriculum manager
    def __post_init__(self):
        """Post initialization."""
        self.decimation = 2
        self.episode_length_s = 20.0
        # simulation settings
        self.sim.dt = 0.005
        self.sim.render_interval = self.decimation
        self.sim.physx.bounce_threshold_velocity = 0.01
        self.sim.physx.gpu_found_lost_aggregate_pairs_capacity = 1024 * 1024 * 4
        self.sim.physx.gpu_total_aggregate_pairs_capacity = 32 * 1024
        self.sim.physx.friction_correlation_distance = 0.003
        self.sim.physx.enable_ccd = True
        self.sim.physx.gpu_constraint_solver_heavy_spring_enabled = True
        self.sim.physx.num_substeps = 4
        self.sim.physx.contact_offset = 0.01
        self.sim.physx.rest_offset = 0.001
        self.sim.physx.num_position_iterations = 16
        self.sim.physx.num_velocity_iterations = 4
        # create event manager
        self.event_manager = SimpleEventManager() 

        self.event_manager.register_multi_object_reset(
            name="reset_object_self",
            object_names=["red_block", "yellow_block", "green_block"],
            pose_ranges={"x": [-0.05, 0.05], "y": [-0.05, 0.05]},  # æ‰€æœ‰ç‰©ä½“ä½¿ç”¨ç›¸åŒèŒƒå›´
            velocity_ranges={}
        )
        
        # æ–¹æ³•2ï¼šå¦‚æœéœ€è¦ä¸ºä¸åŒç‰©ä½“è®¾ç½®ä¸åŒçš„é‡ç½®èŒƒå›´ï¼Œå¯ä»¥ä½¿ç”¨è¿™ç§æ–¹å¼
        # self.event_manager.register("reset_object_self", BatchObjectEvent(
        #     object_names=["red_block", "yellow_block", "green_block"],
        #     pose_ranges={
        #         "red_block": {"x": [-0.05, 0.05], "y": [-0.05, 0.05]},
        #         "yellow_block": {"x": [-0.03, 0.03], "y": [-0.03, 0.03]},
        #         "green_block": {"x": [-0.08, 0.08], "y": [-0.08, 0.08]}
        #     },
        #     velocity_ranges={}
        # ))
        
        # æ–¹æ³•3ï¼šä½¿ç”¨MultiObjectEventçš„è¯¦ç»†é…ç½®æ–¹å¼
        # self.event_manager.register("reset_object_self", MultiObjectEvent(
        #     reset_configs=[
        #         {
        #             "asset_cfg": SceneEntityCfg("red_block"),
        #             "pose_range": {"x": [-0.05, 0.05], "y": [-0.05, 0.05]},
        #             "velocity_range": {}
        #         },
        #         {
        #             "asset_cfg": SceneEntityCfg("yellow_block"),
        #             "pose_range": {"x": [-0.03, 0.03], "y": [-0.03, 0.03]},
        #             "velocity_range": {}
        #         },
        #         {
        #             "asset_cfg": SceneEntityCfg("green_block"),
        #             "pose_range": {"x": [-0.08, 0.08], "y": [-0.08, 0.08]},
        #             "velocity_range": {}
        #         }
        #     ]
        # ))
        
        self.event_manager.register("reset_all_self", SimpleEvent(
            func=lambda env: base_mdp.reset_scene_to_default(
                env,
                torch.arange(env.num_envs, device=env.device))
        ))

===== tasks/utils/__init__.py =====

# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""Sub-package with utilities, data collectors and environment wrappers."""

from .importer import import_packages
from .parse_cfg import get_checkpoint_path, load_cfg_from_registry, parse_env_cfg


===== tasks/utils/env_config_utils.py =====

"""
ç¯å¢ƒé…ç½®å·¥å…·æ¨¡å—
æä¾›å¢å¼ºçš„ç¯å¢ƒé…ç½®ç®¡ç†å’Œå‚æ•°ä¼ é€’åŠŸèƒ½
"""

import argparse
from typing import Dict, Any, Optional
from pathlib import Path


def create_enhanced_env_cfg(task_name: str, args: argparse.Namespace):
    """åˆ›å»ºå¢å¼ºçš„ç¯å¢ƒé…ç½®
    
    Args:
        task_name: ä»»åŠ¡åç§°
        args: å‘½ä»¤è¡Œå‚æ•°
        
    Returns:
        ç¯å¢ƒé…ç½®å¯¹è±¡
    """
    
    # æ ¹æ®ä»»åŠ¡åç§°é€‰æ‹©åˆé€‚çš„é…ç½®åˆ›å»ºæ–¹æ³•
    if "Isaac-PickPlace-G129" in task_name:
        return create_g129_pickplace_cfg(args)
    else:
        # å›é€€åˆ°æ ‡å‡†æ–¹æ³•
        from isaaclab_tasks.utils.parse_cfg import parse_env_cfg
        return parse_env_cfg(task_name, device=args.device, num_envs=getattr(args, 'num_envs', 1))


def create_g129_pickplace_cfg(args: argparse.Namespace):
    """åˆ›å»ºG129æŠ“å–æ”¾ç½®ä»»åŠ¡çš„ç¯å¢ƒé…ç½®
    
    Args:
        args: å‘½ä»¤è¡Œå‚æ•°
        
    Returns:
        PickPlaceG129DEX1JointWaistFixEnvCfg: ç¯å¢ƒé…ç½®
    """
    from tasks.g1_tasks.pick_place_cylinder_g1_29dof_dex1.pickplace_cylinder_g1_29dof_dex1_joint_env_cfg import (
        PickPlaceG129DEX1JointWaistFixEnvCfg
    )
    
    # ä»argsä¸­æå–å‚æ•°
    num_envs = getattr(args, 'num_envs', 1)
    device = getattr(args, 'device', 'cuda')
    env_spacing = getattr(args, 'env_spacing', 2.5)
    
    # ä½¿ç”¨æ–°çš„åˆ›å»ºæ–¹æ³•
    env_cfg = PickPlaceG129DEX1JointWaistFixEnvCfg.create_with_params(
        num_envs=num_envs,
        device=device,
        env_spacing=env_spacing
    )
    
    # è®¾ç½®ä»»åŠ¡åç§°
    env_cfg.env_name = args.task
    
    # åº”ç”¨å…¶ä»–é…ç½®
    apply_performance_optimizations(env_cfg, args)
    apply_termination_settings(env_cfg, args)
    
    return env_cfg


def apply_performance_optimizations(env_cfg, args: argparse.Namespace):
    """åº”ç”¨æ€§èƒ½ä¼˜åŒ–è®¾ç½®
    
    Args:
        env_cfg: ç¯å¢ƒé…ç½®
        args: å‘½ä»¤è¡Œå‚æ•°
    """
    
    # æ ¹æ®ç²¾åº¦æ¨¡å¼è°ƒæ•´ä»¿çœŸå‚æ•°
    precision_mode = getattr(args, 'precision_mode', 'balanced')
    
    if precision_mode == 'fast':
        # å¿«é€Ÿæ¨¡å¼ï¼šé™ä½ç²¾åº¦ï¼Œæé«˜é€Ÿåº¦
        env_cfg.sim.dt = 0.01  # æ›´å¤§çš„æ—¶é—´æ­¥é•¿
        if hasattr(env_cfg.sim, 'substeps'):
            env_cfg.sim.substeps = 1
            
    elif precision_mode == 'precise':
        # ç²¾ç¡®æ¨¡å¼ï¼šæé«˜ç²¾åº¦ï¼Œå¯èƒ½é™ä½é€Ÿåº¦
        env_cfg.sim.dt = 0.002  # æ›´å°çš„æ—¶é—´æ­¥é•¿
        if hasattr(env_cfg.sim, 'substeps'):
            env_cfg.sim.substeps = 4
            
    else:  # balanced
        # å¹³è¡¡æ¨¡å¼ï¼šé»˜è®¤è®¾ç½®
        env_cfg.sim.dt = 0.005
        if hasattr(env_cfg.sim, 'substeps'):
            env_cfg.sim.substeps = 2
    
    # æ ¹æ®ä¼˜åŒ–è®¾ç½®è°ƒæ•´æ¸²æŸ“é¢‘ç‡
    if getattr(args, 'disable_optimizations', False):
        # ç¦ç”¨ä¼˜åŒ–æ—¶ä½¿ç”¨æ ‡å‡†è®¾ç½®
        pass
    else:
        # å¯ç”¨ä¼˜åŒ–æ—¶è°ƒæ•´è®¾ç½®
        if hasattr(env_cfg, 'decimation'):
            # æ ¹æ®step_hzè°ƒæ•´decimation
            step_hz = getattr(args, 'step_hz', 500)
            if step_hz > 300:
                env_cfg.decimation = 2  # æ›´é«˜çš„æ§åˆ¶é¢‘ç‡
            elif step_hz < 100:
                env_cfg.decimation = 8  # æ›´ä½çš„æ§åˆ¶é¢‘ç‡


def apply_termination_settings(env_cfg, args: argparse.Namespace):
    """åº”ç”¨ç»ˆæ­¢æ¡ä»¶è®¾ç½®
    
    Args:
        env_cfg: ç¯å¢ƒé…ç½®
        args: å‘½ä»¤è¡Œå‚æ•°
    """
    
    # æ ¹æ®å‚æ•°å†³å®šæ˜¯å¦ç§»é™¤è¶…æ—¶ç»ˆæ­¢æ¡ä»¶
    if getattr(args, 'disable_timeout', True):  # é»˜è®¤ç¦ç”¨è¶…æ—¶
        if hasattr(env_cfg.terminations, 'time_out'):
            env_cfg.terminations.time_out = None
    
    # è®¾ç½®episodeé•¿åº¦
    episode_length = getattr(args, 'episode_length', 20.0)
    env_cfg.episode_length_s = episode_length


def add_env_config_args(parser: argparse.ArgumentParser):
    """æ·»åŠ ç¯å¢ƒé…ç½®ç›¸å…³çš„å‘½ä»¤è¡Œå‚æ•°
    
    Args:
        parser: å‚æ•°è§£æå™¨
    """
    
    # ç¯å¢ƒåŸºæœ¬å‚æ•°
    env_group = parser.add_argument_group('ç¯å¢ƒé…ç½®å‚æ•°')
    env_group.add_argument("--num_envs", type=int, default=1, help="ç¯å¢ƒæ•°é‡")
    env_group.add_argument("--env_spacing", type=float, default=2.5, help="ç¯å¢ƒé—´è·")
    env_group.add_argument("--episode_length", type=float, default=20.0, help="Episodeé•¿åº¦ï¼ˆç§’ï¼‰")
    env_group.add_argument("--disable_timeout", action="store_true", default=True, help="ç¦ç”¨è¶…æ—¶ç»ˆæ­¢")
    
    # ä»¿çœŸå‚æ•°
    sim_group = parser.add_argument_group('ä»¿çœŸå‚æ•°')
    sim_group.add_argument("--sim_dt", type=float, default=0.005, help="ä»¿çœŸæ—¶é—´æ­¥é•¿")
    sim_group.add_argument("--substeps", type=int, default=2, help="ä»¿çœŸå­æ­¥æ•°")
    
    # æ€§èƒ½ä¼˜åŒ–å‚æ•°
    perf_group = parser.add_argument_group('æ€§èƒ½ä¼˜åŒ–å‚æ•°')
    perf_group.add_argument("--precision_mode", type=str, default="balanced", 
                           choices=["fast", "balanced", "precise"], help="ç²¾åº¦æ¨¡å¼")
    perf_group.add_argument("--disable_optimizations", action="store_true", help="ç¦ç”¨æ‰€æœ‰ä¼˜åŒ–")


def print_env_config_info(env_cfg, args: argparse.Namespace):
    """æ‰“å°ç¯å¢ƒé…ç½®ä¿¡æ¯
    
    Args:
        env_cfg: ç¯å¢ƒé…ç½®
        args: å‘½ä»¤è¡Œå‚æ•°
    """
    
    print("\n=== ç¯å¢ƒé…ç½®ä¿¡æ¯ ===")
    print(f"ä»»åŠ¡åç§°: {getattr(env_cfg, 'env_name', 'Unknown')}")
    print(f"ç¯å¢ƒæ•°é‡: {env_cfg.scene.num_envs}")
    print(f"ç¯å¢ƒé—´è·: {env_cfg.scene.env_spacing}")
    print(f"ç‰©ç†å¤åˆ¶: {env_cfg.scene.replicate_physics}")
    print(f"ä»¿çœŸæ—¶é—´æ­¥: {env_cfg.sim.dt}")
    print(f"Episodeé•¿åº¦: {env_cfg.episode_length_s}s")
    print(f"æ§åˆ¶é¢‘ç‡: {1.0 / (env_cfg.sim.dt * env_cfg.decimation):.1f}Hz")
    print(f"ç²¾åº¦æ¨¡å¼: {getattr(args, 'precision_mode', 'unknown')}")
    print(f"ä¼˜åŒ–çŠ¶æ€: {'ç¦ç”¨' if getattr(args, 'disable_optimizations', False) else 'å¯ç”¨'}")
    print("==================")


# ä¾¿æ·å‡½æ•°
def setup_env_from_args(args: argparse.Namespace):
    """ä»å‘½ä»¤è¡Œå‚æ•°è®¾ç½®ç¯å¢ƒé…ç½®
    
    Args:
        args: å‘½ä»¤è¡Œå‚æ•°
        
    Returns:
        tuple: (env_cfg, env)
    """
    import gymnasium as gym
    
    # åˆ›å»ºç¯å¢ƒé…ç½®
    env_cfg = create_enhanced_env_cfg(args.task, args)
    
    # æ‰“å°é…ç½®ä¿¡æ¯
    if getattr(args, 'verbose', False):
        print_env_config_info(env_cfg, args)
    
    # åˆ›å»ºç¯å¢ƒ
    env = gym.make(args.task, cfg=env_cfg).unwrapped
    
    return env_cfg, env 

===== tasks/utils/hydra.py =====

# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""Sub-module with utilities for the hydra configuration system."""


import functools
from collections.abc import Callable

try:
    import hydra
    from hydra.core.config_store import ConfigStore
    from omegaconf import DictConfig, OmegaConf
except ImportError:
    raise ImportError("Hydra is not installed. Please install it by running 'pip install hydra-core'.")

from isaaclab.envs import DirectRLEnvCfg, ManagerBasedRLEnvCfg
from isaaclab.envs.utils.spaces import replace_env_cfg_spaces_with_strings, replace_strings_with_env_cfg_spaces
from isaaclab.utils import replace_slices_with_strings, replace_strings_with_slices

from isaaclab_tasks.utils.parse_cfg import load_cfg_from_registry


def register_task_to_hydra(
    task_name: str, agent_cfg_entry_point: str
) -> tuple[ManagerBasedRLEnvCfg | DirectRLEnvCfg, dict]:
    """Register the task configuration to the Hydra configuration store.

    This function resolves the configuration file for the environment and agent based on the task's name.
    It then registers the configurations to the Hydra configuration store.

    Args:
        task_name: The name of the task.
        agent_cfg_entry_point: The entry point key to resolve the agent's configuration file.

    Returns:
        A tuple containing the parsed environment and agent configuration objects.
    """
    # load the configurations
    env_cfg = load_cfg_from_registry(task_name, "env_cfg_entry_point")
    agent_cfg = None
    if agent_cfg_entry_point:
        agent_cfg = load_cfg_from_registry(task_name, agent_cfg_entry_point)
    # replace gymnasium spaces with strings because OmegaConf does not support them.
    # this must be done before converting the env configs to dictionary to avoid internal reinterpretations
    env_cfg = replace_env_cfg_spaces_with_strings(env_cfg)
    # convert the configs to dictionary
    env_cfg_dict = env_cfg.to_dict()
    if isinstance(agent_cfg, dict) or agent_cfg is None:
        agent_cfg_dict = agent_cfg
    else:
        agent_cfg_dict = agent_cfg.to_dict()
    cfg_dict = {"env": env_cfg_dict, "agent": agent_cfg_dict}
    # replace slices with strings because OmegaConf does not support slices
    cfg_dict = replace_slices_with_strings(cfg_dict)
    # store the configuration to Hydra
    ConfigStore.instance().store(name=task_name, node=cfg_dict)
    return env_cfg, agent_cfg


def hydra_task_config(task_name: str, agent_cfg_entry_point: str) -> Callable:
    """Decorator to handle the Hydra configuration for a task.

    This decorator registers the task to Hydra and updates the environment and agent configurations from Hydra parsed
    command line arguments.

    Args:
        task_name: The name of the task.
        agent_cfg_entry_point: The entry point key to resolve the agent's configuration file.

    Returns:
        The decorated function with the envrionment's and agent's configurations updated from command line arguments.
    """

    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # register the task to Hydra
            env_cfg, agent_cfg = register_task_to_hydra(task_name, agent_cfg_entry_point)

            # define the new Hydra main function
            @hydra.main(config_path=None, config_name=task_name, version_base="1.3")
            def hydra_main(hydra_env_cfg: DictConfig, env_cfg=env_cfg, agent_cfg=agent_cfg):
                # convert to a native dictionary
                hydra_env_cfg = OmegaConf.to_container(hydra_env_cfg, resolve=True)
                # replace string with slices because OmegaConf does not support slices
                hydra_env_cfg = replace_strings_with_slices(hydra_env_cfg)
                # update the configs with the Hydra command line arguments
                env_cfg.from_dict(hydra_env_cfg["env"])
                # replace strings that represent gymnasium spaces because OmegaConf does not support them.
                # this must be done after converting the env configs from dictionary to avoid internal reinterpretations
                env_cfg = replace_strings_with_env_cfg_spaces(env_cfg)
                # get agent configs
                if isinstance(agent_cfg, dict) or agent_cfg is None:
                    agent_cfg = hydra_env_cfg["agent"]
                else:
                    agent_cfg.from_dict(hydra_env_cfg["agent"])
                # call the original function
                func(env_cfg, agent_cfg, *args, **kwargs)

            # call the new Hydra main function
            hydra_main()

        return wrapper

    return decorator


===== tasks/utils/importer.py =====

# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""Sub-module with utility for importing all modules in a package recursively."""

from __future__ import annotations

import importlib
import pkgutil
import sys


def import_packages(package_name: str, blacklist_pkgs: list[str] | None = None):
    """Import all sub-packages in a package recursively.

    It is easier to use this function to import all sub-packages in a package recursively
    than to manually import each sub-package.

    It replaces the need of the following code snippet on the top of each package's ``__init__.py`` file:

    .. code-block:: python

        import .locomotion.velocity
        import .manipulation.reach
        import .manipulation.lift

    Args:
        package_name: The package name.
        blacklist_pkgs: The list of blacklisted packages to skip. Defaults to None,
            which means no packages are blacklisted.
    """
    # Default blacklist
    if blacklist_pkgs is None:
        blacklist_pkgs = []
    # Import the package itself
    package = importlib.import_module(package_name)
    # Import all Python files
    for _ in _walk_packages(package.__path__, package.__name__ + ".", blacklist_pkgs=blacklist_pkgs):
        pass


def _walk_packages(
    path: str | None = None,
    prefix: str = "",
    onerror: callable | None = None,
    blacklist_pkgs: list[str] | None = None,
):
    """Yields ModuleInfo for all modules recursively on path, or, if path is None, all accessible modules.

    Note:
        This function is a modified version of the original ``pkgutil.walk_packages`` function. It adds
        the `blacklist_pkgs` argument to skip blacklisted packages. Please refer to the original
        ``pkgutil.walk_packages`` function for more details.
    """
    if blacklist_pkgs is None:
        blacklist_pkgs = []

    def seen(p, m={}):
        if p in m:
            return True
        m[p] = True  # noqa: R503

    for info in pkgutil.iter_modules(path, prefix):
        # check blacklisted
        if any([black_pkg_name in info.name for black_pkg_name in blacklist_pkgs]):
            continue

        # yield the module info
        yield info

        if info.ispkg:
            try:
                __import__(info.name)
            except Exception:
                if onerror is not None:
                    onerror(info.name)
                else:
                    raise
            else:
                path = getattr(sys.modules[info.name], "__path__", None) or []

                # don't traverse path items we've seen before
                path = [p for p in path if not seen(p)]

                yield from _walk_packages(path, info.name + ".", onerror, blacklist_pkgs)


===== tasks/utils/parse_cfg.py =====

# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""Sub-module with utilities for parsing and loading configurations."""


import gymnasium as gym
import importlib
import inspect
import os
import re
import yaml

from isaaclab.envs import DirectRLEnvCfg, ManagerBasedRLEnvCfg


def load_cfg_from_registry(task_name: str, entry_point_key: str) -> dict | object:
    """Load default configuration given its entry point from the gym registry.

    This function loads the configuration object from the gym registry for the given task name.
    It supports both YAML and Python configuration files.

    It expects the configuration to be registered in the gym registry as:

    .. code-block:: python

        gym.register(
            id="My-Awesome-Task-v0",
            ...
            kwargs={"env_entry_point_cfg": "path.to.config:ConfigClass"},
        )

    The parsed configuration object for above example can be obtained as:

    .. code-block:: python

        from isaaclab_tasks.utils.parse_cfg import load_cfg_from_registry

        cfg = load_cfg_from_registry("My-Awesome-Task-v0", "env_entry_point_cfg")

    Args:
        task_name: The name of the environment.
        entry_point_key: The entry point key to resolve the configuration file.

    Returns:
        The parsed configuration object. If the entry point is a YAML file, it is parsed into a dictionary.
        If the entry point is a Python class, it is instantiated and returned.

    Raises:
        ValueError: If the entry point key is not available in the gym registry for the task.
    """
    # obtain the configuration entry point
    cfg_entry_point = gym.spec(task_name).kwargs.get(entry_point_key)
    # check if entry point exists
    if cfg_entry_point is None:
        raise ValueError(
            f"Could not find configuration for the environment: '{task_name}'."
            f" Please check that the gym registry has the entry point: '{entry_point_key}'."
        )
    # parse the default config file
    if isinstance(cfg_entry_point, str) and cfg_entry_point.endswith(".yaml"):
        if os.path.exists(cfg_entry_point):
            # absolute path for the config file
            config_file = cfg_entry_point
        else:
            # resolve path to the module location
            mod_name, file_name = cfg_entry_point.split(":")
            mod_path = os.path.dirname(importlib.import_module(mod_name).__file__)
            # obtain the configuration file path
            config_file = os.path.join(mod_path, file_name)
        # load the configuration
        print(f"[INFO]: Parsing configuration from: {config_file}")
        with open(config_file, encoding="utf-8") as f:
            cfg = yaml.full_load(f)
    else:
        if callable(cfg_entry_point):
            # resolve path to the module location
            mod_path = inspect.getfile(cfg_entry_point)
            # load the configuration
            cfg_cls = cfg_entry_point()
        elif isinstance(cfg_entry_point, str):
            # resolve path to the module location
            mod_name, attr_name = cfg_entry_point.split(":")
            mod = importlib.import_module(mod_name)
            cfg_cls = getattr(mod, attr_name)
        else:
            cfg_cls = cfg_entry_point
        # load the configuration
        print(f"[INFO]: Parsing configuration from: {cfg_entry_point}")
        if callable(cfg_cls):
            cfg = cfg_cls()
        else:
            cfg = cfg_cls
    return cfg


def parse_env_cfg(
    task_name: str, device: str = "cuda:0", num_envs: int | None = None, use_fabric: bool | None = None
) -> ManagerBasedRLEnvCfg | DirectRLEnvCfg:
    """Parse configuration for an environment and override based on inputs.

    Args:
        task_name: The name of the environment.
        device: The device to run the simulation on. Defaults to "cuda:0".
        num_envs: Number of environments to create. Defaults to None, in which case it is left unchanged.
        use_fabric: Whether to enable/disable fabric interface. If false, all read/write operations go through USD.
            This slows down the simulation but allows seeing the changes in the USD through the USD stage.
            Defaults to None, in which case it is left unchanged.

    Returns:
        The parsed configuration object.

    Raises:
        RuntimeError: If the configuration for the task is not a class. We assume users always use a class for the
            environment configuration.
    """
    # load the default configuration
    cfg = load_cfg_from_registry(task_name, "env_cfg_entry_point")

    # check that it is not a dict
    # we assume users always use a class for the configuration
    if isinstance(cfg, dict):
        raise RuntimeError(f"Configuration for the task: '{task_name}' is not a class. Please provide a class.")

    # simulation device
    cfg.sim.device = device
    # disable fabric to read/write through USD
    if use_fabric is not None:
        cfg.sim.use_fabric = use_fabric
    # number of environments
    if num_envs is not None:
        cfg.scene.num_envs = num_envs

    return cfg


def get_checkpoint_path(
    log_path: str, run_dir: str = ".*", checkpoint: str = ".*", other_dirs: list[str] = None, sort_alpha: bool = True
) -> str:
    """Get path to the model checkpoint in input directory.

    The checkpoint file is resolved as: ``<log_path>/<run_dir>/<*other_dirs>/<checkpoint>``, where the
    :attr:`other_dirs` are intermediate folder names to concatenate. These cannot be regex expressions.

    If :attr:`run_dir` and :attr:`checkpoint` are regex expressions then the most recent (highest alphabetical order)
    run and checkpoint are selected. To disable this behavior, set the flag :attr:`sort_alpha` to False.

    Args:
        log_path: The log directory path to find models in.
        run_dir: The regex expression for the name of the directory containing the run. Defaults to the most
            recent directory created inside :attr:`log_path`.
        other_dirs: The intermediate directories between the run directory and the checkpoint file. Defaults to
            None, which implies that checkpoint file is directly under the run directory.
        checkpoint: The regex expression for the model checkpoint file. Defaults to the most recent
            torch-model saved in the :attr:`run_dir` directory.
        sort_alpha: Whether to sort the runs by alphabetical order. Defaults to True.
            If False, the folders in :attr:`run_dir` are sorted by the last modified time.

    Returns:
        The path to the model checkpoint.

    Raises:
        ValueError: When no runs are found in the input directory.
        ValueError: When no checkpoints are found in the input directory.

    """
    # check if runs present in directory
    try:
        # find all runs in the directory that math the regex expression
        runs = [
            os.path.join(log_path, run) for run in os.scandir(log_path) if run.is_dir() and re.match(run_dir, run.name)
        ]
        # sort matched runs by alphabetical order (latest run should be last)
        if sort_alpha:
            runs.sort()
        else:
            runs = sorted(runs, key=os.path.getmtime)
        # create last run file path
        if other_dirs is not None:
            run_path = os.path.join(runs[-1], *other_dirs)
        else:
            run_path = runs[-1]
    except IndexError:
        raise ValueError(f"No runs present in the directory: '{log_path}' match: '{run_dir}'.")

    # list all model checkpoints in the directory
    model_checkpoints = [f for f in os.listdir(run_path) if re.match(checkpoint, f)]
    # check if any checkpoints are present
    if len(model_checkpoints) == 0:
        raise ValueError(f"No checkpoints in the directory: '{run_path}' match '{checkpoint}'.")
    # sort alphabetically while ensuring that *_10 comes after *_9
    model_checkpoints.sort(key=lambda m: f"{m:0>15}")
    # get latest matched checkpoint file
    checkpoint_file = model_checkpoints[-1]

    return os.path.join(run_path, checkpoint_file)


===== tools/augmentation_utils.py =====

# utils/augmentation_utils.py

import random
from pxr import UsdShade, UsdLux, UsdGeom, Gf, Sdf
import omni.usd

# ------------------------------
# é€šç”¨å®‰å…¨è®¾ç½®å±æ€§å‡½æ•°ï¼Œé¿å…é‡å¤åˆ›å»ºå±æ€§
def safe_set_attr(prim, attr_name, value, usd_type):
    attr = prim.GetAttribute(attr_name)
    if not attr.IsValid():
        attr = prim.CreateAttribute(attr_name, usd_type)
    attr.Set(value)

# ------------------------------
# ä¿®æ”¹å…‰æºå±æ€§ï¼ˆé¢œè‰²ã€å¼ºåº¦ã€æ—‹è½¬ã€ä½ç½®ç­‰ï¼‰
def update_light(
    prim_path: str,
    color=(1.0, 1.0, 1.0),
    intensity=5000.0,
    rotation=(0.0, 0.0, 0.0),
    position=None,
    radius=None,
    enabled=None,
    temperature=None,
    cast_shadows=None,
):
    """
    æ›´æ–°å…‰æºå±æ€§ï¼Œæ”¯æŒä¸åŒå…‰æºç±»å‹ã€‚
    æ”¯æŒå‚æ•°åŒ…æ‹¬é¢œè‰²ã€å¼ºåº¦ã€æ—‹è½¬è§’åº¦ã€ä½ç½®ã€åŠå¾„ã€æ˜¯å¦å¼€å¯ã€è‰²æ¸©ã€é˜´å½±å¼€å¯ç­‰ã€‚

    Args:
        prim_path: USD Prim è·¯å¾„ï¼Œå¦‚ "/World/light"
        color: å…‰é¢œè‰² RGB tupleï¼ŒèŒƒå›´0-1
        intensity: å…‰å¼ºåº¦
        rotation: æ—‹è½¬è§’ (åº¦)ï¼Œtuple(x,y,z)
        position: ä½ç½®åæ ‡ tuple(x,y,z) æˆ– Noneï¼ˆä¸æ”¹ä½ç½®ï¼‰
        radius: ä»… SphereLight æ”¯æŒï¼ŒåŠå¾„
        enabled: æ˜¯å¦å¯ç”¨å…‰æºï¼Œbool æˆ– None
        temperature: è‰²æ¸©ï¼Œä»…éƒ¨åˆ†å…‰æºæ”¯æŒ
        cast_shadows: æ˜¯å¦æŠ•å°„é˜´å½±ï¼Œbool æˆ– None
    """
    stage = omni.usd.get_context().get_stage()
    prim = stage.GetPrimAtPath(prim_path)
    if not prim.IsValid():
        raise RuntimeError(f"[update_light] âŒ æ‰¾ä¸åˆ°å…‰æº Prim: {prim_path}")

    type_name = prim.GetTypeName()
    print(f"[update_light] âœ… å…‰æºç±»å‹: {type_name}")

    # è®¾ç½®ä½å§¿å±æ€§ï¼ˆæ—‹è½¬å’Œå¹³ç§»ï¼‰
    safe_set_attr(prim, "xformOp:rotateXYZ", Gf.Vec3f(*rotation), Sdf.ValueTypeNames.Float3)
    if position is not None:
        safe_set_attr(prim, "xformOp:translate", Gf.Vec3f(*position), Sdf.ValueTypeNames.Float3)

    # è¯†åˆ«å…‰æºç±»å‹å¹¶åˆ›å»ºå¯¹åº”æ¥å£
    light = None
    if type_name == "DomeLight":
        light = UsdLux.DomeLight(prim)
    elif type_name == "DistantLight":
        light = UsdLux.DistantLight(prim)
    elif type_name == "SphereLight":
        light = UsdLux.SphereLight(prim)
    elif type_name == "RectLight":
        light = UsdLux.RectLight(prim)
    else:
        # æœªçŸ¥å…‰æºç±»å‹ä½¿ç”¨é€šç”¨æ¥å£
        print(f"[update_light] âš ï¸ æœªçŸ¥å…‰æºç±»å‹ {type_name}ï¼Œä½¿ç”¨é€šç”¨æ¥å£è®¾ç½® color å’Œ intensity")
        safe_set_attr(prim, "color", Gf.Vec3f(*color), Sdf.ValueTypeNames.Color3f)
        safe_set_attr(prim, "intensity", intensity, Sdf.ValueTypeNames.Float)
        return

    # é€šç”¨å±æ€§è®¾ç½®
    light.CreateColorAttr().Set(Gf.Vec3f(*color))
    light.CreateIntensityAttr().Set(intensity)

    # æœ‰æ¡ä»¶åœ°è®¾ç½®å…¶ä»–å±æ€§
    if enabled is not None and type_name in ["SphereLight", "DistantLight", "RectLight"]:
        light.CreateEnableAttr().Set(enabled)

    if cast_shadows is not None and type_name in ["SphereLight", "DistantLight", "RectLight"]:
        light.CreateShadowEnableAttr().Set(cast_shadows)

    if temperature is not None and hasattr(light, "CreateTemperatureAttr"):
        light.CreateTemperatureAttr().Set(temperature)

    if radius is not None and type_name == "SphereLight":
        light.CreateRadiusAttr().Set(radius)

    print(f"[update_light] âœ… å…‰æº {prim_path} è®¾ç½®å®Œæˆ")


# ------------------------------
# ä¿®æ”¹ç›¸æœºå±æ€§ï¼Œæ”¯æŒç„¦è·ã€ä¼ æ„Ÿå™¨å°ºå¯¸ã€æ›å…‰ã€ç„¦ç‚¹è·ç¦»ç­‰
def augment_camera_appearance(
    camera_path: str,
    focal_length: float = None,
    horizontal_aperture: float = None,
    vertical_aperture: float = None,
    exposure: float = None,
    focus_distance: float = None,
):
    """
    ä¿®æ”¹é™æ€ç›¸æœºçš„è§†è§‰æˆåƒå±æ€§ï¼Œç”¨äºå¢å¼ºæ•°æ®å¤šæ ·æ€§ã€‚
    æ”¯æŒè°ƒæ•´ç„¦è·ã€è§†é‡èŒƒå›´ã€æ›å…‰ã€æ™¯æ·±ç­‰ã€‚

    Args:
        camera_path: USD ç›¸æœº Prim è·¯å¾„
        focal_length: ç„¦è·ï¼ˆå•ä½ mmï¼‰
        horizontal_aperture: ä¼ æ„Ÿå™¨å®½åº¦ï¼ˆå•ä½ mmï¼‰
        vertical_aperture: ä¼ æ„Ÿå™¨é«˜åº¦ï¼ˆå•ä½ mmï¼‰
        exposure: æ›å…‰å€¼
        focus_distance: èšç„¦è·ç¦»ï¼ˆæ™¯æ·±æ•ˆæœï¼‰
    """
    stage = omni.usd.get_context().get_stage()
    prim = stage.GetPrimAtPath(camera_path)

    if not prim or not prim.IsValid():
        raise RuntimeError(f"[augment_camera_appearance] âŒ æ‰¾ä¸åˆ°ç›¸æœº prim: {camera_path}")

    camera = UsdGeom.Camera(prim)

    if focal_length is not None:
        camera.CreateFocalLengthAttr().Set(focal_length)

    if horizontal_aperture is not None:
        camera.CreateHorizontalApertureAttr().Set(horizontal_aperture)

    if vertical_aperture is not None:
        camera.CreateVerticalApertureAttr().Set(vertical_aperture)

    if exposure is not None:
        camera.CreateExposureAttr().Set(exposure)

    if focus_distance is not None:
        camera.CreateFocusDistanceAttr().Set(focus_distance)

    print(f"[augment_camera_appearance] âœ… è®¾ç½®ç›¸æœº {camera_path} å±æ€§å®Œæˆ")

# --- æ–°å¢ï¼šæ‰¹é‡ä¿®æ”¹ç›¸æœºï¼ˆæ ¹æ®åç§°å…³é”®è¯åŒ¹é…ï¼‰ ---
def batch_augment_cameras_by_name(
    names,
    focal_length=None,
    horizontal_aperture=None,
    vertical_aperture=None,
    exposure=None,
    focus_distance=None,
):
    """
    æ‰¹é‡ä¿®æ”¹åœºæ™¯ä¸­æ‰€æœ‰åç§°åŒ…å« names ä¸­ä»»æ„å…³é”®è¯çš„ç›¸æœºå±æ€§ã€‚

    å‚æ•°:
        names: list[str] â€” ç›¸æœºåç§°å…³é”®è¯ï¼Œå¦‚ ["front_cam", "wrist_camera"]
        å…¶ä½™å‚æ•°: å¯ä¸ºå•å€¼ï¼ˆå¹¿æ’­ï¼‰æˆ–ä¸åŒ¹é…çš„ç›¸æœºæ•°é‡ä¸€è‡´çš„åˆ—è¡¨ï¼ˆé€ä¸ªèµ‹å€¼ï¼‰
    """
    from pxr import UsdGeom
    stage = omni.usd.get_context().get_stage()
    if stage is None:
        raise RuntimeError("[batch_augment_cameras_by_name] USD Stage æœªåˆå§‹åŒ–")

    matched_prims = []

    def traverse_prim(prim):
        if not prim or not prim.IsValid():
            return
        if prim.IsA(UsdGeom.Camera):
            prim_name = prim.GetName()
            if any(name in prim_name for name in names):
                matched_prims.append(prim)
        for child in prim.GetChildren():
            traverse_prim(child)

    traverse_prim(stage.GetPseudoRoot())

    if not matched_prims:
        print("[batch_augment_cameras_by_name] âš ï¸ æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„ç›¸æœº")
        return

    # å‚æ•°å±•å¼€å·¥å…·
    def normalize(param, default=None):
        if isinstance(param, (list, tuple)):
            if len(param) == len(matched_prims):
                return param
        return [param if param is not None else default] * len(matched_prims)

    focal_lengths = normalize(focal_length)
    horiz_apertures = normalize(horizontal_aperture)
    vert_apertures = normalize(vertical_aperture)
    exposures = normalize(exposure)
    focus_distances = normalize(focus_distance)

    for i, prim in enumerate(matched_prims):
        try:
            augment_camera_appearance(
                camera_path=prim.GetPath().pathString,
                focal_length=focal_lengths[i],
                horizontal_aperture=horiz_apertures[i],
                vertical_aperture=vert_apertures[i],
                exposure=exposures[i],
                focus_distance=focus_distances[i],
            )
        except Exception as e:
            print(f"[batch_augment_cameras_by_name] ä¿®æ”¹ç›¸æœº {prim.GetPath().pathString} å‡ºé”™: {e}")

    print(f"[batch_augment_cameras_by_name] âœ… æ‰¹é‡ä¿®æ”¹å®Œæˆï¼Œç›®æ ‡æ•°: {len(matched_prims)}")







===== tools/convert_urdf.py =====

# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""
URDFè½¬USDæ ¼å¼çš„å·¥å…·è„šæœ¬ã€‚

URDF (Unified Robot Description Format) æ˜¯ROSä¸­ç”¨äºæè¿°æœºå™¨äººæ‰€æœ‰å…ƒç´ çš„XMLæ–‡ä»¶æ ¼å¼ã€‚
æ›´å¤šä¿¡æ¯è¯·å‚è€ƒ: http://wiki.ros.org/urdf

æœ¬è„šæœ¬ä½¿ç”¨Isaac Simçš„URDFå¯¼å…¥å™¨æ‰©å±•(``isaacsim.asset.importer.urdf``)å°†URDFèµ„æºè½¬æ¢ä¸ºUSDæ ¼å¼ã€‚
è¿™æ˜¯ä¸€ä¸ªå‘½ä»¤è¡Œä½¿ç”¨çš„ä¾¿æ·è„šæœ¬ã€‚å…³äºURDFå¯¼å…¥å™¨çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è€ƒæ‰©å±•æ–‡æ¡£ï¼š
https://docs.isaacsim.omniverse.nvidia.com/latest/robot_setup/ext_isaacsim_asset_importer_urdf.html

å‚æ•°è¯´æ˜:
  input               è¾“å…¥URDFæ–‡ä»¶çš„è·¯å¾„
  output              è¾“å‡ºUSDæ–‡ä»¶çš„å­˜å‚¨è·¯å¾„

å¯é€‰å‚æ•°:
  -h, --help          æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
  --merge-joints      åˆå¹¶ç”±å›ºå®šå…³èŠ‚è¿æ¥çš„é“¾æ¥ (é»˜è®¤: False)
  --fix-base          å°†åŸºåº§å›ºå®šåœ¨å¯¼å…¥ä½ç½® (é»˜è®¤: False)
  --joint-stiffness   å…³èŠ‚é©±åŠ¨çš„åˆšåº¦ (é»˜è®¤: 100.0)
  --joint-damping     å…³èŠ‚é©±åŠ¨çš„é˜»å°¼ (é»˜è®¤: 1.0)
  --joint-target-type å…³èŠ‚é©±åŠ¨çš„æ§åˆ¶ç±»å‹ (é»˜è®¤: "position")
"""

"""é¦–å…ˆå¯åŠ¨Isaac Simæ¨¡æ‹Ÿå™¨"""

import argparse

from isaaclab.app import AppLauncher

# æ·»åŠ å‘½ä»¤è¡Œå‚æ•°è§£æ
parser = argparse.ArgumentParser(description="URDFè½¬USDæ ¼å¼çš„å·¥å…·")
# parser.add_argument("input", type=str, default="/home/unitree/newDisk/URDF/urdf-to-usd/g1withdex1/g1_29dof_with_dex1_rev_1_0.urdf", help="è¾“å…¥URDFæ–‡ä»¶çš„è·¯å¾„")
# parser.add_argument("output", type=str, default="/home/unitree/Code/isaaclab_demo/usd/g1_body29_hand14.usd", help="è¾“å‡ºUSDæ–‡ä»¶çš„è·¯å¾„")
parser.add_argument(
    "--merge-joints",
    action="store_true",
    default=False,
    help="åˆå¹¶ç”±å›ºå®šå…³èŠ‚è¿æ¥çš„é“¾æ¥",
)
parser.add_argument("--fix-base", action="store_true", default=True, help="å°†åŸºåº§å›ºå®šåœ¨å¯¼å…¥ä½ç½®")
parser.add_argument(
    "--joint-stiffness",
    type=float,
    default=100.0,
    help="å…³èŠ‚é©±åŠ¨çš„åˆšåº¦",
)
parser.add_argument(
    "--joint-damping",
    type=float,
    default=1.0,
    help="å…³èŠ‚é©±åŠ¨çš„é˜»å°¼",
)
parser.add_argument(
    "--joint-target-type",
    type=str,
    default="position",
    choices=["position", "velocity", "none"],
    help="å…³èŠ‚é©±åŠ¨çš„æ§åˆ¶ç±»å‹",
)

# æ·»åŠ AppLauncherçš„å‘½ä»¤è¡Œå‚æ•°
AppLauncher.add_app_launcher_args(parser)
# è§£æå‘½ä»¤è¡Œå‚æ•°
args_cli = parser.parse_args()

# å¯åŠ¨omniverseåº”ç”¨
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app

"""ä»¥ä¸‹æ˜¯ä¸»è¦åŠŸèƒ½å®ç°"""

import contextlib
import os

import carb
import isaacsim.core.utils.stage as stage_utils
import omni.kit.app

from isaaclab.sim.converters import UrdfConverter, UrdfConverterCfg
from isaaclab.utils.assets import check_file_path
from isaaclab.utils.dict import print_dict


def main():
    # æ£€æŸ¥è¾“å…¥æ–‡ä»¶è·¯å¾„æ˜¯å¦æœ‰æ•ˆ
    urdf_path = "/home/unitree/newDisk/URDF/urdf-to-usd/h1_2_inspire/h1_2.urdf" #args_cli.input
    print(urdf_path)
    if not os.path.isabs(urdf_path):
        urdf_path = os.path.abspath(urdf_path)
    if not check_file_path(urdf_path):
        raise ValueError(f"æ— æ•ˆçš„æ–‡ä»¶è·¯å¾„: {urdf_path}")
    
    # åˆ›å»ºè¾“å‡ºæ–‡ä»¶è·¯å¾„
    dest_path = "/home/unitree/newDisk/URDF/urdf-to-usd/h1_2_inspire/h1_2.urdf.usd"
    if not os.path.isabs(dest_path):
        dest_path = os.path.abspath(dest_path)

    # åˆ›å»ºURDFè½¬æ¢å™¨é…ç½®
    urdf_converter_cfg = UrdfConverterCfg(
        asset_path=urdf_path,
        usd_dir=os.path.dirname(dest_path),
        usd_file_name=os.path.basename(dest_path),
        fix_base=args_cli.fix_base,
        merge_fixed_joints=args_cli.merge_joints,
        force_usd_conversion=True,
        joint_drive=UrdfConverterCfg.JointDriveCfg(
            gains=UrdfConverterCfg.JointDriveCfg.PDGainsCfg(
                stiffness=args_cli.joint_stiffness,
                damping=args_cli.joint_damping,
            ),
            target_type=args_cli.joint_target_type,
        ),
    )

    # æ‰“å°é…ç½®ä¿¡æ¯
    print("-" * 80)
    print("-" * 80)
    print(f"è¾“å…¥URDFæ–‡ä»¶: {urdf_path}")
    print("URDFå¯¼å…¥å™¨é…ç½®:")
    print_dict(urdf_converter_cfg.to_dict(), nesting=0)
    print("-" * 80)
    print("-" * 80)

    # åˆ›å»ºURDFè½¬æ¢å™¨å¹¶å¯¼å…¥æ–‡ä»¶
    urdf_converter = UrdfConverter(urdf_converter_cfg)
    # æ‰“å°è¾“å‡ºä¿¡æ¯
    print("URDFå¯¼å…¥å™¨è¾“å‡º:")
    print(f"ç”Ÿæˆçš„USDæ–‡ä»¶: {urdf_converter.usd_path}")
    print("-" * 80)
    print("-" * 80)

    # æ£€æŸ¥æ˜¯å¦æœ‰GUIéœ€è¦æ›´æ–°:
    # è·å–è®¾ç½®æ¥å£
    carb_settings_iface = carb.settings.get_settings()
    # è¯»å–æœ¬åœ°GUIæ˜¯å¦å¯ç”¨çš„æ ‡å¿—
    local_gui = carb_settings_iface.get("/app/window/enabled")
    # è¯»å–ç›´æ’­GUIæ˜¯å¦å¯ç”¨çš„æ ‡å¿—
    livestream_gui = carb_settings_iface.get("/app/livestream/enabled")

    # å¦‚æœå¯ç”¨äº†GUIï¼Œåˆ™è¿è¡Œæ¨¡æ‹Ÿåœºæ™¯
    if local_gui or livestream_gui:
        # æ‰“å¼€USDåœºæ™¯
        stage_utils.open_stage(urdf_converter.usd_path)
        # é‡æ–°åˆå§‹åŒ–æ¨¡æ‹Ÿ
        app = omni.kit.app.get_app_interface()
        # è¿è¡Œæ¨¡æ‹Ÿ
        with contextlib.suppress(KeyboardInterrupt):
            while app.is_running():
                # æ‰§è¡Œæ¨¡æ‹Ÿæ­¥éª¤
                app.update()


if __name__ == "__main__":
    # è¿è¡Œä¸»å‡½æ•°
    main()
    # å…³é—­æ¨¡æ‹Ÿåº”ç”¨
    simulation_app.close()


===== tools/data_convert.py =====

def convert_to_joint_range(value):
    """Convert the command value to the Isaac Lab joint angle [5.6, 0] -> [-0.02, 0.024]
    
    Args:
        value: the input value, range in [5.6, 0]
                5.6: fully open
                0.0: fully closed
        
    Returns:
        float: the converted value, range in [-0.02, 0.03]
                -0.02: fully open
                0.03: fully closed
    """
    # input range (gripper control value)
    input_min = 0.0    # fully closed
    input_max = 5.4    # fully open
    
    # output range (joint angle)
    output_min = 0.024  # fully closed
    output_max = -0.02 # fully open
    
    # ensure the input value is in the valid range
    value = max(input_min, min(input_max, value))
    
    # linear mapping conversion
    converted_value = output_min + (output_max - output_min) * (value - input_min) / (input_max - input_min)
    
    return converted_value

def convert_to_gripper_range(value):
    """Convert the Isaac Lab joint angle to the gripper control value [-0.02, 0.03] -> [5.6, 0]
    
    Args:
        value: the input value, range in [-0.02, 0.024]
                -0.02: fully open
                0.03: fully closed
        
    Returns:
        float: the converted value, range in [5.6, 0]
                5.6: fully open
                0.0: fully closed
    """
    # input range (joint angle)
    input_min = 0.024   # fully closed
    input_max = -0.02  # fully open
    
    # output range (gripper control value)
    output_min = 0.0   # fully closed
    output_max = 5.4   # fully open
    try:
        value = round(float(value), 3)
    except Exception:
        pass
    # ensure the input value is in the valid range
    value = max(input_max, min(input_min, value))
    
    # linear mapping conversion
    converted_value = output_min + (output_max - output_min) * (input_min - value) / (input_min - input_max)
    
    converted_value = round(converted_value, 3)
    return converted_value

===== tools/data_json_load.py =====

import json
import numpy as np
import torch
import re
from pathlib import Path
def convert_nested_lists_to_tensor(obj):
    """
    é€’å½’éå† objï¼ŒæŠŠæ‰€æœ‰å½¢å¦‚ list[list[float]] çš„ç»“æ„è½¬ä¸º torch.tensorã€‚
    """
    if isinstance(obj, dict):
        return {k: convert_nested_lists_to_tensor(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        # åˆ¤æ–­æ˜¯å¦æ˜¯ list[list[number]]
        if all(isinstance(item, list) and all(isinstance(x, (int, float)) for x in item) for item in obj):
            return torch.tensor(obj, dtype=torch.float32)
        else:
            return [convert_nested_lists_to_tensor(item) for item in obj]
    else:
        return obj
def load_robot_data(json_path):
    """
    è¯»å–å¹¶è§£æ robot data.json æ–‡ä»¶ï¼Œå¹¶å°† sim_state ä¸­æ‰€æœ‰ list[list[float]] è½¬ä¸º tensorã€‚

    å‚æ•°:
        json_path (str): JSON æ–‡ä»¶è·¯å¾„

    è¿”å›:
        tuple: (robot_action: List[np.ndarray], hand_action: List[np.ndarray], sim_state: dict with torch.tensor)
    """
    with open(json_path, 'r') as f:
        content = json.load(f)

    info = content.get("info", {})
    text = content.get("text", {})
    data = content.get("data", [])


    if not data:
        raise ValueError("data is None")

    robot_action = []
    hand_action = []
    sim_state_json_list=[]
    sim_state_list=[]
    sim_task_name_list=[]
    for item in data:
        action = item.get("actions", {})
        if not action:
            raise ValueError("data not have action")

        left_arm = action.get("left_arm", {})
        right_arm = action.get("right_arm", {})
        left_arm_action = np.array(left_arm.get("qpos", []))
        right_arm_action = np.array(right_arm.get("qpos", []))
        left_right_arm = np.concatenate([left_arm_action, right_arm_action])

        left_hand = action.get("left_ee", {})
        right_hand = action.get("right_ee", {})
        left_hand_action = np.array(left_hand.get("qpos", []))
        right_hand_action = np.array(right_hand.get("qpos", []))
        left_right_hand = np.concatenate([right_hand_action, left_hand_action])

        robot_action.append(left_right_arm)
        hand_action.append(left_right_hand)
        sim_state_json = item.get("sim_state", "{}")
        if not sim_state_json:
            raise ValueError("sim_state is None")
        sim_state_json_list.append(sim_state_json)
        # sim_state = parse_nested_sim_state(sim_state_json)
        sim_state_raw = sim_state_json.get("init_state","{}")
        task_name = sim_state_json.get("task_name","")
        if task_name=="":
            raise ValueError("task_name is None")
        # å¦‚æœ sim_state æ˜¯ JSON å­—ç¬¦ä¸²åˆ™è§£æ
        if not sim_state_raw:
            raise ValueError("sim_state_raw is None")
        if isinstance(sim_state_raw, str):
            sim_state_dict = json.loads(sim_state_raw)
        else:
            sim_state_dict = sim_state_raw
        sim_state = convert_nested_lists_to_tensor(sim_state_dict)
        sim_state_list.append(sim_state)
        sim_task_name_list.append(task_name)
    return robot_action, hand_action, sim_state_list,sim_task_name_list,sim_state_json_list



def load_robot_data2(json_path):
    """
    è¯»å–å¹¶è§£æ robot data.json æ–‡ä»¶ï¼Œå¹¶å°† sim_state ä¸­æ‰€æœ‰ list[list[float]] è½¬ä¸º tensorã€‚

    å‚æ•°:
        json_path (str): JSON æ–‡ä»¶è·¯å¾„

    è¿”å›:
        tuple: (robot_action: List[np.ndarray], hand_action: List[np.ndarray], sim_state: dict with torch.tensor)
    """
    with open(json_path, 'r') as f:
        content = json.load(f)

    info = content.get("info", {})
    text = content.get("text", {})
    data = content.get("data", [])
    sim_state = info.get("sim_state", "{}")
    if not sim_state:
        raise ValueError("sim_state is None")
    sim_state = parse_nested_sim_state(sim_state)
    sim_state_raw = sim_state.get("init_state","{}")
    task_name = sim_state.get("task_name","")

    if task_name=="":
        raise ValueError("task_name is None")
    # å¦‚æœ sim_state æ˜¯ JSON å­—ç¬¦ä¸²åˆ™è§£æ
    if not sim_state_raw:
        raise ValueError("sim_state_raw is None")
    if isinstance(sim_state_raw, str):
        sim_state_dict = json.loads(sim_state_raw)
    else:
        sim_state_dict = sim_state_raw

    # è½¬æ¢ sim_state æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„åµŒå¥— list -> tensor
    sim_state = convert_nested_lists_to_tensor(sim_state_dict)

    if not data:
        raise ValueError("data is None")

    robot_action = []
    hand_action = []

    for item in data:
        action = item.get("actions", {})
        if not action:
            raise ValueError("data not have action")

        left_arm = action.get("left_arm", {})
        right_arm = action.get("right_arm", {})
        left_arm_action = np.array(left_arm.get("qpos", []))
        right_arm_action = np.array(right_arm.get("qpos", []))
        left_right_arm = np.concatenate([left_arm_action, right_arm_action])

        left_hand = action.get("left_ee", {})
        right_hand = action.get("right_ee", {})
        left_hand_action = np.array(left_hand.get("qpos", []))
        right_hand_action = np.array(right_hand.get("qpos", []))
        left_right_hand = np.concatenate([right_hand_action, left_hand_action])

        robot_action.append(left_right_arm)
        hand_action.append(left_right_hand)

    return robot_action, hand_action, sim_state,task_name


def parse_nested_sim_state(json_str: str):
    # ç¬¬ä¸€æ­¥ï¼šè§£æå¤–å±‚ JSON
    outer = json.loads(json_str)

    # ç¬¬äºŒæ­¥ï¼šè§£æå†…å±‚ JSONï¼ˆinit_state æ˜¯å­—ç¬¦ä¸²ï¼‰
    if "init_state" in outer and isinstance(outer["init_state"], str):
        outer["init_state"] = json.loads(outer["init_state"])

    return outer

def get_file_path(dir):
    root_dir = Path(dir)
    json_paths = list(root_dir.glob("**/data.json"))
    pathlist = [str(p) for p in json_paths]
    return pathlist

def get_data_json_list(file_path):
    print(f"args_cli.file_path:{file_path}")
    file_path = Path(file_path)
    data_json_list=[]
    if file_path.is_file():
        if file_path.suffix == ".json":
            data_json_list.append(file_path)
        else:
            raise ValueError("file is error")
    elif file_path.is_dir():
        data_json_list = get_file_path(file_path)

    # æŒ‰ç…§episode_åé¢çš„æ•°å­—æ’åº
    def extract_episode_number(path):
        match = re.search(r'episode_(\d+)', str(path))
        return int(match.group(1)) if match else float('inf')
    
    data_json_list.sort(key=extract_episode_number)
    
    print(f"data_json_list: {data_json_list}")
    return data_json_list

def tensors_to_list(obj):
    if isinstance(obj, torch.Tensor):
        return obj.tolist()
    elif isinstance(obj, dict):
        return {k: tensors_to_list(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [tensors_to_list(i) for i in obj]
    return obj

def sim_state_to_json(data):
    data_serializable = tensors_to_list(data)
    json_str = json.dumps(data_serializable)
    return json_str

===== tools/edit_usda.py =====

import re

def modify_instanceable_flag(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    modified_lines = []
    inside_visuals_block = False
    visuals_start_re = re.compile(r'^\s*def\s+Xform\s+"visuals"\s*\(')
    instanceable_re = re.compile(r'^\s*instanceable\s*=\s*true\s*$')
    # instanceable_re = re.compile(r'^\s*instanceable\s*=\s*false\s*$')

    for line in lines:
        if visuals_start_re.match(line):
            inside_visuals_block = True
            modified_lines.append(line)
            continue

        if inside_visuals_block:
            if instanceable_re.match(line):
                # Replace 'true' with 'false'
                modified_lines.append('            instanceable = false\n')
                # modified_lines.append('            instanceable = true\n')
            else:
                modified_lines.append(line)

            if line.strip().endswith(')'):
                inside_visuals_block = False
        else:
            modified_lines.append(line)

    # ä¿å­˜ä¿®æ”¹åçš„å†…å®¹
    with open('/home/unitree/newDisk/URDF/urdf-to-usd/h1_2_inspire/h1_2_demo2.usda', 'w', encoding='utf-8') as f:
        f.writelines(modified_lines)

# ä½¿ç”¨æ–¹æ³•
modify_instanceable_flag('/home/unitree/newDisk/URDF/urdf-to-usd/h1_2_inspire/demo.usda')  # æ›¿æ¢ä¸ºä½ çš„å®é™…æ–‡ä»¶è·¯å¾„


===== tools/edit_usda_tem.py =====

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import logging
from typing import List, Set, Optional
from pathlib import Path
import re

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def modify_usda_file(input_file, output_file, target_links):
    """
    ä¿®æ”¹usdaæ–‡ä»¶
    - æ‰€æœ‰visualsä¸‹çš„instanceableæ”¹ä¸ºfalse
    - æŒ‡å®šlinkä¸‹çš„collisionsçš„instanceableæ”¹ä¸ºfalse
    """
    with open(input_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    modified_lines = []
    current_link = None
    inside_visuals_block = False
    inside_collisions_block = False
    find_target_link = False
    
    # ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼
    visuals_start_re = re.compile(r'^\s*def\s+Xform\s+"visuals"\s*\(')
    collisions_start_re = re.compile(r'\s*def\s+Xform\s+"collisions"\s*\(')
    instanceable_re = re.compile(r'^\s*instanceable\s*=\s*true\s*$')
    collisions_instanceable_re = re.compile(r'^\s*instanceable\s*=\s*true\s*$')
    
    for line in lines:
        # æ£€æŸ¥æ˜¯å¦æ˜¯Xformå®šä¹‰è¡Œ
        if 'def Xform "' in line:
            if visuals_start_re.match(line):
                inside_visuals_block = True
                modified_lines.append(line)
                continue
            elif collisions_start_re.match(line):
                inside_collisions_block = True
                modified_lines.append(line)
                continue
            else:
                # æå–linkåç§°
                current_link = line.split('"')[1]
                
                if current_link in target_links:
                    find_target_link = True
                    inside_collisions_block = False
                    inside_visuals_block = False
                modified_lines.append(line)
                continue
        # å¤„ç†visualséƒ¨åˆ†
        if inside_visuals_block:
            if instanceable_re.match(line):
                modified_lines.append('            instanceable = false\n')
            else:
                modified_lines.append(line)
            if line.strip().endswith(')'):
                inside_visuals_block = False
            continue
        # å¤„ç†collisionséƒ¨åˆ†
        if inside_collisions_block and find_target_link:
            if  instanceable_re.match(line):
                modified_lines.append('            instanceable = false\n')
            else:
                modified_lines.append(line)
            if line.strip().endswith(')'):
                inside_collisions_block = False
                find_target_link = False
            continue
        # å…¶ä»–è¡Œç›´æ¥æ·»åŠ 
        else:
            modified_lines.append(line)
            continue

    # ä¿å­˜ä¿®æ”¹åçš„å†…å®¹
    with open(output_file, 'w', encoding='utf-8') as f:
        f.writelines(modified_lines)

def main():
    """ä¸»å‡½æ•°"""
    # ä½¿ç”¨æ–¹æ³•
    target_links = [
        "right_hand_index_0_link", 
        "right_hand_index_1_link",
        "right_hand_middle_0_link",
        "right_hand_middle_1_link",
        "right_hand_thumb_0_link",
        "right_hand_thumb_1_link",
        "right_hand_thumb_2_link",
        "left_hand_index_0_link", 
        "left_hand_index_1_link",
        "left_hand_middle_0_link",
        "left_hand_middle_1_link",
        "left_hand_thumb_0_link",
        "left_hand_thumb_1_link",
        "left_hand_thumb_2_link",

        
    ]
    
    input_file = "/home/unitree/newDisk/URDF/urdf-to-usd/g1withdex3/g1_29dof_with_hand_rev_1_0.usda"
    output_file = "/home/unitree/newDisk/URDF/urdf-to-usd/g1withdex3/g1_29dof_with_hand_rev_1_0_edit.usda"
    
    try:
        modify_usda_file(input_file, output_file, target_links)
        logger.info(f"æ–‡ä»¶å¤„ç†å®Œæˆï¼Œå·²ä¿å­˜åˆ°: {output_file}")
    except Exception as e:
        logger.error(f"ç¨‹åºæ‰§è¡Œå¤±è´¥: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main()


===== tools/episode_writer.py =====

import os
import cv2
import json
import datetime
import numpy as np
import time
from .rerun_visualizer import RerunLogger
from queue import Queue, Empty
from threading import Thread
import logging_mp
logger_mp = logging_mp.get_logger(__name__)

class EpisodeWriter():
    def __init__(self, task_dir, frequency=30, image_size=[640, 480], rerun_log = True):
        """
        image_size: [width, height]
        """
        logger_mp.info("==> EpisodeWriter initializing...\n")
        self.task_dir = task_dir
        self.frequency = frequency
        self.image_size = image_size

        self.rerun_log = rerun_log
        if self.rerun_log:
            logger_mp.info("==> RerunLogger initializing...\n")
            self.rerun_logger = RerunLogger(prefix="online/", IdxRangeBoundary = 60, memory_limit = "300MB")
            logger_mp.info("==> RerunLogger initializing ok.\n")
        
        self.data = {}
        self.episode_data = []
        self.item_id = -1
        self.episode_id = -1
        if os.path.exists(self.task_dir):
            episode_dirs = [episode_dir for episode_dir in os.listdir(self.task_dir) if 'episode_' in episode_dir]
            episode_last = sorted(episode_dirs)[-1] if len(episode_dirs) > 0 else None
            self.episode_id = 0 if episode_last is None else int(episode_last.split('_')[-1])
            logger_mp.info(f"==> task_dir directory already exist, now self.episode_id is:{self.episode_id}\n")
        else:
            os.makedirs(self.task_dir)
            logger_mp.info(f"==> episode directory does not exist, now create one.\n")
        self.data_info()
        self.text_desc()

        self.is_available = True  # Indicates whether the class is available for new operations
        # Initialize the queue and worker thread
        self.item_data_queue = Queue(-1)
        self.stop_worker = False
        self.need_save = False  # Flag to indicate when save_episode is triggered
        self.worker_thread = Thread(target=self.process_queue)
        self.worker_thread.start()

        logger_mp.info("==> EpisodeWriter initialized successfully.\n")

    def data_info(self, version='1.0.0', date=None, author=None):
        self.info = {
                "version": "1.0.0" if version is None else version, 
                "date": datetime.date.today().strftime('%Y-%m-%d') if date is None else date,
                "author": "unitree" if author is None else author,
                "image": {"width":self.image_size[0], "height":self.image_size[1], "fps":self.frequency},
                "depth": {"width":self.image_size[0], "height":self.image_size[1], "fps":self.frequency},
                "audio": {"sample_rate": 16000, "channels": 1, "format":"PCM", "bits":16},    # PCM_S16
                "joint_names":{
                    "left_arm":   ['kLeftShoulderPitch' ,'kLeftShoulderRoll', 'kLeftShoulderYaw', 'kLeftElbow', 'kLeftWristRoll', 'kLeftWristPitch', 'kLeftWristyaw'],
                    "left_ee":  [],
                    "right_arm":  [],
                    "right_ee": [],
                    "body":       [],
                },

                "tactile_names": {
                    "left_ee": [],
                    "right_ee": [],
                }, 
                "sim_state": ""
            }
    def text_desc(self):
        self.text = {
            "goal": "Pick up the red cup on the table.",
            "desc": "Pick up the cup from the table and place it in another position. The operation should be smooth and the water in the cup should not spill out",
            "steps":"step1: searching for cups. step2: go to the target location. step3: pick up the cup",
        }

 
    def create_episode(self,sim_state=None):
        """
        Create a new episode.
        Returns:
            bool: True if the episode is successfully created, False otherwise.
        Note:
            Once successfully created, this function will only be available again after save_episode complete its save task.
        """
        if not self.is_available:
            logger_mp.info("==> The class is currently unavailable for new operations. Please wait until ongoing tasks are completed.")
            return False  # Return False if the class is unavailable

        # Reset episode-related data and create necessary directories
        self.item_id = -1
        self.episode_data = []
        self.episode_id = self.episode_id + 1
        
        self.episode_dir = os.path.join(self.task_dir, f"episode_{str(self.episode_id).zfill(4)}")
        self.color_dir = os.path.join(self.episode_dir, 'colors')
        self.depth_dir = os.path.join(self.episode_dir, 'depths')
        self.audio_dir = os.path.join(self.episode_dir, 'audios')
        self.json_path = os.path.join(self.episode_dir, 'data.json')
        os.makedirs(self.episode_dir, exist_ok=True)
        os.makedirs(self.color_dir, exist_ok=True)
        os.makedirs(self.depth_dir, exist_ok=True)
        os.makedirs(self.audio_dir, exist_ok=True)
        if self.rerun_log:
            self.online_logger = RerunLogger(prefix="online/", IdxRangeBoundary = 60, memory_limit="300MB")

        self.is_available = False  # After the episode is created, the class is marked as unavailable until the episode is successfully saved
        logger_mp.info(f"==> New episode created: {self.episode_dir}")
        self.info['sim_state'] = sim_state
        return True  # Return True if the episode is successfully created
        
    def add_item(self, colors, depths=None, states=None, actions=None, tactiles=None, audios=None,sim_state=None):
        # Increment the item ID
        self.item_id += 1
        # Create the item data dictionary
        item_data = {
            'idx': self.item_id,
            'colors': colors,
            'depths': depths,
            'states': states,
            'actions': actions,
            'tactiles': tactiles,
            'audios': audios,
            'sim_state': sim_state,
        }
        # Enqueue the item data
        self.item_data_queue.put(item_data)

    def process_queue(self):
        while not self.stop_worker or not self.item_data_queue.empty():
            # Process items in the queue
            try:
                item_data = self.item_data_queue.get(timeout=1)
                try:
                    self._process_item_data(item_data)
                except Exception as e:
                    logger_mp.info(f"Error processing item_data (idx={item_data['idx']}): {e}")
                self.item_data_queue.task_done()
            except Empty:
                pass
        
            # Check if save_episode was triggered
            if self.need_save and self.item_data_queue.empty():
                self._save_episode()

    def _process_item_data(self, item_data):
        idx = item_data['idx']
        colors = item_data.get('colors', {})
        depths = item_data.get('depths', {})
        audios = item_data.get('audios', {})

        # Save images
        if colors:
            for idx_color, (color_key, color) in enumerate(colors.items()):
                color_name = f'{str(idx).zfill(6)}_{color_key}.jpg'
                if not cv2.imwrite(os.path.join(self.color_dir, color_name), color):
                    logger_mp.info(f"Failed to save color image.")
                item_data['colors'][color_key] = os.path.join('colors', color_name)

        # Save depths
        if depths:
            for idx_depth, (depth_key, depth) in enumerate(depths.items()):
                depth_name = f'{str(idx).zfill(6)}_{depth_key}.jpg'
                if not cv2.imwrite(os.path.join(self.depth_dir, depth_name), depth):
                    logger_mp.info(f"Failed to save depth image.")
                item_data['depths'][depth_key] = os.path.join('depths', depth_name)

        # Save audios
        if audios:
            for mic, audio in audios.items():
                audio_name = f'audio_{str(idx).zfill(6)}_{mic}.npy'
                np.save(os.path.join(self.audio_dir, audio_name), audio.astype(np.int16))
                item_data['audios'][mic] = os.path.join('audios', audio_name)

        # Update episode data
        self.episode_data.append(item_data)

        # Log data if necessary
        if self.rerun_log:
            curent_record_time = time.time()
            logger_mp.info(f"==> episode_id:{self.episode_id}  item_id:{idx}  current_time:{curent_record_time}")
            self.rerun_logger.log_item_data(item_data)

    def save_episode(self):
        """
        Trigger the save operation. This sets the save flag, and the process_queue thread will handle it.
        """
        self.need_save = True  # Set the save flag
        logger_mp.info(f"==> Episode saved start...")

    def _save_episode(self):
        """
        Save the episode data to a JSON file.
        """
        self.data['info'] = self.info
        self.data['text'] = self.text
        self.data['data'] = self.episode_data
        with open(self.json_path, 'w', encoding='utf-8') as jsonf:
            jsonf.write(json.dumps(self.data, indent=4, ensure_ascii=False))
        self.need_save = False     # Reset the save flag
        self.is_available = True   # Mark the class as available after saving
        logger_mp.info(f"==> Episode saved successfully to {self.json_path}.")

    def close(self):
        """
        Stop the worker thread and ensure all tasks are completed.
        åœæ­¢åå°çº¿ç¨‹å¹¶ç¡®ä¿æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        """
        print("==>  Starting EpisodeWriter shutdown...")
        
        # å¦‚æœè¿˜æœ‰æœªä¿å­˜çš„æ•°æ®ï¼Œå…ˆä¿å­˜
        # If there is still unsaved data, save it first
        if not self.is_available:  # If self.is_available is False, it means there is still data not saved.
            print("==>  Saving unfinished episode...")
            self.save_episode()
            # ç­‰å¾…ä¿å­˜å®Œæˆ
            # Wait for save to complete
            while not self.is_available:
                time.sleep(0.01)
        
        # åœæ­¢å·¥ä½œçº¿ç¨‹
        # Stop worker thread
        print("==> Stopping worker thread...")
        self.stop_worker = True
        
        # ç­‰å¾…é˜Ÿåˆ—å¤„ç†å®Œæˆ
        # Wait for queue processing to complete
        try:
            self.item_data_queue.join()
        except Exception as e:
            print(f"==>  Error waiting for queue completion: {e}")
        
        # ç­‰å¾…å·¥ä½œçº¿ç¨‹ç»“æŸ
        # Wait for worker thread to finish
        if self.worker_thread and self.worker_thread.is_alive():
            print("==>  Waiting for worker thread to finish...")
            self.worker_thread.join(timeout=5.0)  # 5ç§’è¶…æ—¶
            if self.worker_thread.is_alive():
                print("==>  Warning: Worker thread did not finish within timeout")
        
        print("==> EpisodeWriter shutdown completed")

===== tools/get_reward.py =====

#
# å®ç”¨å‡½æ•°ï¼šå¦‚ä½•è·å–å¥–åŠ±å€¼
##
import torch

def get_step_reward_value(env) -> torch.Tensor:
    """
    å¿«é€Ÿè·å–å½“å‰ç¯å¢ƒçš„æ€»å¥–åŠ±å€¼
    
    Args:
        env: ManagerBasedRLEnv ç¯å¢ƒå®ä¾‹
        
    Returns:
        torch.Tensor: å½“å‰çš„æ€»å¥–åŠ±å€¼ï¼Œå¦‚æœå¤±è´¥è¿”å›é›¶å¼ é‡
    """
    try:
        if hasattr(env, 'reward_manager'):
            return env.reward_manager.get_active_iterable_terms(0)[0][1][0]#.compute(dt=dt)
        else:
            return torch.zeros(env.num_envs, device=env.device)
    except Exception as e:
        print(f"è·å–å¥–åŠ±å€¼æ—¶å‡ºé”™: {e}")
        return torch.zeros(env.num_envs, device=env.device)


def get_current_rewards(env) -> dict:
    """
    è·å–å½“å‰ç¯å¢ƒçš„å¥–åŠ±å€¼
    
    Args:
        env: ManagerBasedRLEnv ç¯å¢ƒå®ä¾‹
        
    Returns:
        dict: åŒ…å«å¥–åŠ±ä¿¡æ¯çš„å­—å…¸
    """
    
    try:
        # æ–¹æ³•1: é€šè¿‡å¥–åŠ±ç®¡ç†å™¨è®¡ç®—å½“å‰å¥–åŠ±
        if hasattr(env, 'reward_manager'):
            # Isaac Lab çš„å¥–åŠ±ç®¡ç†å™¨éœ€è¦ dt å‚æ•°
            dt = env.physics_dt if hasattr(env, 'physics_dt') else 0.02  # é»˜è®¤ä½¿ç”¨ 0.02 ç§’
            current_rewards = env.reward_manager.compute(dt=dt)
            return current_rewards
            
            # print(f"current_rewards: {current_rewards}")
            
    except Exception as e:
        print(f"è·å–å¥–åŠ±å€¼æ—¶å‡ºé”™: {e}")
        return torch.zeros(env.num_envs, device=env.device)




===== tools/get_stiffness.py =====

def get_robot_stiffness_from_env(env):
    """
    Get robot joint stiffness/damping parameters from runtime environment
    Access through env.scene["robot"].data
    """
    print("ğŸ” Getting joint kp/kd parameters from runtime environment...")
    
    try:
        if not hasattr(env, 'scene'):
            print("âŒ Environment has no 'scene' attribute")
            return None
        
        # Display available scene entities
        try:
            scene_keys = list(env.scene.keys()) if hasattr(env.scene, 'keys') else "Unable to get"
            print(f"ğŸ“‹ Available entities in scene: {scene_keys}")
        except:
            print("ğŸ“‹ Unable to get scene entity list")
            
        # Try to access robot object directly
        try:
            robot = env.scene["robot"]
            print(f"âœ… Found robot object: {type(robot)}")
        except KeyError as e:
            print(f"âŒ Cannot access robot object: {e}")
            return None
        
        if not hasattr(robot, 'data'):
            print("âŒ Robot object has no 'data' attribute")
            return None
            
        robot_data = robot.data
        print(f"âœ… Found robot.data object: {type(robot_data)}")
        
        # Explore all attributes in robot.data
        print("\nğŸ“Š Available attributes in robot.data:")
        print("-" * 60)
        
        data_attrs = [attr for attr in dir(robot_data) if not attr.startswith('_')]
        print(f"ğŸ“ˆ Total attributes: {len(data_attrs)}")
        
        stiffness_attrs = []
        damping_attrs = []
        joint_attrs = []
        other_attrs = []
        
        for attr in data_attrs:
            if 'stiff' in attr.lower():
                stiffness_attrs.append(attr)
            elif 'damp' in attr.lower():
                damping_attrs.append(attr)
            elif 'joint' in attr.lower():
                joint_attrs.append(attr)
            else:
                other_attrs.append(attr)
        
        # Display joint-related attributes
        if joint_attrs:
            print(f"\nğŸ”— Joint-related attributes:")
            for attr in joint_attrs:
                try:
                    value = getattr(robot_data, attr)
                    print(f"   ğŸ“Œ {attr}: {type(value)} - shape: {getattr(value, 'shape', 'N/A')}")
                except Exception as e:
                    print(f"   ğŸ“Œ {attr}: Cannot access - {e}")
        
        # Display stiffness-related attributes
        if stiffness_attrs:
            print(f"\nğŸ’ª Stiffness-related attributes:")
            for attr in stiffness_attrs:
                try:
                    value = getattr(robot_data, attr)
                    print(f"   ğŸ“Œ {attr}: {type(value)} - shape: {getattr(value, 'shape', 'N/A')}")
                    if hasattr(value, 'shape') and len(value.shape) <= 2:
                        print(f"      Value: {value}")
                except Exception as e:
                    print(f"   ğŸ“Œ {attr}: Cannot access - {e}")
        
        # Display damping-related attributes
        if damping_attrs:
            print(f"\nğŸ› ï¸ Damping-related attributes:")
            for attr in damping_attrs:
                try:
                    value = getattr(robot_data, attr)
                    print(f"   ğŸ“Œ {attr}: {type(value)} - shape: {getattr(value, 'shape', 'N/A')}")
                    if hasattr(value, 'shape') and len(value.shape) <= 2:
                        print(f"      Value: {value}")
                except Exception as e:
                    print(f"   ğŸ“Œ {attr}: Cannot access - {e}")
        
        # Display all potentially relevant attributes
        print(f"\nâš™ï¸ All potentially relevant attributes (first 20):")
        control_keywords = ['default', 'joint', 'pos', 'vel', 'stiff', 'damp', 'kp', 'kd', 'control', 'target', 'limit']
        relevant_attrs = []
        
        for attr in data_attrs:
            if any(keyword in attr.lower() for keyword in control_keywords):
                relevant_attrs.append(attr)
        
        for attr in relevant_attrs[:20]:  # Show only first 20
            try:
                value = getattr(robot_data, attr)
                shape_info = getattr(value, 'shape', 'N/A')
                print(f"   ğŸ“Œ {attr}: {type(value).__name__} - shape: {shape_info}")
            except Exception as e:
                print(f"   ğŸ“Œ {attr}: Cannot access - {e}")
        
        if len(relevant_attrs) > 20:
            print(f"   ... {len(relevant_attrs) - 20} more relevant attributes")

        # Try common attribute names
        common_stiffness_names = [
            'default_joint_stiffness',
            'joint_stiffness', 
            'stiffness',
            'kp',
            'default_kp',
            'default_joint_pos_target',
            'joint_pos_target'
        ]
        
        common_damping_names = [
            'default_joint_damping',
            'joint_damping',
            'damping', 
            'kd',
            'default_kd',
            'default_joint_vel_target',
            'joint_vel_target'
        ]
        
        print(f"\nğŸ” Trying common parameter names:")
        stiffness_found = None
        damping_found = None
        
        for name in common_stiffness_names:
            if hasattr(robot_data, name):
                try:
                    stiffness_found = getattr(robot_data, name)
                    print(f"   âœ… Found stiffness: {name}")
                    print(f"      Type: {type(stiffness_found)}")
                    print(f"      Shape: {getattr(stiffness_found, 'shape', 'N/A')}")
                    if hasattr(stiffness_found, 'shape') and len(stiffness_found.shape) <= 2:
                        print(f"      Value: {stiffness_found}")
                    break
                except Exception as e:
                    print(f"   âš ï¸ {name} exists but cannot access: {e}")
        
        for name in common_damping_names:
            if hasattr(robot_data, name):
                try:
                    damping_found = getattr(robot_data, name)
                    print(f"   âœ… Found damping: {name}")
                    print(f"      Type: {type(damping_found)}")  
                    print(f"      Shape: {getattr(damping_found, 'shape', 'N/A')}")
                    if hasattr(damping_found, 'shape') and len(damping_found.shape) <= 2:
                        print(f"      Value: {damping_found}")
                    break
                except Exception as e:
                    print(f"   âš ï¸ {name} exists but cannot access: {e}")
        
        # Check articulation object
        if hasattr(robot, 'articulation') and robot.articulation is not None:
            print(f"\nğŸ”§ Checking articulation object:")
            articulation = robot.articulation
            print(f"   Type: {type(articulation)}")
            
            # Try articulation methods
            if hasattr(articulation, 'get_stiffnesses'):
                try:
                    artic_stiffness = articulation.get_stiffnesses()
                    print(f"   âœ… articulation.get_stiffnesses(): {artic_stiffness}")
                    if stiffness_found is None:
                        stiffness_found = artic_stiffness
                except Exception as e:
                    print(f"   âš ï¸ get_stiffnesses() failed: {e}")
                    
            if hasattr(articulation, 'get_dampings'):
                try:
                    artic_damping = articulation.get_dampings()
                    print(f"   âœ… articulation.get_dampings(): {artic_damping}")
                    if damping_found is None:
                        damping_found = artic_damping
                except Exception as e:
                    print(f"   âš ï¸ get_dampings() failed: {e}")
        
        # Return results
        result = {
            'stiffness': stiffness_found,
            'damping': damping_found,
            'robot_data': robot_data
        }
        
        print(f"\nâœ… Parameter acquisition complete!")
        if stiffness_found is not None or damping_found is not None:
            print("ğŸ‰ Successfully found at least one parameter!")
        else:
            print("âš ï¸ No expected parameters found")
            
        return result
        
    except Exception as e:
        print(f"âŒ Error getting parameters: {e}")
        import traceback
        traceback.print_exc()
        return None


===== tools/rerun_visualizer.py =====

import os
import json
import cv2
import time
import rerun as rr
import rerun.blueprint as rrb
from datetime import datetime

class RerunEpisodeReader:
    def __init__(self, task_dir = ".", json_file="data.json"):
        self.task_dir = task_dir
        self.json_file = json_file

    def return_episode_data(self, episode_idx):
        # Load episode data on-demand
        episode_dir = os.path.join(self.task_dir, f"episode_{episode_idx:04d}")
        json_path = os.path.join(episode_dir, self.json_file)

        if not os.path.exists(json_path):
            raise FileNotFoundError(f"Episode {episode_idx} data.json not found.")

        with open(json_path, 'r', encoding='utf-8') as jsonf:
            json_file = json.load(jsonf)

        episode_data = []

        # Loop over the data entries and process each one
        for item_data in json_file['data']:
            # Process images and other data
            colors = self._process_images(item_data, 'colors', episode_dir)
            depths = self._process_images(item_data, 'depths', episode_dir)
            audios = self._process_audio(item_data, 'audios', episode_dir)

            # Append the data in the item_data list
            episode_data.append(
                {
                    'idx': item_data.get('idx', 0),
                    'colors': colors,
                    'depths': depths,
                    'states': item_data.get('states', {}),
                    'actions': item_data.get('actions', {}),
                    'tactiles': item_data.get('tactiles', {}),
                    'audios': audios,
                }
            )

        return episode_data

    def _process_images(self, item_data, data_type, dir_path):
        images = {}

        for key, file_name in item_data.get(data_type, {}).items():
            if file_name:
                file_path = os.path.join(dir_path, file_name)
                if os.path.exists(file_path):
                    image = cv2.imread(file_path)
                    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
                    images[key] = image
        return images

    def _process_audio(self, item_data, data_type, episode_dir):
        audio_data = {}
        dir_path = os.path.join(episode_dir, data_type)

        for key, file_name in item_data.get(data_type, {}).items():
            if file_name:
                file_path = os.path.join(dir_path, file_name)
                if os.path.exists(file_path):
                    pass  # Handle audio data if needed
        return audio_data

class RerunLogger:
    def __init__(self, prefix = "", IdxRangeBoundary = 30, memory_limit = None):
        self.prefix = prefix
        self.IdxRangeBoundary = IdxRangeBoundary
        rr.init(datetime.now().strftime("Runtime_%Y%m%d_%H%M%S"))
        if memory_limit:
            rr.spawn(memory_limit = memory_limit, hide_welcome_screen = True)
        else:
            rr.spawn(hide_welcome_screen = True)

        # Set up blueprint for live visualization
        if self.IdxRangeBoundary:
            self.setup_blueprint()

    def setup_blueprint(self):
        views = []

        data_plot_paths = [
                           f"{self.prefix}left_arm", 
                           f"{self.prefix}right_arm", 
                           f"{self.prefix}left_ee", 
                           f"{self.prefix}right_ee"
        ]
        for plot_path in data_plot_paths:
            view = rrb.TimeSeriesView(
                origin = plot_path,
                time_ranges=[
                    rrb.VisibleTimeRange(
                        "idx",
                        start = rrb.TimeRangeBoundary.cursor_relative(seq = -self.IdxRangeBoundary),
                        end = rrb.TimeRangeBoundary.cursor_relative(),
                    )
                ],
                plot_legend = rrb.PlotLegend(visible = True),
            )
            views.append(view)

        # image_plot_paths = [
        #                     f"{self.prefix}colors/color_0",
        #                     f"{self.prefix}colors/color_1",
        #                     f"{self.prefix}colors/color_2",
        #                     f"{self.prefix}colors/color_3"
        # ]
        # for plot_path in image_plot_paths:
        #     view = rrb.Spatial2DView(
        #         origin = plot_path,
        #         time_ranges=[
        #             rrb.VisibleTimeRange(
        #                 "idx",
        #                 start = rrb.TimeRangeBoundary.cursor_relative(seq = -self.IdxRangeBoundary),
        #                 end = rrb.TimeRangeBoundary.cursor_relative(),
        #             )
        #         ],
        #     )
        #     views.append(view)

        grid = rrb.Grid(contents = views,
                        grid_columns=2,               
                        column_shares=[1, 1],
                        row_shares=[1, 1], 
        )
        views.append(rr.blueprint.SelectionPanel(state=rrb.PanelState.Collapsed))
        views.append(rr.blueprint.TimePanel(state=rrb.PanelState.Collapsed))
        rr.send_blueprint(grid)


    def log_item_data(self, item_data: dict):
        rr.set_time_sequence("idx", item_data.get('idx', 0))

        # Log states
        states = item_data.get('states', {}) or {}
        for part, state_info in states.items():
            if part != "body" and state_info:
                values = state_info.get('qpos', [])
                for idx, val in enumerate(values):
                    rr.log(f"{self.prefix}{part}/states/qpos/{idx}", rr.Scalar(val))

        # Log actions
        actions = item_data.get('actions', {}) or {}
        for part, action_info in actions.items():
            if part != "body" and action_info:
                values = action_info.get('qpos', [])
                for idx, val in enumerate(values):
                    rr.log(f"{self.prefix}{part}/actions/qpos/{idx}", rr.Scalar(val))

        # # Log colors (images)
        # colors = item_data.get('colors', {}) or {}
        # for color_key, color_val in colors.items():
        #     if color_val is not None:
        #         rr.log(f"{self.prefix}colors/{color_key}", rr.Image(color_val))

        # # Log depths (images)
        # depths = item_data.get('depths', {}) or {}
        # for depth_key, depth_val in depths.items():
        #     if depth_val is not None:
        #         # rr.log(f"{self.prefix}depths/{depth_key}", rr.Image(depth_val))
        #         pass # Handle depth if needed

        # # Log tactile if needed
        # tactiles = item_data.get('tactiles', {}) or {}
        # for hand, tactile_vals in tactiles.items():
        #     if tactile_vals is not None:
        #         pass # Handle tactile if needed

        # # Log audios if needed
        # audios = item_data.get('audios', {}) or {}
        # for audio_key, audio_val in audios.items():
        #     if audio_val is not None:
        #         pass  # Handle audios if needed

    def log_episode_data(self, episode_data: list):
        for item_data in episode_data:
            self.log_item_data(item_data)


if __name__ == "__main__":
    import gdown
    import zipfile
    import os
    import logging_mp
    logger_mp = logging_mp.get_logger(__name__, level=logging_mp.INFO)

    zip_file = "rerun_testdata.zip"
    zip_file_download_url = "https://drive.google.com/file/d/1f5UuFl1z_gaByg_7jDRj1_NxfJZh2evD/view?usp=sharing"
    unzip_file_output_dir = "./testdata"
    if not os.path.exists(os.path.join(unzip_file_output_dir, "episode_0006")):
        if not os.path.exists(zip_file):
            file_id = zip_file_download_url.split('/')[5]
            gdown.download(id=file_id, output=zip_file, quiet=False)
            logger_mp.info("download ok.")
        if not os.path.exists(unzip_file_output_dir):
            os.makedirs(unzip_file_output_dir)
        with zipfile.ZipFile(zip_file, 'r') as zip_ref:
            zip_ref.extractall(unzip_file_output_dir)
        logger_mp.info("uncompress ok.")
        os.remove(zip_file)
        logger_mp.info("clean file ok.")
    else:
        logger_mp.info("rerun_testdata exits.")


    episode_reader = RerunEpisodeReader(task_dir = unzip_file_output_dir)
    # TEST EXAMPLE 1 : OFFLINE DATA TEST
    user_input = input("Please enter the start signal (enter 'off' or 'on' to start the subsequent program):\n")
    if user_input.lower() == 'off':
        episode_data6 = episode_reader.return_episode_data(6)
        logger_mp.info("Starting offline visualization...")
        offline_logger = RerunLogger(prefix="offline/")
        offline_logger.log_episode_data(episode_data6)
        logger_mp.info("Offline visualization completed.")

    # TEST EXAMPLE 2 : ONLINE DATA TEST, SLIDE WINDOW SIZE IS 60, MEMORY LIMIT IS 50MB
    if user_input.lower() == 'on':
        episode_data8 = episode_reader.return_episode_data(8)
        logger_mp.info("Starting online visualization with fixed idx size...")
        online_logger = RerunLogger(prefix="online/", IdxRangeBoundary = 60, memory_limit='50MB')
        for item_data in episode_data8:
            online_logger.log_item_data(item_data)
            time.sleep(0.033) # 30hz
        logger_mp.info("Online visualization completed.")


    # # TEST DATA OF data_dir
    # data_dir = "./data"
    # episode_data_number = 10
    # episode_reader2 = RerunEpisodeReader(task_dir = data_dir)
    # user_input = input("Please enter the start signal (enter 'on' to start the subsequent program):\n")
    # episode_data8 = episode_reader2.return_episode_data(episode_data_number)
    # if user_input.lower() == 'on':
    #     # Example 2: Offline Visualization with Fixed Time Window
    #     logger_mp.info("Starting offline visualization with fixed idx size...")
    #     online_logger = RerunLogger(prefix="offline/", IdxRangeBoundary = 60)
    #     for item_data in episode_data8:
    #         online_logger.log_item_data(item_data)
    #         time.sleep(0.033) # 30hz
    #     logger_mp.info("Offline visualization completed.")